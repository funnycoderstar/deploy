(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{446:function(_,v,t){"use strict";t.r(v);var a=t(33),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"三次握手，四次挥手，为什么是三次和四次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手，四次挥手，为什么是三次和四次"}},[_._v("#")]),_._v(" 三次握手，四次挥手，为什么是三次和四次")]),_._v(" "),t("h3",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),t("ol",[t("li",[_._v("发送端首先发送一个带SYN标志的数据包给对方")]),_._v(" "),t("li",[_._v("接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息")]),_._v(" "),t("li",[_._v("最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。")])]),_._v(" "),t("p",[_._v("若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。")]),_._v(" "),t("h3",{attrs:{id:"握手为什么是三次？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#握手为什么是三次？"}},[_._v("#")]),_._v(" 握手为什么是三次？")]),_._v(" "),t("p",[_._v("三次握手其实就是建立一个TCP连接时，需要客户端和服务器总共发出3个包，进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常。指定自己的初始化序列号为后面的可靠性传送做准备。")]),_._v(" "),t("p",[_._v("第一次握手：客户端发送网络包，服务端收到了。\n这样服务端就能得出结论：客户端的发送能力。服务端的接收能力是正常的。")]),_._v(" "),t("p",[_._v("第二次握手：服务端发包，客户端收到了。\n这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收。发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。")]),_._v(" "),t("p",[_._v("第三次握手：客户端发包，服务端收到了。\n这样服务端就能得出结论：客户端的接收。发送能力正常，服务器自己的发送、接收能力也正常。")]),_._v(" "),t("p",[_._v("试想如果是用两次握手，则会出现下面这种情况：")]),_._v(" "),t("blockquote",[t("p",[_._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])]),_._v(" "),t("h3",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),t("ol",[t("li",[_._v("第一次挥手：主动关闭方发送一个"),t("code",[_._v("FIN")]),_._v("，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的"),t("code",[_._v("ack")]),_._v("确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。")]),_._v(" "),t("li",[_._v("第二次挥手：被动关闭方收到"),t("code",[_._v("FIN")]),_._v("包后，发送一个"),t("code",[_._v("ACK")]),_._v("给对方，确认序号为收到序号+1（与"),t("code",[_._v("SYN")]),_._v("相同，一个"),t("code",[_._v("FIN")]),_._v("占用一个序号）。")]),_._v(" "),t("li",[_._v("第三次挥手：被动关闭方发送一个"),t("code",[_._v("FIN")]),_._v("，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。")]),_._v(" "),t("li",[_._v("第四次挥手：主动关闭方收到 "),t("code",[_._v("FIN")]),_._v("后，发送一个"),t("code",[_._v("ACK")]),_._v("给被动关闭方，确认序号为收到序号"),t("code",[_._v("+1")]),_._v("，至此，完成四次挥手。")])]),_._v(" "),t("h3",{attrs:{id:"挥手为什么是四次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#挥手为什么是四次"}},[_._v("#")]),_._v(" 挥手为什么是四次?")]),_._v(" "),t("p",[_._v("因为当服务端收到客户端的SYN连接请求报文后，可以直接发送 SYN + ACK 报文。其中 ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。")]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/86426969",target:"_blank",rel:"noopener noreferrer"}},[_._v("面试官，不要再问我三次握手和四次挥手"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=e.exports}}]);