(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{462:function(t,e,a){"use strict";a.r(e);var s=a(33),c=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"react-setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-setstate"}},[t._v("#")]),t._v(" react setState")]),t._v(" "),a("ul",[a("li",[t._v("react的setstate过程， 收到新state怎么更新，发生了什么事情")]),t._v(" "),a("li",[t._v("说一下几种情况的setstate的输出，为什么")])]),t._v(" "),a("p",[t._v('在React中，如果是由React引发的事件处理（比如通过 onClick引发的事件处理），调用 setState 不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓"除此之外”，指的是绕过React通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval产生的异步调用。')]),t._v(" "),a("p",[t._v("在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。")])])}),[],!1,null,null,null);e.default=c.exports}}]);