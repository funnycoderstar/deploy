(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{440:function(t,e,a){"use strict";a.r(e);var r=a(33),T=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"http1-x、http2、http3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-x、http2、http3"}},[t._v("#")]),t._v(" HTTP1.x、HTTP2、HTTP3")]),t._v(" "),a("ul",[a("li",[t._v("HTTP1.0 和HTTP1.1的一些区别")]),t._v(" "),a("li",[t._v("HTTP2.0和HTTP1.X相比的新特性")]),t._v(" "),a("li",[t._v("为什么 HTTP1.1 不能实现多路复用")]),t._v(" "),a("li",[t._v("多路复用和 keep alive区别")])]),t._v(" "),a("h3",{attrs:{id:"http1-0-和http1-1的一些区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-和http1-1的一些区别"}},[t._v("#")]),t._v(" http1.0 和HTTP1.1的一些区别")]),t._v(" "),a("ul",[a("li",[t._v("长连接\n"),a("ul",[a("li",[t._v("在HTTP1.1中默认开启Connection： keep-alive，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟")])])]),t._v(" "),a("li",[t._v("缓存处理\n"),a("ul",[a("li",[t._v("http1.0 主要使用header中的Exprires， If-Modified-Since来做为缓存判断的标准")]),t._v(" "),a("li",[t._v("HTTP1.1 Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")])])]),t._v(" "),a("li",[t._v("带宽优化及网络连接的使用\n"),a("ul",[a("li",[t._v("HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）")])])]),t._v(" "),a("li",[t._v("Host头处理\n"),a("ul",[a("li",[t._v("在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误")])])])]),t._v(" "),a("h3",{attrs:{id:"http2-0和http1-x相比的新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2-0和http1-x相比的新特性"}},[t._v("#")]),t._v(" HTTP2.0和HTTP1.X相比的新特性")]),t._v(" "),a("h4",{attrs:{id:"http1-x存在的问题："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-x存在的问题："}},[t._v("#")]),t._v(" HTTP1.x存在的问题：")]),t._v(" "),a("ol",[a("li",[t._v("TCP连接数限制\n对于同一个域名，浏览器最多只能同时创建6 ~ 8个TCP链接。为了解决数量的限制，出现 域名分片技术。")]),t._v(" "),a("li",[t._v("队头阻塞(Head-Of-Line Blocking)\n当HTTP开启长连接时，共用一个TCP连接，同一时刻只能处理一个请求，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。")]),t._v(" "),a("li",[t._v("header内容多，并且每次请求 Header不会变化太多，没有相应的压缩传输优化方案")]),t._v(" "),a("li",[t._v("为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制")]),t._v(" "),a("li",[t._v("明文传输不安全")])]),t._v(" "),a("h4",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("二进制传输\nHTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩， HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效\nHTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧。")])]),t._v(" "),a("li",[a("p",[t._v("多路复用\n在一个TCP连接上，我们可以向对方不断发送帧，每帧的 stream identifier 标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。 把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。")])]),t._v(" "),a("li",[a("p",[t._v("header压缩\n使用 "),a("a",{attrs:{href:"https://httpwg.org/specs/rfc7541.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HPACK"),a("OutboundLink")],1),t._v(" 算法来压缩首部内容")])]),t._v(" "),a("li",[a("p",[t._v('服务端推送\n浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）')])])]),t._v(" "),a("p",[t._v("HTTP/1 的几种优化可以弃用:\n合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多")]),t._v(" "),a("h3",{attrs:{id:"为什么-http1-1-不能实现多路复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么-http1-1-不能实现多路复用"}},[t._v("#")]),t._v(" 为什么 HTTP1.1 不能实现多路复用")]),t._v(" "),a("p",[t._v("HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。")]),t._v(" "),a("h3",{attrs:{id:"多路复用和-keep-alive区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用和-keep-alive区别"}},[t._v("#")]),t._v(" 多路复用和 keep alive区别")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.suisuijiang.com/ImageMessage/5adad39555703565e79040fa_1559269633983.png",alt:"img"}})]),t._v(" "),a("ol",[a("li",[t._v("队头阻塞（Head-of-Line Blocking），HTTP1.X虽然可以采用Keep alive来解决复用TCP的问题，但是还是无法解决请求阻塞；")]),t._v(" "),a("li",[t._v("所谓请求阻塞意思就是一条 TCP 的connection在同一时间只允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。")]),t._v(" "),a("li",[t._v("之所以有这个问题就是因为HTTP1.x需要每条请求都是可以识别，按顺序发送，否则serve就无法判断该响应哪个具体的请求。")]),t._v(" "),a("li",[t._v("HTTP2采用多路复用是指，在同一个域名下，开启一个TCP的connection，每个请求以stream的方式传输，每个stream有唯一的标识，connection一旦建立，后续的请求都可以复用这个connection并且可以同时发送，server端可以根据stream的唯一标识来响应对应的请求。")])]),t._v(" "),a("h3",{attrs:{id:"http3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[t._v("#")]),t._v(" http3")]),t._v(" "),a("h4",{attrs:{id:"http-2-的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的缺点"}},[t._v("#")]),t._v(" HTTP/2 的缺点")]),t._v(" "),a("p",[t._v("尽管HTTP/2解决了很多1.1的问题，但HTTP/2仍然存在一些缺陷，这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。")]),t._v(" "),a("h4",{attrs:{id:"http3-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http3-2"}},[t._v("#")]),t._v(" http3")]),t._v(" "),a("p",[t._v("由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP/3选择了一个折衷的方法——UDP协议，HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/34074946",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP/2 相比 1.0 有哪些重大改进？"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.jianshu.com/p/be29d679cbff",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP1.0、HTTP1.1和HTTP2.0的区别"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5b88a4f56fb9a01a0b31a67e",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP2 详解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5d9abde7e51d4578110dc77f",target:"_blank",rel:"noopener noreferrer"}},[t._v("解密HTTP/2与HTTP/3 的新特性"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=T.exports}}]);