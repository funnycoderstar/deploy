<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CORS原理及@koa/cors源码解析]]></title>
    <url>%2F2019%2F06%2F15%2F2019-06-21%2F</url>
    <content type="text"><![CDATA[目录 跨域 简单请求和复杂请求 服务端如何设置CORS @koa/cors是怎么实现的 跨域为什么会有跨域问题？这是浏览器的同源策略所造成的，同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 一定要注意跨域是浏览器的限制，其实你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。 如何解决跨域? jsonp: 带有src属性的标签都可以用来， 但是只能处理GET请求 document.domain + iframe跨域 location.hash + iframe window.name + iframe postMessage跨域 Nginx配置反向代理 CORS（跨域资源共享）：支持所有类型的HTTP请求相信大家对于以上的解决方法都很熟悉，这里不再对每一种方法展开讲解，接下来主要讲一下CORS； 简单请求和非简单请求浏览器将CORS跨域请求分为简单请求和非简单请求； 如果你使用nginx反向代理解决的跨域问题，则不会有跨域请求这个说法了，因为nginx反向代理就使得前后端是同一个域了，就不存在跨域问题了。 只要同时满足一下两个条件，就属于简单请求(1)使用下列方法之一： head get post (2)请求的Heder是 Accept Accept-Language Content-Language Content-Type: 只限于三个值： application/x-www-form-urlencoded multipart/form-data text/plain 不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。 简单请求例子对于简单请求，浏览器直接发出CORS请求。具体来说，就是头信息之中，增加一个Origin字段。上面这个例子，post请求，Content-Type为application/x-www-form-urlencoded，满足简单请求的条件；响应头部返回Access-Control-Allow-Origin: http://127.0.0.1:3000;浏览器发现这次跨域请求是简单请求，就自动在头信息之中，添加一个Origin字段；Origin字段用来说明请求来自哪个源（协议+域名+端口号）。服务端根据这个值，决定是否同意本次请求。 CORS请求相关的字段，都以 Access-Control-开头 Access-Control-Allow-Origin：必选 请求头Origin字段的值 *：接受任何域名 Access-Control-Allow-Credentials：可选， true: 表示允许发送cookie，此时Access-Control-Allow-Origin不能设置为*，必须指定明确的，与请求网页一致的域名。 不设置该字段：不需要浏览器发送cookie Access-Control-Expose-Headers：可选 响应报头指示哪些报头可以公开为通过列出他们的名字的响应的一部分。默认情况下，只显示6个简单的响应标头： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。 withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面需要服务器同意，设置响应头Access-Control-Allow-Credentials: true,另一方面在客户端发出请求的时候也要进行一些设置;12345678910// XHRvar xhr = new XMLHttpRequest();xhr.open('GET', 'http://example.com/', true); xhr.withCredentials = true; xhr.send(null);// Fetchfetch(url, &#123; credentials: 'include' &#125;) 非简单请求非简单请求就是那种对服务器有特殊要求的请求，比如请求方法为PUT或DELETE，或者Content-Type字段为application/json; 1. 预检请求和回应非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求；浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的接口请求，否则就会报错； HTTP请求的方法是POST，请求头Content-Type字段为application/json。浏览器发现，这是一个非简单请求，就自动发出一个预检请求，要求服务器确认可以这样请求。 1.1预检请求预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个域。除了Origin，预检请求的头信息包括两个特殊字段： Access-Control-Request-Method： 必选，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是POST Access-Control-Request-Headers：该字段是一个用逗号分割的字符串，执行浏览器CORS请求会额外发送的头信息字段，上例是Content-Type; 1.2预检回应服务器收到预检请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨域请求，就可以做出回应。上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://127.0.0.1:3000可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了“预检”请求，就会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段，这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获h。 服务器回应的其他CORS字段 Access-Control-Allow-Methods：必需；它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的方法。这是为了避免多次预检请求。 Access-Control-Allow-Headers：如果浏览器请求头里包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段。 Access-Control-Allow-Credentials：与简单请求时含义相同。 Access-Control-Allow-Max-Age: 可选，用来指定本次预检请求的有效期。单位为秒。在有效期内，不用发出另一条预检请求 2.正常请求和回应一旦服务器通过了预检请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段； 服务端如何设置CORS单独接口单独处理比如一个简单的登录页面，需要给接口接口传入 username和password 两个字段；前端的域名为 localhost:8900，后端的域名为 localhost:3200，构成跨域。 1. 如果设置请求头&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;，这种情况则为简单请求；会有跨域问题，直接设置 响应头 Access-Control-Allow-Origin为*, 或者具体的域名；注意如果设置响应头Access-Control-Allow-Credentials为true，表示要发送cookie，则此时Access-Control-Allow-Origin的值不能设置为星号，必须指定明确的，与请求网页一致的域名。 123456789const login = ctx =&gt; &#123; const req = ctx.request.body; const userName = req.userName; ctx.set('Access-Control-Allow-Origin', '*'); ctx.response.body = &#123; data: &#123;&#125;, msg: '登陆成功' &#125;;&#125; 2. 如果设置请求头&#39;Content-Type&#39;: &#39;application/json&#39;，这种情况则为非简单请求处理OPTIONS请求，服务端可以单独写一个路由，来处理login的OPTIONS的请求 123456app.use(route.options('/login', ctx =&gt; &#123; ctx.set('Access-Control-Allow-Origin', '*'); ctx.set('Access-Control-Allow-Headers', 'Content-Type'); ctx.status = 204; &#125;)); 大家都知道前端调用服务端的时候，会调用很多个接口，并且每个接口处理跨域请求的逻辑是完全一样的，我们可以把这部分抽离出来，作为一个中间件； 写一个中间件进行处理首先了解一下koa中间件的“洋葱圈”模型 将洋葱的一圈看做是一个中间件，直线型就是从第一个中间件走到最后一个，但是洋葱圈就很特殊了，最早use的中间件在洋葱最外层，开始的时候会按照顺序走到所有中间件，然后按照倒序再走一遍所有的中间件，相当于每个中间件都会进入两次，这就给了我们更多的操作空间。123456789101112131415161718192021const Koa = require("koa");const app = new Koa();app.use((ctx, next) =&gt; &#123; console.log('a - 1'); next(); console.log('a - 2');&#125;)app.use((ctx, next) =&gt; &#123; console.log('b - 1'); next(); console.log('b - 2');&#125;)app.use((ctx, next) =&gt; &#123; console.log('c - 1'); next(); console.log('c - 2');&#125;)app.listen(3200, () =&gt; &#123; console.log('启动成功');&#125;); 输出123456a - 1b - 1c - 1c - 2b - 2a - 2 Koa官方文档上把外层的中间件称为“上游”，内层的中间件为“下游”。一般的中间件都会执行两次，调用next之前为一次，调用next时把控制按顺序传递给下游的中间件。当下游不再有中间件或者中间件没有执行 next 函数时，就将依次恢复上游中间件的行为，让上游中间件执行 next之后的代码； 处理跨域的中间件简单示例123456789101112131415161718192021222324252627282930313233343536373839const Koa = require("koa");const app = new Koa();const route = require('koa-route');var bodyParser = require('koa-bodyparser');app.use(bodyParser()); // 处理post请求的参数const login = ctx =&gt; &#123; const req = ctx.request.body; const userName = req.userName; const expires = Date.now() + 3600000; // 设置超时时间为一小时后 var payload = &#123; iss: userName, exp: expires &#125;; const Token = jwt.encode(payload, secret); ctx.response.body = &#123; data: Token, msg: '登陆成功' &#125;;&#125;// 将公共逻辑方法放到中间件中处理app.use((ctx, next)=&gt; &#123; const headers = ctx.request.headers; if(ctx.method === 'OPTIONS') &#123; ctx.set('Access-Control-Allow-Origin', '*'); ctx.set('Access-Control-Allow-Headers', 'Authorization'); ctx.status = 204; &#125; else &#123; next(); &#125;&#125;)app.use(route.post('/login', login));app.listen(3200, () =&gt; &#123; console.log('启动成功');&#125;); @koa/cors是怎么实现的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143'use strict';const vary = require('vary');/** * CORS middleware * * @param &#123;Object&#125; [options] * - &#123;String|Function(ctx)&#125; origin `Access-Control-Allow-Origin`, default is request Origin header * - &#123;String|Array&#125; allowMethods `Access-Control-Allow-Methods`, default is 'GET,HEAD,PUT,POST,DELETE,PATCH' * - &#123;String|Array&#125; exposeHeaders `Access-Control-Expose-Headers` * - &#123;String|Array&#125; allowHeaders `Access-Control-Allow-Headers` * - &#123;String|Number&#125; maxAge `Access-Control-Max-Age` in seconds * - &#123;Boolean&#125; credentials `Access-Control-Allow-Credentials` * - &#123;Boolean&#125; keepHeadersOnError Add set headers to `err.header` if an error is thrown * @return &#123;Function&#125; cors middleware * @api public */module.exports = function (options) &#123; const defaults = &#123; allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH', &#125;; // 默认的配置项和使用时设置的options进行一个融合 options = Object.assign(&#123;&#125;, defaults, options); // 因为函数的一些参数，exposeHeaders，allowMethods，allowHeaders的形式既可以是String,也可以是Array类型， // 如果是Array类型,也转换为用逗号分隔的字符串。 if (Array.isArray(options.exposeHeaders)) &#123; options.exposeHeaders = options.exposeHeaders.join(','); &#125; if (Array.isArray(options.allowMethods)) &#123; options.allowMethods = options.allowMethods.join(','); &#125; if (Array.isArray(options.allowHeaders)) &#123; options.allowHeaders = options.allowHeaders.join(','); &#125; if (options.maxAge) &#123; options.maxAge = String(options.maxAge); &#125; options.credentials = !!options.credentials; options.keepHeadersOnError = options.keepHeadersOnError === undefined || !!options.keepHeadersOnError; return async function cors(ctx, next) &#123; // If the Origin header is not present terminate this set of steps. // The request is outside the scope of this specification. const requestOrigin = ctx.get('Origin'); // Always set Vary header // https://github.com/rs/cors/issues/10 ctx.vary('Origin'); // 如果请求头不存在 origin，则直接跳出该中间件，执行下一个中间件 if (!requestOrigin) return await next(); // 对origin参数的不同类型做一个处理 let origin; if (typeof options.origin === 'function') &#123; origin = options.origin(ctx); if (origin instanceof Promise) origin = await origin; if (!origin) return await next(); &#125; else &#123; origin = options.origin || requestOrigin; &#125; const headersSet = &#123;&#125;; function set(key, value) &#123; ctx.set(key, value); headersSet[key] = value; &#125; /** * 非OPTIONS请求的处理 * */ if (ctx.method !== 'OPTIONS') &#123; // Simple Cross-Origin Request, Actual Request, and Redirects set('Access-Control-Allow-Origin', origin); if (options.credentials === true) &#123; set('Access-Control-Allow-Credentials', 'true'); &#125; if (options.exposeHeaders) &#123; set('Access-Control-Expose-Headers', options.exposeHeaders); &#125; if (!options.keepHeadersOnError) &#123; return await next(); &#125; try &#123; return await next(); &#125; catch (err) &#123; const errHeadersSet = err.headers || &#123;&#125;; const varyWithOrigin = vary.append(errHeadersSet.vary || errHeadersSet.Vary || '', 'Origin'); delete errHeadersSet.Vary; err.headers = Object.assign(&#123;&#125;, errHeadersSet, headersSet, &#123; vary: varyWithOrigin &#125;); throw err; &#125; &#125; else &#123; // Preflight Request // If there is no Access-Control-Request-Method header or if parsing failed, // do not set any additional headers and terminate this set of steps. // The request is outside the scope of this specification. if (!ctx.get('Access-Control-Request-Method')) &#123; // this not preflight request, ignore it return await next(); &#125; ctx.set('Access-Control-Allow-Origin', origin); if (options.credentials === true) &#123; ctx.set('Access-Control-Allow-Credentials', 'true'); &#125; if (options.maxAge) &#123; ctx.set('Access-Control-Max-Age', options.maxAge); &#125; if (options.allowMethods) &#123; ctx.set('Access-Control-Allow-Methods', options.allowMethods); &#125; let allowHeaders = options.allowHeaders; if (!allowHeaders) &#123; allowHeaders = ctx.get('Access-Control-Request-Headers'); &#125; if (allowHeaders) &#123; ctx.set('Access-Control-Allow-Headers', allowHeaders); &#125; ctx.status = 204; &#125; &#125;;&#125;; 以上是 @koa/cors V3.0.0的源码实现，如果你真正理解的CORS，看源码的逻辑就会非常轻松。 主要是分两个逻辑来处理，有预检请求的和没有预检请求的。 对于非OPTIONS请求的处理，要根据情况加上 Access-Control-Allow-Origin，Access-Control-Allow-Credentials，Access-Control-Expose-Headers这三个响应头部； 对于OPTIONS请求（预检请求）的处理，要根据情况加上 Access-Control-Allow-Origin，Access-Control-Allow-Credentials，Access-Control-Max-Age，Access-Control-Allow-Methods，Access-Control-Allow-Headers这几个响应头部；]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解 Cookie，Session，Token]]></title>
    <url>%2F2019%2F06%2F15%2F2019-06-15%2F</url>
    <content type="text"><![CDATA[前言无状态的HTTP协议很久很久之前， Web基本都是文档的浏览而已。既然是浏览， 作为服务器， 不需要记录在某一段时间里都浏览了什么文档， 每次请求都是一个新的HTTP协议，就是请求加响应。不用记录谁刚刚发了HTTP请求， 每次请求都是全新的 如何管理会话随着交互式Web应用的兴起， 像在线购物网站，需要登录的网站等，马上面临一个问题，就是要管理回话，记住那些人登录过系统，哪些人往自己的购物车中放商品，也就是说我必须把每个人区分开。 本文主要讲解cookie，session, token 这三种是如何管理会话的； cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据。跟服务器没啥关系，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以KV形式存储到某个目录下的文本文件中，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。所以每个域的cookie数量是有限制的。 如何设置客户端设置1document.cookie = "name=xiaoming; age=12 " 客户端可以设置cookie的一下选项: expires, domain, path, secure(只有在https协议的网页中, 客户端设置secure类型cookie才能生效), 但无法设置httpOnly选项 设置cookie =&gt; cookie被自动添加到request header中 =&gt; 服务端接收到cookie 服务端设置不管你是请求一个资源文件(如html/js/css/图片), 还是发送一个ajax请求, 服务端都会返回response.而response header中有一项叫set-cookie, 是服务端专门用来设置cookie的; 一个set-cookie只能设置一个cookie, 当你想设置多个, 需要添加同样多的set-cookie 服务端可以设置cookie的所有选项: expires, domain, path, secure, HttpOnly Cookie，SessionStorage，LocalStorageHTML5提供了两种本地存储的方式 sessionStorage 和 localStorage； session什么是sessionsession从字面上讲，就是会话。这个就类似你和一个人交谈，你怎么知道当时和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他是张三；session也是类似的道理，服务器要知道当前请求发给自己的是谁。为了做这种区分，服务器就是要给每个客户端分配不同的”身份标识”，然后客户端每次向服务器发请求的时候，都带上这个”身份标识“，服务器就知道这个请求来自与谁了。至于客户端怎么保存这个”身份标识“，可以有很多方式，对于浏览器客户端，大家都采用cookie的方式。 过程(服务端session + 客户端 sessionId) 1.用户向服务器发送用户名和密码 2.服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等; 3.服务器向用户返回一个session_id, 写入用户的cookie 4.用户随后的每一次请求, 都会通过cookie, 将session_id传回服务器 5.服务端收到 session_id, 找到前期保存的数据, 由此得知用户的身份 存在的问题扩展性不好单机当然没问题， 如果是服务器集群， 或者是跨域的服务导向架构， 这就要求session数据共享，每台服务器都能够读取session。 举例来说， A网站和B网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？这个问题就是如何实现单点登录的问题 Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。 Session复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。 共享Session：将Session Id 集中存储到一个地方，所有的机器都来访问这个地方的数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败； 另一种方案是服务器索性不保存session数据了，所有数据就保存在客户端，每次请求都发回服务器。这种方案就是接下来要介绍的基于Token的验证; Token过程 用户通过用户名和密码发送请求 程序验证 程序返回一个签名的token给客户端 客户端储存token, 并且每次用每次发送请求 服务端验证Token并返回数据 这个方式的技术其实很早就已经有很多实现了，而且还有现成的标准可用，这个标准就是JWT; JWT(JSON Web Token)数据结构实际的JWT大概就像下面这样： JSON Web Tokens由dot（.）分隔的三个部分组成，它们是： Header（头部） Payload（负载） Signature（签名） 因此，JWT通常如下展示： xxxxx.yyyyy.zzzz Header（头部）Header 是一个 JSON 对象1234&#123; "alg": "HS256", // 表示签名的算法，默认是 HMAC SHA256（写成 HS256） "typ": "JWT" // 表示Token的类型，JWT 令牌统一写为JWT&#125; Payload（负载）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据12345678910111213&#123; // 7个官方字段 "iss": "a.com", // issuer：签发人 "exp": "1d", // expiration time： 过期时间 "sub": "test", // subject: 主题 "aud": "xxx", // audience： 受众 "nbf": "xxx", // Not Before：生效时间 "iat": "xxx", // Issued At： 签发时间 "jti": "1111", // JWT ID：编号 // 可以定义私有字段 "name": "John Doe", "admin": true&#125; JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 Signature（签名）Signature 是对前两部分的签名，防止数据被篡改。 首先，需要指定一个密钥(secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。1HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 算出签名后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。1JWT = Base64(Header) + "." + Base64(Payload) + "." + $Signature 如何保证安全？ 发送JWT要使用HTTPS；不使用HTTPS发送的时候，JWT里不要写入秘密数据 JWT的payload中要设置expire时间 使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。此后，客户端每次与服务端通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息 Authorization 字段里面。1Authorization: Bearer &lt;token&gt; 另一种做法是， 跨域的时候， JWT就放在POST请求的数据体里。 JWT 的作用JWT最开始的初衷是为了实现授权和身份认证作用的，可以实现无状态，分布式的Web应用授权。大致实现的流程如下 客户端需要携带用户名/密码等可证明身份的的内容去授权服务器获取JWT信息； 每次服务都携带该Token内容与Web服务器进行交互，由业务服务器来验证Token是否是授权发放的有效Token，来验证当前业务是否请求合法。 这里需要注意：不是每次请求都要申请一次Token，这是需要注意，如果不是对于安全性要求的情况，不建议每次都申请，因为会增加业务耗时；比如只在登陆时申请，然后使用JWT的过期时间或其他手段来保证JWT的有效性； Acesss Token，Refresh TokenJWT最大的优势是服务器不再需要存储Session，使得服务器认证鉴权业务可以方便扩展。这也是JWT最大的缺点由于服务器不需要存储Session状态，因此使用过程中无法废弃某个Token，或者更改Token的权限。也就是说一旦JWT签发了，到期之前就会始终有效。我们可以基于上面提到的问题做一些改进。 前面讲的Token，都是Acesss Token，也就是访问资源接口时所需要的Token，还有另外一种Token，Refresh Token。一般情况下，Refresh Token的有效期会比较长。而Access Token的有效期比较短，当Acesss Token由于过期而失效时，使用Refresh Token就可以获取到新的Token，如果Refresh Token也失效了，用户就只能重新登录了。Refresh Token及过期时间是存储在服务器的数据库中，只有在申请新的Acesss Token时才会验证，不会对业务接口响应时间造成影响，也不需要向Session一样一直保持在内存中以应对大量的请求。 一个简单的JWT使用示例准备1npm i --save koa koa-route koa-bodyparser @koa/cors jwt-simple 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243const Koa = require("koa");const app = new Koa();const route = require('koa-route');var bodyParser = require('koa-bodyparser');const jwt = require('jwt-simple');const cors = require('@koa/cors');const secret = 'your_secret_string'; // 加密用的SECRET字符串，可随意更改app.use(bodyParser()); // 处理post请求的参数const login = ctx =&gt; &#123; const req = ctx.request.body; const userName = req.userName; const expires = Date.now() + 3600000; // 设置超时时间为一小时后 var payload = &#123; iss: userName, exp: expires &#125;; const Token = jwt.encode(payload, secret); ctx.response.body = &#123; data: Token, msg: '登陆成功' &#125;;&#125;const getUserName = ctx =&gt; &#123; const reqHeader = ctx.request.headers; const token = reqHeader.authorization.split(" ")[1]; var decoded = jwt.decode(token, secret); ctx.response.body = &#123; data: &#123; username: decoded.iss, &#125;, msg: '获取用户名成功' &#125;;&#125;app.use(cors());app.use(route.post('/login', login));app.use(route.get('/getUsername', getUserName));app.listen(3200, () =&gt; &#123; console.log('启动成功');&#125;); 客户端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;JWT-demo&lt;/title&gt; &lt;style&gt; .login-wrap &#123; height: 100px; width: 200px; border: 1px solid #ccc; padding: 20px; margin-bottom: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="login-wrap"&gt; &lt;input type="text" placeholder="用户名" class="userName"&gt; &lt;br&gt; &lt;input type="password" placeholder="密码" class="password"&gt; &lt;br&gt; &lt;br&gt; &lt;button class="btn"&gt;登陆&lt;/button&gt; &lt;/div&gt; &lt;button class="btn1"&gt;获取用户名&lt;/button&gt; &lt;p class="username"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; var btn = document.querySelector('.btn'); btn.onclick = function () &#123; var userName = document.querySelector('.userName').value; var password = document.querySelector('.password').value; fetch('http://localhost:3200/login', &#123; method: 'POST', body: JSON.stringify(&#123; userName, password &#125;), headers:&#123; 'Content-Type': 'application/json' &#125;, mode: 'cors' // no-cors, cors, *same-origin &#125;) .then(function (response) &#123; return response.json(); &#125;) .then(function (res) &#123; // 获取到Token,将Token放在localStorage document.cookie = `token=$&#123;res.data&#125;`; localStorage.setItem('token', res.data); localStorage.setItem('token_exp', new Date().getTime()); alert(res.msg); console.log('本地测试', res); &#125;) .catch(err =&gt; &#123; console.error('本地测试错误', err); &#125;); &#125; var btn1 = document.querySelector('.btn1'); btn1.onclick = function () &#123; var username = document.querySelector('.username'); const token = localStorage.getItem('token'); fetch('http://localhost:3200/getUsername', &#123; headers:&#123; 'Authorization': 'Bearer ' + token &#125;, mode: 'cors' // no-cors, cors, *same-origin &#125;) .then(function (response) &#123; return response.json(); &#125;) .then(function (res) &#123; console.log('返回用户名结果', res); username.innerHTML = `姓名：$&#123;res.data.username&#125;`; &#125;) .catch(err =&gt; &#123; console.error('本地测试错误', err); &#125;); &#125;&lt;/script&gt;&lt;/html&gt; 运行代码 以上只是一个特别简单的例子， 很多边界条件没有做处理，比如未登陆的校验，异常的处理，Token过期的判断； 区别Cookie和Session的区别 存储位置不同： cookie数据存放在客户的浏览器上，session数据放在服务器上 隐私策略不同：cookie不是很安全， 别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session session会在一定时间内保存在服务器上。当访问增多，就会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie 存储大小不同： 单个cookie保存的数据不能超过4k, 很多浏览器都限制一个站点最多保存20个cookie 一般建议： 将登陆信息等重要信息存放为session, 其他信息如果需要保留，可以放在cookie中 Token和Session的区别Session是一种HTTP储存机制， 为无状态的HTTP提供持久机制;Token就是令牌， 比如你授权(登录)一个程序时，它就是个依据，判断你是否已经授权该软件； Session和Token并不矛盾，作为身份认证Token安全性比Session好，因为每一个请求都有签名还能防止监听以及重放攻击，而Session就必须依赖链路层来保障通讯安全了。如上所说，如果你需要实现有状态的回话，仍然可以增加Session来在服务端保存一些状态。 总结cookie，session，Token没有绝对的好与坏之分，只要还是要结合实际的业务场景和需求来决定采用哪种方式来管理回话，当然也可以三种都用。 参考 jwt 彻底理解cookie，session，token JSON Web Token 入门教程 Cookie、Session、Token那点事儿（原创） 3种web会话管理的方式 你真的了解 Cookie 和 Session 吗 不要用JWT替代session管理（上）：全面了解Token,JWT,OAuth,SAML,SSO access_token、refresh_token的原理与实现]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界上真的没有真正的感同身受]]></title>
    <url>%2F2019%2F04%2F27%2F2019-04-27%2F</url>
    <content type="text"><![CDATA[今天早上一觉醒来，刷微博，看到这样一条热搜。在昨晚的《我是唱作人》节目中，王源在演唱自己的原创作品《世界上没有真正的感同身受》时，因控制不住自己的情绪，在舞台上崩溃大哭。事后王源针对因情绪影响演唱在微博上向所有人道歉， 在听到这首歌的时候，我都忍不住想要落泪。因为光是这首歌的歌名就已经够让人感同身受，只是你的情绪只是你一个人的，没有人可以真正深入地了解到你的内心。世界上真的没有真正的感同身受的。 在演唱这首歌前，王源问了台下观众这么一句话“你们看舞台亮吗？” 台下观众争先恐后地答“亮”。 可是王源说“我看你们是黑的。” 年少成名，他拥有多少光亮，就经历了多少黑暗的时刻。 也许这便是粉丝和偶像之间最大的距离，其实也是我们每个人身处情绪之中时旁人和我们的最大距离。 每个人都有这样的时刻，这个世界只有自己，一个人寂寞，一个人难过，周围的人都说懂，但其实他们从来都没有真正的懂过。 这个时候，不需要加油也不需过多的安慰，自己会好，只是突然会觉得失落，难过，孤独。 难过的时候，你感觉你的周围都是黑的。可以你身边人是没办法感受到这种黑暗的，他们的生活依然是阳关明媚， 光鲜亮丽。获取他们会安慰你，会说“我懂你的感受。”只是口头上懂得只是表面，心底的波澜无人可懂。只有你一个人。 就像是王源一样，外人看到的都是光鲜亮丽。一个小小年纪的孩子就成为偶像，成为光彩的明星，这是多少人的梦寐以求，可是他背后承担了多少压力，放弃了多少快乐，又有谁知道呢？一切只有自己心里清楚，没有人可以真正感同身受。 所以不要妄想别人可以对你感同身受，可以知道你心里的苦，而当别人和你倾诉的时候，不要用自己的角度轻飘飘地对待。如果你不能感同身受，至少不要让对方觉得你漫不经心。而当你崩溃大哭的时候，也不要觉得自责，因为坚强地够久了，我们都有权利大哭一场。哭过之后，我们还都是坚强的孩子。 我们所羡慕的，我们并不知道她们背后有着什么，她们是否得到这个结果前，在路上哭泣过。 所以以后不要再羡慕别人了，你要羡慕的应该是你自己，因为最懂你的那个人就是你自己。你不要去想那些不好的，你不需要等谁在天塌下来陪你，你要让天一直是天，让你是更好的你，另外你还要记得，世上没有人懂你，但永远有人在爱着你。]]></content>
      <categories>
        <category>life</category>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的缓存机制]]></title>
    <url>%2F2018%2F12%2F01%2F2018-12-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器的缓存机制缓存过程浏览器与服务器通信的方式为应答模式, 即是:浏览器发起HTTP请求-服务器响应请求, 那么浏览器怎么确定一个资源该不该请求缓存呢?浏览器第一次向服务器发起该请求后拿到请求结果, 将请求结果和缓存标识存入浏览器缓存, 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的 分为强制缓存和协商缓存强制缓存优先于协商缓存, 强制缓存(expires和Cache-control)生效则直接使用强制缓存, 若不生效则进行协商缓存(Last-Modified/If-Modified-Since和Etag/If-None-Match), 协商缓存由服务器决定是否使用缓存, 如果协商缓存失效, 那么代表该请求的的缓存失效, 返回200,重新返回资源的缓存标识, 再存入浏览器缓存中; 生效则返回304, 继续使用缓存; Cache-control优先级高于expiresEtag/If-None-Match优先级高于Last-Modified/If-Modified-Since 区别 强缓存不发请求, 直接在缓存中获取; 弱缓存需要发送一个请求, 验证是都可以使用缓存, 如果可以则返回304直接使用缓存, 如果不可以使用缓存, 则直接返回该资源的数据 强缓存返回200(from cache), 弱缓存返回304 强制缓存不会向服务器请求资源, 直接从缓存中读取资源, 在chrome控制台的netWork选项中可以看到该请求返回200的状态码, size显示 from disk cache和from memory cache; from disk cache 从硬盘中读取缓存; from memory cache 从内存中读取缓存;浏览器会在js和图片资源等文件解析后直接存入内存缓存中, 那么当刷新页面时只需直接从内存缓存中读取(from memory cache); 协商缓存协商缓存是无法减少请求数的开销的, 但是可以减少返回的正文大小; 用户行为对缓存的影响1.地址栏访问, 链接跳转是正常用户的行为, 将会触发浏览器缓存机制2.F5刷新, 浏览器会设置max-age=0, 跳过强制缓存判断, 会进行协商缓存判断3.ctrl+F5刷新, 会跳过强制缓存和协商缓存, 直接从服务器拉取资源]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router常见用法]]></title>
    <url>%2F2018%2F11%2F24%2F2018-11-24-vue-router%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hash模式和history模式hash模式(vue-router默认hash模式)就是看到路由上面会有一个 #号, 例如http://localhost:8800/#/; javascript通过hashChange事件来监听url的变化history模式,就是直接匹配的/, 这种模式充分利用 history.pushState API来完成URL跳转而无需重新加载页面12345const router = new VueRouter(&#123;// 使用HTML5的History路由模式 mode: 'history', routes: [...]&#125;) history模式, 需要后端配置支持, 因为我们的应用是单页应用, 后端如果没有配置, 访问 http://localhost:8800/home就是404;后端需要配置在接收到所有的请求后, 都会指向同一个index.html 钩子函数的使用常见场景beforeEach和afterEach 修改页面的标题1234router.beforeEach((to, from, next) =&gt; &#123; window.document.title = to.meta.title; next();&#125;) 微信中给vue单页应用设置标题123456789101112131415161718192021222324252627282930function addELementToBody(el) &#123; if (document.body) &#123; document.body.appendChild(el); &#125; else &#123; window.onload = function () &#123; document.body.appendChild(el); &#125;; &#125;&#125;function setTitle(title = '') &#123; if (title) &#123; window.document.title = title; // 兼容IOS下的微信 if (/ip(hone|od|ad)/i.test(navigator.userAgent)) &#123; const i = document.createElement('iframe'); i.src = '/favicon.ico'; i.style.display = 'none'; i.onload = function () &#123; setTimeout(() =&gt; &#123; i.remove(); &#125;, 9); &#125;; addELementToBody(i); &#125; return Promise.resolve(); &#125; return Promise.reject('请传递title参数');&#125;;export default setTitle; 每次页面跳转控制滚动到最顶部 123router.afterEach((to, from, next) =&gt; &#123; window.scrollTo(0, 0);&#125;) 判断是否登录 1234567router.beforeEach((to, from, next) =&gt; &#123; if(window.localStorage.getItem('token')) &#123; next(); &#125; else &#123; next('/login'); &#125;&#125;) next参数为false时, 可以取消导航, 设置为具体的路径可以导航到指定的页面; 正确的使用好导航钩子可以实现一些全局性的功能, 而且便于维护 路由懒加载(按需加载)如果使用babel, 则需要添加 syntax-dynamic-import 该插件 懒加载的写法：1const Foo = () =&gt; import('./Foo.vue') 命名chunk及把组件按组分块命名chunk使用了异步路由之后, 编译出来的每个页面的js都叫做chunk(块),默认的chunk都是以0, 1, 2, 3 … 来命名的, 这样开发的时候不太方便看出具体是哪个模块的chunk, 我们可以给每个chunk都进行命名;在webapck配置的出口output里通过设置chunkFilename字段修改chunk命名: 12345678&#123; output: &#123; publicPath: '/dist/', // [hash:8] 修改为8位数的hash值 filename: '[name].[hash:8].js', chunkFilename: '[name].[hash:8].chunk.js' &#125;,&#125; 有了chunk后, 在每个页面(.vue文件)里写的样式也需要配置后才会打包进main.css, 否则仍然会通过JavaScript动态创建&lt;style&gt;标签的形式写入.配置插件123456plugins: [ new ExtractTextPlugin(&#123; filename: '[name].[hash:8].css', allChunks: true &#125;),] 把组件按组分块使用命名chunk, 一个特殊的注释语法来提供chunk name123const Foo = () =&gt; import(/* webpackChunkName: "group-foo" */ './Foo.vue')const Bar = () =&gt; import(/* webpackChunkName: "group-foo" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: "group-foo" */ './Baz.vue') 命名相同的webapck会打包到同一个chunk下; .babelrc的配置123456789101112&#123; "presets": ["stage-3", "env"], "plugins": ["transform-runtime", "syntax-dynamic-import"], // "comments": false, "env": &#123; "production": &#123; "plugins": [ ["transform-remove-console"] ] &#125;&#125;&#125; “comments”: false, 该项一定不要保留,因为会把注释的部分去掉, 但是命名chunk规则是根据注释来判断的; 匹配404路由在路由列表的最下面加上如下代码1234567891011121314new Router(&#123; routes: [&#123; // 此处省略N个路由 &#123; name: '404', path: '/404', component: () =&gt; import('./notFound.vue') &#125;, &#123; path: '*', // 此处需特别注意至于最底部 redirect: '/404' &#125; &#125;]&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚点的添加]]></title>
    <url>%2F2018%2F11%2F01%2F2018-11-01-%E9%94%9A%E7%82%B9%E7%9A%84%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[1.使用 id 定位 2.使用 name 定位 3.使用js定位 1.使用 id 定位这种定位最大的好处就是可以针对任何标签来定位给一个a标签一个href=“#锚点”，然后要跳的锚点给个id=“锚点”1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;锚点&lt;/title&gt; &lt;style&gt; #div1 &#123; margin-top: 2000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt; &lt;a href="#div1"&gt;to div1&lt;/a&gt; &lt;/h2&gt; &lt;div id="div1"&gt;div1&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.使用 name 定位使用 name 定位只用于 &lt;a&gt;标签,其他的标签就不管用了。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;锚点&lt;/title&gt; &lt;style&gt; a[name="a"]&#123; margin-top: 2000px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt; &lt;a href="#a"&gt;定位到A&lt;/a&gt; &lt;/h2&gt; &lt;a name="a"&gt;A&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 3.使用js定位element.scrollIntoView()方法让当前元素滚动到浏览器窗口的可视区域内(有浏览器的兼容问题)12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;锚点&lt;/title&gt; &lt;style&gt; #a &#123; margin-top: 2000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div onclick="javascript:document.getElementById('a').scrollIntoView()"&gt; 定位到A &lt;/div&gt; &lt;div id="a"&gt; A &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack-dev-server的proxy用法]]></title>
    <url>%2F2018%2F10%2F20%2F2018-10-20-Webpack-dev-server%E7%9A%84proxy%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。 解决开发环境的跨域问题(不用在去配置nginx和host, 爽歪歪~~) 在webpack.config.js中配置 下面简单介绍一下五个经常使用的场景 使用一:12345678mmodule.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': 'http://localhost:3000' &#125; &#125;&#125;; 请求到 /api/xxx 现在会被代理到请求 http://localhost:3000/api/xxx, 例如 /api/user 现在会被代理到请求 http://localhost:3000/api/user 使用二如果你想要代码多个路径代理到同一个target下, 你可以使用由一个或多个「具有 context 属性的对象」构成的数组：123456789module.exports = &#123; //... devServer: &#123; proxy: [&#123; context: ['/auth', '/api'], target: 'http://localhost:3000', &#125;] &#125;&#125;; 使用三:如果你不想始终传递 /api ，则需要重写路径：1234567891011module.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://localhost:3000', pathRewrite: &#123;'^/api' : ''&#125; &#125; &#125; &#125;&#125;; 请求到 /api/xxx 现在会被代理到请求 http://localhost:3000/xxx, 例如 /api/user 现在会被代理到请求 http://localhost:3000/user 使用四:默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，只要设置 secure: false 就行。修改配置如下：1234567891011module.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': &#123; target: 'https://other-server.example.com', secure: false &#125; &#125; &#125;&#125;; 使用五:有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。在函数中你可以访问请求体、响应体和代理选项。必须返回 false 或路径，来跳过代理请求。 例如：对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理。你可以这样做：12345678910111213141516module.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://localhost:3000', bypass: function(req, res, proxyOptions) &#123; if (req.headers.accept.indexOf('html') !== -1) &#123; console.log('Skipping proxy for browser request.'); return '/index.html'; &#125; &#125; &#125; &#125; &#125; &#125;; 解决跨域原理上面的参数列表中有一个changeOrigin参数, 是一个布尔值, 设置为true, 本地就会虚拟一个服务器接收你的请求并代你发送该请求,1234567891011module.exports = &#123; //... devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://localhost:3000', changeOrigin: true, &#125; &#125; &#125;&#125;; vue-cli中proxyTable配置接口地址代理示例修改 config/index.js12345678910111213141516171819202122232425262728module.exports = &#123; dev: &#123; // 静态资源文件夹 assetsSubDirectory: 'static', // 发布路径 assetsPublicPath: '/', // 代理配置表，在这里可以配置特定的请求代理到对应的API接口 // 使用方法：https://vuejs-templates.github.io/webpack/proxy.html proxyTable: &#123; // 例如将'localhost:8080/api/xxx'代理到'https://wangyaxing.cn/api/xxx' '/api': &#123; target: 'https://wangyaxing.cn', // 接口的域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 &#125;, // 例如将'localhost:8080/img/xxx'代理到'https://cdn.wangyaxing.cn/xxx' '/img': &#123; target: 'https://cdn.wangyaxing.cn', // 接口的域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 pathRewrite: &#123;'^/img': ''&#125; // pathRewrite 来重写地址，将前缀 '/api' 转为 '/'。 &#125; &#125;, // Various Dev Server settings host: 'localhost', // can be overwritten by process.env.HOST port: 4200, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined&#125; 更多参数dev-server 使用了非常强大的 http-proxy-middleware , http-proxy-middleware 基于 http-proxy 实现的，可以查看 http-proxy 的源码和文档:https://github.com/nodejitsu/node-http-proxy 。123456789101112target：要使用url模块解析的url字符串forward：要使用url模块解析的url字符串agent：要传递给http（s）.request的对象（请参阅Node的https代理和http代理对象）ssl：要传递给https.createServer（）的对象ws：true / false，是否代理websocketsxfwd：true / false，添加x-forward标头secure：true / false，是否验证SSL CertstoProxy：true / false，传递绝对URL作为路径（对代理代理很有用）prependPath：true / false，默认值：true - 指定是否要将目标的路径添加到代理路径ignorePath：true / false，默认值：false - 指定是否要忽略传入请求的代理路径（注意：如果需要，您必须附加/手动）。localAddress：要为传出连接绑定的本地接口字符串changeOrigin：true / false，默认值：false - 将主机标头的原点更改为目标URL 参考 官方文档 http-proxy-middleware node-http-proxy API Proxying During Development]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css自定义属性实现一键换肤功能]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25-%E4%BD%BF%E7%94%A8css%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[使用css自定义属性实现一键换肤功能 css自定义属性简介css 的自定义属性功能(var), 在css中使用变量,和less及scss不同的是,在js中可以直接修改变量值; 用法: MDN它们使用自定义属性符号（例如--main-color: black;）进行设置，并使用var()函数。例如: color: var(--main-color); 123456789101112:root &#123; --main-color: brown;&#125;.one &#123; color: white; background-color: var(--main-color); margin: 10px; width: 50px; height: 50px; display: inline-block;&#125; 可以在javascript中设置12345678// get variable from inline styleelement.style.getPropertyValue("--my-var");// get variable from wherevergetComputedStyle(element).getPropertyValue("--my-var");// set variable on inline styleelement.style.setProperty("--my-var", 'red'); 浏览器支持css自定义属性目前支持的浏览器有 使用css-vars-polyfill polyfill 补充polyfill 的简单解释polyfill用于表示根据新特性的定义,创建一段与之行为等价但能够在旧的javascript环境中运行的代码 引用 wiki 里的一句话解释 In web development, a polyfill is code that implements a feature on web browsers that do not support the feature. Most often, it refers to a JavaScript library that implements an HTML5web standard, either an established standard (supported by some browsers) on older browsers, or a proposed standard (not supported by any browsers) on existing browsers. Formally, “a polyfill is a shim for a browser API”. 可以这样简单的理解一下:css自定义变量在IE浏览器中无法使用,但是使用了css-vars-polyfill ,就可以让我们在IE9+中也可以使用该属性;还记得 babel-polyfill 么, babel允许我们使用es6的语法,它主要是把es6的语法转成大多数浏览器可是支持的es5语法, 可以使用 工具 来看一下平常所写的es6语法对应到es5是什么样的, 例如但是像 Array.from , Object.assign, Array.prototype.includes, promise, async ,await 这些都是es5语法中没有的,我们还是想使用,但是很多浏览器不支持怎么办, babel-polyfill就是帮我们解决这个问题的]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客简单支持PWA]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05-%E5%8D%9A%E5%AE%A2%E6%94%AF%E6%8C%81PWA%2F</url>
    <content type="text"><![CDATA[文章首次发表在: 博客支持PWA了~ 前言 使用hexo插件使博客支持pwa功能，目前我所知道的有两种插件均可实现该功能 hexo-pwa hexo-offline 前提(HTTPS)全站支持HTTPS.(ps: 目前本人使用的是腾讯云的免费证书) 网站配置HTTPS, 已经有很多文章写了配置过程, 本篇文章不在赘述 使用hexo-pwa1.安装hexo-pwa1npm i --save hexo-pwa 2.修改配置文件 hexo的配置文件采用yml语言, 想要了解该语言的可以去看看 在根目录的_config.yml中添加12345678910111213141516171819202122232425262728293031323334353637pwa: manifest: path: /manifest.json body: "name": "funnycoderstar" "short_name": "star" "theme_color": "rgba(203,7,83,0.86)" "background_color": "#FAFAFA" "display": "standalone" "Scope": "/" "start_url": "/" icons: - src: https://cdn.wangyaxing.cn/icon-144x144.png?v=1 sizes: 144x144 type: image/png - src: https://cdn.wangyaxing.cn/icon-128x128.png sizes: 128x128 type: image/png - src: https://cdn.wangyaxing.cn/icon-96x96.png sizes: 96x96 type: image/png serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\// strategy: networkFirst priority: 5 参数含义可以去hexo-pwa文档中查看 3.添加manifest.json和sw.js这两个文件放的位置要和配置中的路径一致, 我是放在跟目录的sw.js123456789101112131415importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');if (workbox) &#123; workbox.setConfig(&#123; modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' &#125;); workbox.precaching.precache(['/', '/index.html']); workbox.routing.registerRoute(new RegExp('^https?://wangyaxing.cn/?$'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst()); workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate()); workbox.routing.registerRoute(new RegExp('https://cdn.wangyaxing.cn/'), workbox.strategies.cacheFirst());&#125; manifest.json123456789101112131415161718192021222324252627&#123; "name": "funnycoderstar", "short_name": "star", "theme_color": "rgba(203,7,83,0.86)", "background_color": "#FAFAFA", "display": "standalone", "Scope": "/", "start_url": "/", "icons": [ &#123; "src": "/source/images/icons/icon-96x96.png", "sizes": "96x96", "type": "image/png" &#125;, &#123; "src": "/source/images/icons/icon-128x128.png", "sizes": "128x128", "type": "image/png" &#125;, &#123; "src": "/source/images/icons/icon-144x144.png", "sizes": "144x144", "type": "image/png" &#125;, ], "splash_pages": null&#125; manifest生成地址： https://app-manifest.firebaseapp.com/ 4.将funnycoderstar安装到主屏(PWA) 地址栏输入: Chrome://flags 搜索并启用以下项目: Desktop PWAs(桌面PWAs)、App Banners(应用横幅)、Experimental App Banners(实验性应用横幅) 重启浏览器使修改的设置生效 点击地址栏最右边按钮 选择”安装 funnycoderstar” 在桌面上即可看到博客的小图标 感兴趣的小伙伴可以来我的博客体验一下, 哈哈~~ https://.wangyaxing.cn/ 使用hexo-offline使用基本与hexo-pwa相同, 下面简述一下过程 1. 安装1npm i --save hexo-offline 2. 修改配置文件123456789101112131415161718# Offline## Config passed to sw-precache## https://github.com/JLHwung/hexo-offlineoffline: maximumFileSizeToCacheInBytes: 10485760 staticFileGlobs: - public/**/*.&#123;js,html,css,png,jpg,jpeg,gif,svg,json,xml&#125; stripPrefix: public verbose: true runtimeCaching: - urlPattern: /* handler: cacheFirst options: origin: cdn.example.com - urlPattern: /* handler: cacheFirst options: origin: cdn.another-example.org 3. 添加manifest.json manifest.json放到 source目录下 4. 引入manifest.jsonnext主题在 layout/_partials/head.swig添加1&lt;link rel="manifest" href="/manifest.json"&gt; 注意 文件放置位置一定要与配置文件中写的路径一致 图标大小一定按照PWA的严格要求 打开 Chrome Dev Tools的Application一栏中进行调试 还可以通过观察network中的请求是否有小齿轮标志来检测serviceWorker是否已加载 参考 hexo博客支持PWA和压缩博文 让 Hexo 博客支持 PWA 五步让 Hexo 博客支持 PWA]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo加入gitment功能]]></title>
    <url>%2F2018%2F09%2F01%2F2018-09-01-hexo%E5%8A%A0%08%E5%85%A5gitment%E8%AF%84%E8%AE%BA%08%08%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[文章首次发表在:hexo加入gitment功能 前言Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 使用 next(v5.1.4)支持gitment功能 使用步骤1. 注册 OAuth Application点击https://github.com/settings/applications/new注册，注意Authorization callback URL填自己的网站url, 比如我的 https://wangyaxing.cn/ 你会得到一个 client ID 和一个 client secret，这个将用于以下的配置中 2.在主题文件下的_config.yml中配置找到gitment进行配置1234567891011gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: Your Github ID github_repo: 新建一个代码仓库,用于存储评论内容, 这里千万注意添加仓库名称而不是完整地址 client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 遇到的问题1. not fund出现这个问题的原因是因为配置ower, repo的时候错了 repo指的是仓库名称而不是仓库地址 2.点击初始化评论报错 Error：validation failed刚开始看了好多文章, 一直修改next/layout/_partials/comments.swig, 而且还加了如下内容, 但是修改完之后一直没有起作用, 后来又查找源码, 发现V5.1.4版本和之前的不太一样, 并不用自己添加一些内容,这也是提醒大家查找解决方法时一定要注意修改的版本号之前的版本 现在的版本内容如下: 修改next/layout/_third-party/comments/gitment.swig 修改ID由默认的window.location.pathname为 page.date解决ID长度过长报错问题 3.自动初始化评论问题初始化评论框方案讨论自动初始化 Gitalk 和 Gitment 评论]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript编码风格指南]]></title>
    <url>%2F2018%2F06%2F19%2F2018-06-19-JavaScript%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言程序语言的编码风格指南对于一个长期维护的软件而言是非常重要的;好的编程风格有助于写出质量更高、错误更少、更易于 维护的程序。 团队合作需要制定一些代码规范还有利用一些工具来强制要求团队代码的风格统一.毕竟很多情况下以后不一定是由写一手代码的人来维护代码,所以有一个统一的代码风格很重要!!! 最近看了一下编写可维护的JavaScript和编写高质量代码:Web前端开发修炼之道,根据书中提倡的一些写法,同时结合我个人的经验和喜好做了一些改动,大致整理了如下JavaScript编码风格 JavaScript编码风格1.缩进每一行的层级由4个空格组成,避免使用制表符(Tab)进行缩进123if (true) &#123; doSomething();&#125; 2.行的长度每行长度不应该超过80个字符.如果一行多于80个字符,应当在一个运算符(逗号,加好等)后换行.下一级应当增加两级缩进(8个字符).12345678910// 好的写法doSomething(arg1, arg2, arg3, arg4, arg5);// 不好的写法: 第二行只有4个空格的缩进doSomething(arg1, arg2, arg3, arg4, arg5);// 不好的写法: 在运算符之前换行doSomething(arg1, arg2, arg3, arg4 ,arg5); 3.原始值特殊值null除了下述情况应当避免使用 用来初始化一个变量,这个变量可能被赋值为一个对象 用来和一个已经初始化的变量比较,这个变量可以是也可以不是一个对象 当函数的参数期望是对象时,被用作返回值传出12// 好的做法const person = null; 判断一个变量是否定义应当使用 typeof 操作符123456789// 好的写法if (typeof constiable == 'undefined') &#123; // do something&#125;// 不好的写法if (constiable == 'undefined') &#123; // do something&#125; 4.运算符间距二元运算符前后必须使用一个空格来保持表达式的整洁.操作符包括赋值运算符和逻辑运算符12345678910111213141516171819202122// 好的写法const found = (values[i] === item);// 不好的写法: 丢失了空格const found = (values[i]===item);// 好的写法if (found &amp;&amp; (count &gt; 10)) &#123; doSomething();&#125;// 不好的写法: 丢失了空格if (found&amp;&amp;(count&gt;10)) &#123; doSomething();&#125;// 好的写法for(let i = 0; i &lt; count; i++) &#123; process(i);&#125;// 不好的写法: 丢失了空格for(let i=0; i&lt;count; i++) &#123; process(i);&#125; 5.括号间距当使用括号时,紧接左括号之后和紧接右括号之前不应该有空格12345678910111213141516171819202122// 好的写法const found = (values[i] === item);// 不好的写法: 左括号之后有额外的空格const found = ( values[i] === item);// 好的写法if (found &amp;&amp; (count &gt; 10)) &#123; doSomething();&#125;// 不好的写法: 右括号之后有额外的空格if (found &amp;&amp; (count &gt; 10) ) &#123; doSomething();&#125;// 好的写法for(let i = 0; i &lt; count; i++) &#123; process(i);&#125;// 不好的写法: 参数两边有额外的空格for(let i = 0; i&lt; count; i++) &#123; process( i );&#125; 6.对象直接量对象直接量应当使用如下格式 起始左花括号应当同表达式保持同一行 每个属性的名值对应当保持一个缩进,第一个属性应当在左花括号后另起一行. 每个属性的名值对应当使用不含引号的属性名,其后紧跟一个冒号(之前不含空格),而后是值 倘若属性值是函数类型,函数体应当在属性名之下另起一行,而且其前后均应保留一个空行 一组相关的属性前后可以插入空行以提高代码的可读性 结束的右花括号应当独占一行1234567891011121314151617181920212223242526272829// 好的写法const object = &#123; key1: value1, key2: value2, func: function() &#123; &#125;, key3: value3,&#125;;// 不好的写法: 不恰当的缩进const object = &#123; key1: value1, key2: value2, &#125;;// 不好的写法:函数体缺少空行const object = &#123; key1: value1, key2: value2, func: function() &#123; &#125;, key3: value3,&#125;; 当对象字面量作为函数参数时,如果值是变量,起始花括号应当同函数名在同一行.所有其余先前列出的规则同样适用 12345678// 好的写法doSomething(&#123; key1: value1, key2: value2,&#125;);// 不好的写法doSomething(&#123; key1: value1, key2: value2 &#125;); 7.注释频繁地适用注释有助于他人理解你的代码.如下情况应当使用注释 代码晦涩难懂 可能被误认为错误的代码 必要但不明显的针对特定浏览器的代码 对于对象,方法或者属性,生成文档是有必要的(使用恰当的文档注释). 1).单行注释使用单行注释当用来说明一行代码或者一组代码.单行注释可能有三种使用方式 独占一行的注释,用来解释下一行代码 在代码行的尾部的注释,用来解释它之前的代码 多行,用来注释掉一个代码块1234567891011121314151617181920212223242526272829// 好的写法if (condition) &#123; // 如果代码执行到这里,则说明通过了所有的安全性检测 allowed();&#125;// 不好的写法:注释之前没有空行if (condition) &#123; // 如果代码执行到这里,则说明通过了所有的安全性检测 allowed();&#125;// 不好的写法: 错误的缩进if (condition) &#123;// 如果代码执行到这里,则说明通过了所有的安全性检测 allowed();&#125;// 不好的写法: 这里应当用多行注释// 接下来的这段代码非常难, 那么,让我详细的解释一下// 1. xxxx// 2. xxxxif (condition) &#123;// 如果代码执行到这里,则说明通过了所有的安全性检测 allowed();&#125; 对于代码行尾单行注释的情况,应确保代码结尾同注释之间至少一个缩进12345// 好的写法const result = something + somethingElse; // somethingElse will never be null// 不好的写法: 代码和注释间没有足够的空格const result = something + somethingElse;// somethingElse will never be null 注释一个代码块时在连续多行使用单行注释是唯一可以接受的情况.多行注释不应当在这种情况下使用1234// 好的写法// if(condition) &#123;// doSomething();// &#125; 2).多行注释多行注释应当在代码需要更多文字去解释的时候使用.每个多行注释都至少有如下三行.1.首行仅仅包括 / 注释开始.该行不应当有其他文字2.接下来的行以 开头并保持左对齐.这些行可以由文字描述3.最后一行以 */开头并同先前行保持对齐.也不应当有其他文字 多行注释的首行应当保持同它描述代码的相同层次的缩进.后续的每行应当有同样层次的缩进并附加一个空格(为了适当保持 * 字符的对齐).每一个多行代码之前应当预留一个空格123456789101112131415161718192021222324252627282930313233343536373839// 好的写法if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有的安全性检测 */ allowed();&#125;// 不好的写法: 注释之前无空行if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有的安全性检测 */ allowed();&#125;// 不好的写法: 星号后没有空格if (condition) &#123; /* *如果代码执行到这里 *说明通过了所有的安全性检测 */ allowed();&#125;// 不好的写法: 错误的缩进if (condition) &#123;/* * 如果代码执行到这里 * 说明通过了所有的安全性检测*/ allowed();&#125;// 不好的写法: 代码尾部注释不要用多行注释格式const result = something + somethingElse; /* somethingElse 不应当取值为null */ 3)注释声明注释有时候可以用来给一段代码声明额外的信息.这些声明的格式以单个单词打头并紧跟一个双引号.可使用的声明如下 TODO: 说明代码还未完成.应当包含下一步要做的事情 HACK: 表明代码实现走了一个捷径 XXX: 说明代码是有问题的并应当尽快修复 FIXME: 说明代码是有问题的并应当尽快修复.重要性略次于XXX REVIEW: 说明代码任何可能的改动都需要评审这些声明可能在一行或多行注释中使用,并且应当遵循同一般注释类型相同的格式规则12345678910111213// 好的写法// TODO: 我希望找到一种更快的方式doSomething();// 不好的写法: 注释声明空格不正确// TODO : 我希望找到一种更快的方式doSomething();// 好的写法// REVIEW: 有更好的方法吗?doSomething();// 不好的写法: 代码和注释应当保持同样的缩进 // REVIEW: 有更好的方法吗?doSomething(); 8.命名变量命名应当采用驼峰命名格式,首字母小写,每个单词首字母大写.变量名的第一个单词应当是一个名词(而非动词)比避免同函数混淆.不要在变量名中使用下划线1234567891011// 好的写法const myName = 'Jack';// 不好的写法: 大写字母开头const MyName = 'Jack';// 不好的写法: 动词开头const getMyName = 'Jack';// 不好的写法: 使用下划线const my_name = 'Jack'; 函数命名应当采用驼峰命名格式.函数名的第一个单词应当是动词(而非名词)来避免同变量混淆.函数名中最好不要使用下划线.1234567891011121314151617// 好的写法function doSomething() &#123; // 代码&#125;// 不好的写法: 大写字母开头function DoSomething() &#123; // 代码&#125;// 不好的写法: 名词开头function car() &#123; // 代码&#125;// 不好的写法: 使用下划线function do_something() &#123; // 代码&#125; 构造函数–通过new元素安抚创建新对象的函数–也应使用驼峰合适命名,首先首字母大写.构造函数命名应当以非动词开头,因为new代表着创建一个对象实例的操作 12345678910111213141516// 好的写法function MyObject() &#123;&#125;// 不好的写法: 小写字母开头function myObject() &#123; &#125;// 不好的写法: 使用下划线function My_Object() &#123; &#125;// 不好的写法: 动词开头function getMyObject() &#123; &#125; 常量(不会被改变的变量)的命名应当是所有字母大写,不同单词之间用单个下划线隔开.ES6中使用const来声明一个常量123456// 好的写法const TOTAL_COUNT = 10;// 不好的写法const totalCount = 10;// 不好的写法: 混合模式const total_COUNT = 10; 对象的属性同变量的命名规范相同.对象的方法同函数的命名规则相同.如果属性或者方法是私有的,应当在之前加一个下划线12345678// 好的写法const object = &#123; _count: 10, _getCount: function() &#123; return this._count; &#125;&#125; 9.赋值当给变量赋值时,如果右侧是含有比较语句的表达式,需要用圆括号包裹12345// 好的写法const flag = (i &lt; count);// 不好的写法:遗漏圆括号const flag = i &lt; count; 10.等号运算符使用 === (严格相等) 和 !==(严格不相等)代替 ==(相等) 和 !=(不等) 来避免弱类型转换错误12345// 好的写法const same = (a === b);// 不好的写法: 使用 == const same = (a == b); 11.三元操作符三元运算符应当仅仅用在条件赋值语句中,而不要作为if语句的替代品.12345// 好的写法const value = condition ? value1 : value2;// 不好的写法: 没有赋值,应当使用 if 表达式condition ? doSomething() : doSomethingElse(); 12.语句简单语句每一行最多只包含一条语句.所有简单的语句都应该以分号(;)结束.1234567// 好的写法const a = 1;const b = 2;const c = a + b;// 不好的写法: 多个表达式写在一行const a = 1;const b = 2;const c = a + b; 返回语句返回语句当返回一个值的时候不应当使用圆括号包裹,除非在某些情况下这么做可以让返回值更容易理解.例如:123return;return collection.size();return (size &gt; 0 ? size : defaultSize) 复合语句复合语句是大括号括起来的语句列表; 括起来的语句应当较复合语句多缩进一个层级 开始的大括号应当在复合语句所在行的末尾;结束的大括号应当独占一行且同复合语句的开始保持同样的缩进. 当括号时控制结构的一部分时,诸如if或者for语句,所有语句都需要用打括号括起来,也包括单个语句.这个约定使得我们更方便地添加语句而不用担心忘记加括号而引起bug 像if一样的语句开始的关键词,其后应当紧跟一个空格,起始大括号应当在空格之后 if语句1234567if (condition) &#123; statements&#125; else if (condition) &#123; statements&#125; else &#123; statements&#125; 绝不允许在if语句中省略花括号12345678910111213141516// 好的写法if (condition) &#123; doSomething();&#125; // 不好的写法: 不恰当的空格if(condition)&#123; doSomething();&#125; // 不好的写法: 遗漏花括号if (condition) doSomething();// 不好的写法: 所有代码写在一行if (condition) &#123; doSomething(); &#125;// 不好的写法: 所有代码写在一行且没有花括号if (condition) doSomething(); for语句1234567for (initialization; condition; update) &#123; statements&#125;for (constiable in object) &#123; statements&#125; 当使用 for-in 语句时,记得使用 hasOwnProperty() 进行双重检查来过滤出对象的成员 while语句123while (condition) &#123; statements&#125; do语句123do &#123; statements&#125; while (condition) switch语句123456switch (expression) &#123; case expression: statements default: statements&#125; switch下的每一个case都叮当保持一个缩进.除第一个之外包括default在内的每一个case都应当在之前保持一个空行每一组语句(除了default)都应当以break, return, throw结尾,或者用一行注释表示跳过123456789101112// 好的写法switch (value) &#123; case 1: /* falls through */ case 2: doSomething(); break; case 3: return true; default: throw new Error('this should not happen');&#125; try语句1234567try &#123; statements&#125; catch (constiable) &#123; statements&#125; finally &#123; statements&#125; 13.严格模式严格模式应当仅限在函数内部使用,千万不要在全局使用. ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 14.变量声明所有的变量在使用前都应事先定义.变量定义应放在函数开头.变量定义前应当初始化,并且赋值操作符应当保持一致的缩进.初始化的变量应当在未初始化变量之前. 推荐使用ES6的let和 const来声明变量 15.函数声明函数声明应当在使用前提前定义.一个不是作为方法的函数(也就是没有作为一个对象的属性)应当使用函数定义的格式(不是函数表达式和Function构造器格式).函数名和开始圆括号之前不应当有空格.结束的圆括号和右边的花括号之间应该留一个空格.右侧的花括号应当同function关键字保持同一行.开始和结束括号之间不应该有空格.参数名之间应当在逗号之后保留一个空格.函数体应当保持一级缩进12345678910111213141516171819// 好的写法function doSomething(arg1, agr2) &#123; return arg1 + arg2;&#125;// 不好的写法: 第一行不恰当的空格function doSomething (arg1, agr2) &#123; return arg1 + arg2;&#125;// 不好的写法: const doSomething = function doSomething(arg1, agr2) &#123; return arg1 + arg2;&#125;// 不好的写法: 左侧的花括号位置不对function doSomething(arg1, agr2)&#123; return arg1 + arg2;&#125;// 错误的写法: 使用Function构造器const doSomething = new Function('arg1', 'agr2', 'return arg1 + arg2'); 16.留白在逻辑相关的代码块之间添加空行可以提高代码的可读性 两行空行权限在如下情况使用 在不同的源代码文件之间 在类和接口定义之间 单行空行权限在如下情况使用 方法之间 方法中局部变量和第一行语句之间 多行或单行注释之前 方法中逻辑代码块之间以提高代码的可读性 空格应当在如下情况中使用 关键词后跟括号的情况应当用空格隔开 参数列表中逗号之后应当保留一个空格 所有的除了点(.)之外的二元运算符,其操作数都应当用空格隔开.单目运算符的操作数之间不应该用空白隔开,诸如一元减号,递增(++),递减(–) for语句中的表达式之间应当用空格隔开 17. 需要避免的 切勿使用像String一类的原始包装类型创建的新对象 避免使用eval() 避免使用with语句.改语句在严格模式中不复存在,可能在未来也将去除 使用工具(eslint)来强制约束eslint 规则eslint规则在.eslintrc.js中定义,觉得不合理的可以禁掉某条规则,或者有好的建议的也可以添加;主要注意一下几条: 代码缩进用4空格 语句必须默认后加分号 使用单引号 提交代码前将console.log语句删掉或注释掉(不然影响其他开发人员调试) 禁止使用const,使用es6的let,const声明变量 还有一些情况是不需要检测的,例如第3方的库, 框架、组件、ui库等等,可以将这些文件放在.eslintignore文件中,可以忽略eslint的检测 在文件顶部加上下面这行,可以禁掉整个文件的eslint规则1/* eslint-disable */ pre-commit代码提交之前会强制code-review,不符合规范的不允许提交代码使用方法1.在命令行安装1npm i --save-dev pre-commit 2.在package.json中配置12345678910&#123; "scripts": &#123; "eslint": "eslint ./ --ext js,vue --ignore-pattern .eslintignore --cache --fix", "lint-message": "echo '开始 eslint 检查, 存在 error 则会拒绝提交'" &#125;, "pre-commit": [ "lint-message", "eslint" // 进行eslint检查并自动修复一些简单的格式错误 ],&#125; 代码提交之前会强制code-review,不符合规范的不允许提交代码 如果项目实在没时间去改的话，可以 git commit -m &#39;XXX&#39; --no-verify 或 git commit -n &#39;xxx&#39;强制提交 小技巧-vscode可以配置保存自动修复eslint错误vscode安装eslint插件,在配置中配置如下12345678910111213141516171819202122&#123; "eslint.autoFixOnSave": true, "eslint.enable": true, "eslint.options": &#123; "extensions": [".js", ".vue", ".jsx"] &#125;, "eslint.validate": [ &#123; "language": "vue", "autoFix": true &#125;, &#123; "language": "javascript", "autoFix": true &#125;, &#123; "language": "javascriptreact", "autoFix": true &#125; ],&#125; 配置完成之后,每次保存,都会自动根据 .eslintrc.js文件自动修复空格,分号的错误;但是最好还是在平常的编码中养成一个良好的习惯,而不是依赖工具. 下列参考给出的文章及书籍，有时间一定要好好看一下，会帮助大家深刻理解JavaScript编码风格的重要性。永远记住，规范能解决大部分问题。 参考 编写可维护的JavaScript 编写高质量代码:Web前端开发修炼之道 代码整洁之道 ESLint JavaScript编码风格]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客域名更改说明]]></title>
    <url>%2F2018%2F06%2F18%2F2018-06-18-%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%94%B9%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博客域名更改说明wangyaxing.top 改为 wangyaxing.cn; 今天是端午节，首先祝大家端午安康，假期最后一天，好好耍一天，明天开始投入工作； 该博客大概是从2017年8月份开始的，截止到今天，也差不多快一年了。总浏览量为16000左右，访客大概8000左右。没有刻意的宣传，大多数流量来自于搜索引擎。 换了新域名后，浏览量和阅读量这些数据都消失了，因为是绑在之前的域名下的。不过，那就从今天重新开始吧! 通过博客也认识了很多有趣的小伙伴，也学到了很多东西。很感谢。 之后希望可以写出一些有深度的文章，博客更新的频率可以高一些； 希望大家可以持续关注我的博客，有问题随时给我指出，最后希望自己的博客可以给大家带来一点点帮助，共同成长]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex使用]]></title>
    <url>%2F2018%2F04%2F27%2F2018-04-27-vuex%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vuex中几个核心概念: state, getters, mutations, actions, module 简介可以把Vuex看成是一个前端的”数据库”(store), 修改”数据库”中一个值,则所有使用到该值得地方都会得到相应的更新 vuex用法getters可以认为是store的计算属性;与计算属性一样,getter的返回值会根据它的依赖缓存起来,且只有当它的依赖值发生变化才会被重新计算 mapGetters辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; mutations 只能是同步操作更改vuex的store中的状态的唯一方法就是提交 mutations在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？ mutation必须是同步函数1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交mutations你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; actions 可以是异步操作 action提交的是mutation,而不是直接更改状态 action 可以包含任何异步操作 分发 action在组件中分发Action你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： 12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; module由于使用单一状态树,应用的所有状态会集中到一个比较大的对象;当应用变得非常复杂时,store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 需要注意的点默认情况下,模块内的getter, mutation,action是注册在全局空间的,state只注册在局部命名空间的;要想使模块内的getter, mutation,action注册在模块命名空间,必须在模块内加上 namespaced: true 使用命名空间在调用action时必须使用 1234567this.$store.dispatch('hero1/getHeroInfo');computed: &#123; doneTodosCount () &#123; return this.$store.getters['hero1/doneTodos'][0].item; &#125; &#125;, 参考链接 页面刷新时,store中的数据会清空解决方案https://stackoverflow.com/questions/43027499/vuex-state-on-page-refresh]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单实现一个Virtual DOM]]></title>
    <url>%2F2018%2F04%2F23%2F2018-04-20-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAVirtual-DOM%2F</url>
    <content type="text"><![CDATA[前言之前写过一篇文章为什么使用v-for时必须添加唯一的key?,但是解释的不是很深刻，其实真正的原因还需要从Virtual DOM的实现上解释；本篇文章从简单实现一个Virtual DOM入手，去解释一下Virtual DOM的实现思想; 源码地址：github 思路1.定义一个类,用来创建 DOM 元素(element.js); 2.比较新旧 DOM 树的差异(diff.js); 3.将差异的部分渲染到DOM树即只渲染变化了的部分(patch.js) virtural-dom的模型一个DOM标签所需的基本元素 标签名 节点属性,包含样式,属性,事件 子节点 标识id12345678910111213&#123; // 标签名 tagName: 'div', // 属性 properties: &#123; // 样式 style: &#123;&#125;, &#125;, // 子节点 children: [], // 唯一标识 key: 1,&#125; 过程一: 用javascript对象表示DOM结构为了实现这个需求，下面使用element.js。 原理: 1.根据 tagName 使用 document.createElement创建元素 2.根据 props 使用 setAttribute给元素设置属性 3.根据 innerHtml 使用 document.createTextNode 渲染文本节点 4.根据是否有 children (子元素) 去递归渲染 5.最后使用appendChild将创建的元素插入到页面中 然后代码和使用方式如下 element.js 1234567891011121314151617181920212223242526272829303132333435class Element &#123; constructor(tagName, ...args) &#123; this.tagName = tagName; // 判断下面还有没有子元素 if(Array.isArray(args[0])) &#123; this.props = &#123;&#125;; this.children = args[0]; &#125; else &#123; this.props = args[0]; this.children = args[1]; &#125; this.key = this.props.key || void 0; &#125; render() &#123; // 创建一个元素 const $dom = document.createElement(this.tagName); // 给元素加上所有的属性 for(const proKey in this.props) &#123; $dom.setAttribute(proKey, this.props[proKey]); &#125; // 如果存在子节点 if(this.children) &#123; this.children.forEach(child =&gt; &#123; // 如果子元素还包含子元素,则递归 if(child instanceof Element) &#123; $dom.appendChild(child.render()); &#125; else &#123; $dom.appendChild(document.createTextNode(child)) &#125; &#125;); &#125; return $dom; &#125;&#125;;export default Element; 123456789 const tree = new Element('div', &#123;classname: 'div'&#125;, [ new Element('h1', &#123;style: 'color: red;'&#125;,['Hello, This is my Vdom library']), new Element('ul', [ new Element('li', ['1111']), new Element('li', ['2222']), ])]);const $dom = tree.render();console.log(111, $dom); 这跟vue的render方法很相似123456789101112131415161718192021return h('div', &#123; style: &#123; background: '#fff', &#125;, class: &#123; 'content': true, &#125;, on: &#123; click: () =&gt; &#123; &#125;, mouseenter: () =&gt; &#123; &#125;, mouseleave: () =&gt; &#123; &#125;, &#125;, &#125;, [ h('p', &#123;&#125;, '文本') ]) vue中也是把template解析成render模板进行渲染的; 二: 比较新旧 DOM树的差异差异类型对DOM的操作也就是对节点的增删改查操作,当前定义了如下几种类型 1234567patch.NODE_DELETE = 'NODE_DELETE'; // 节点被删除patch.NODE_TEXT_MODIFY = 'NODE_TEXT_MODIFY'; // 文本节点被更改patch.NODE_REPLACE = 'NODE_REPLACE'; // 节点被替代patch.NODE_ADD = 'NODE_ADD'; // 添加节点patch.NODE_ATTRIBUTE_MODIFY = 'NODE_ATTRIBUTE_MODIFY'; // 更新属性patch.NODE_ATTRIBUTE_ADD = 'NODE_ATTRIBUTE_ADD'; // 添加属性patch.NODE_ATTRIBUTE_DELETE = 'NODE_ATTRIBUTE_DELETE'; // 删除属性 深度优先遍历,记录差异 首先简单解释一下什么是深度优先遍历和广度优先遍历: 对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。以上面二叉树为例，深度优先搜索的顺序为：ABDECFG。怎么实现这个顺序呢 ？深度优先搜索二叉树是先访问根结点，然后遍历左子树接着是遍历右子树，因此我们可以利用堆栈的先进后出的特点，现将右子树压栈，再将左子树压栈，这样左子树就位于栈顶，可以保证结点的左子树先与右子树被遍历。 广度优先搜索(Breadth First Search),又叫宽度优先搜索或横向优先搜索，是从根结点开始沿着树的宽度搜索遍历，上面二叉树的遍历顺序为：ABCDEFG. 接下来简单说一下比较的过程 1.比较属性的变化 遍历旧的属性,找到被删除和修改的情况 新属性中不存在,旧属性存在,属性被删除 新旧属性中都存在,但是值不同: 属性值被修改遍历新元素的属性,找到添加的属性 2.比较子元素的变化 3.比较innerHTML的变化 使用pathes 来存储差异 完整代码如下diff.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import patch from './patch';function diff(oldTree, newTree) &#123; const patches = &#123;&#125;; const index = &#123; value: 0, &#125; dfsWalk(oldTree, newTree, index, patches); return patches;&#125;// 比较属性的变化function diffProps(oldProps, newProps, index, currentIndexPatches) &#123; // 遍历旧的属性,找到被删除和修改的情况 for (const propKey in oldProps) &#123; // 新属性中不存在,旧属性存在,属性被删除 if (!newProps.hasOwnProperty(propKey)) &#123; currentIndexPatches.push(&#123; type: patch.NODE_ATTRIBUTE_DELETE, key: propKey, &#125;) &#125; else if (newProps[propKey] !== oldProps[propKey]) &#123; // 新旧属性中都存在,但是值不同: 属性被修改 currentIndexPatches.push(&#123; type: patch.NODE_ATTRIBUTE_MODIFY, key: propKey, alue: newProps[propKey], &#125;) &#125; &#125; // 遍历新元素,找到添加的部分 for (const propKey in newProps) &#123; // 旧属性中不存在,新属性中存在: 添加属性 if (!oldProps.hasOwnProperty(propKey)) &#123; currentIndexPatches.push(&#123; type: patch.NODE_ATTRIBUTE_ADD, key: propKey, value: newProps[propKey] &#125;) &#125; &#125;&#125;// 顺序比较子元素的变化function diffChildren(oldChildren, newChildren, index, currentIndexPatches, patches) &#123; const currentIndex = index.value; if (oldChildren.length &lt; newChildren.length) &#123; // 有元素被添加 let i = 0; for (; i &lt; oldChildren.length; i++) &#123; index.value++; dfsWalk(oldChildren[i], newChildren[i], index, patches) &#125; for (; i &lt; newChildren.length; i++) &#123; currentIndexPatches.push(&#123; type: patch.NODE_ADD, value: newChildren[i] &#125;) &#125; &#125; else &#123; // 对比新旧子元素的变化 for(let i = 0; i&lt; oldChildren.length; i++) &#123; index.value++; dfsWalk(oldChildren[i], newChildren[i], index, patches) &#125; &#125;&#125;// 比较innerHTML的变化function dfsWalk(oldNode, newNode, index, patches) &#123; const currentIndex = index.value; const currentIndexPatches = []; if(newNode === undefined) &#123; // 节点被移除 currentIndexPatches.push(&#123; type: patch.NODE_DELETE, &#125;) &#125; else if(typeof oldNode === 'string' &amp;&amp; typeof newNode === 'string') &#123; // 文本节点被修改 if(oldNode !== newNode) &#123; currentIndexPatches.push(&#123; type: patch.NODE_TEXT_MODIFY, value: newNode, &#125;) &#125; &#125; else if(oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123; // 同时根据tagName和key来进行对比 diffProps(oldNode.props, newNode.props, index, currentIndexPatches); diffChildren(oldNode.children, newNode.children, index, currentIndexPatches, patches); &#125; else &#123; currentIndexPatches.push(&#123; type: patch.NODE_REPLACE, value: newNode, &#125;) &#125; if(currentIndexPatches.length &gt; 0) &#123; patches[currentIndex] = currentIndexPatches; &#125;&#125;export default diff; 需要注意的是，因为tagName是重复的，不能用这个进行对比，所以需要给子节点加上唯一的标识key,列表对比的时候，使用key进行对比，这样才能复用老的DOM树上的节点; 为了实现深度优先遍历,记录差异，这里使用列表计算法 求最小的插入,删除操作的组合；这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解。我们需要优化一下最常见的操作；具体的实现算法也很多； 当前实现的简单 Virtual DOM, 并没有实现如果是数组,会优先使用key去做对比; 下面大致从Vue虚拟DOM的Diff算法实现的角度去解释一下之前的一篇文章为什么使用v-for时必须添加唯一的key? vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设： 两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。 同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。 引用React’s diff algorithm中的例子: 当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。比如一下这个情况：我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？ 所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。 所以一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 三：将差异的部分渲染到DOM树即只渲染变化了的部分通过深度优先遍历，记录差异 patches,最后需要根据patches进行DOM操作;paches记录了差异的类型;大致数据结构如下: 实现该过程的完整代码如下: patch.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function patch($dom, patches) &#123; const index = &#123; value: 0, &#125; dfsWalk($dom, index, patches);&#125;patch.NODE_DELETE = 'NODE_DELETE'; // 节点被删除patch.NODE_TEXT_MODIFY = 'NODE_TEXT_MODIFY'; // 文本节点被更改patch.NODE_REPLACE = 'NODE_REPLACE'; // 节点被替代patch.NODE_ADD = 'NODE_ADD'; // 添加节点patch.NODE_ATTRIBUTE_MODIFY = 'NODE_ATTRIBUTE_MODIFY'; // 更新属性patch.NODE_ATTRIBUTE_ADD = 'NODE_ATTRIBUTE_ADD'; // 添加属性patch.NODE_ATTRIBUTE_DELETE = 'NODE_ATTRIBUTE_DELETE'; // 删除属性// 根据不同类型的差异对当前节点进行 DOM 操作：function dfsWalk($node, index, patches, isEnd = false) &#123; if (patches[index.value]) &#123; patches[index.value].forEach(p =&gt; &#123; switch (p.type) &#123; case patch.NODE_ATTRIBUTE_MODIFY: &#123; $node.setAttribute(p.key, p.value); break; &#125; case patch.NODE_ATTRIBUTE_DELETE: &#123; $node.removeAttribute(p.key, p.value); break; &#125; case patch.NODE_ATTRIBUTE_ADD: &#123; $node.setAttribute(p.key, p.value); break; &#125; case patch.NODE_ADD: &#123; $node.appendChild(p.value.render()); break; &#125; case patch.NODE_TEXT_MODIFY: &#123; $node.textContent = p.value; break; &#125; case patch.NODE_REPLACE: &#123; $node.replaceWith(p.value.render()); break; &#125; case patch.NODE_DELETE: &#123; $node.remove(); break; &#125; default: &#123; console.log(p); &#125; &#125; &#125;); &#125; if (isEnd) &#123; return; &#125; if ($node.children.length &gt; 0) &#123; for (let i = 0; i &lt; $node.children.length; i++) &#123; index.value++; dfsWalk($node.children[i], index, patches); &#125; &#125; else &#123; index.value++; dfsWalk($node, index, patches, true); &#125;&#125;;export default patch; 最后测试一下123456789101112131415161718192021222324252627// 1.构建虚拟DOMconst tree = new Element('div', &#123;classname: 'div'&#125;, [ new Element('h1', &#123;style: 'color: red;'&#125;,['Hello, This is my Vdom library']), new Element('ul', [ new Element('li', ['1111']), new Element('li', ['2222']), ])]);// 2.通过虚拟DOM构建真正的DOMconst $dom = tree.render();const $app = document.querySelector('#app');$app.replaceWith($dom);// 3.生成新的虚拟DOMconst newTree = new Element('div', &#123;id: 'div1'&#125;, [ new Element('h1', &#123;style: 'color: red;'&#125;, ['Hello, This is my vdom library111']), new Element('p', &#123;style: 'color: blue;'&#125;, ['extra text']), new Element('ul', [ new Element('li', ['1111']), new Element('li', ['5555']), new Element('li', ['333']), ])]);// 4.比较新旧虚拟DOM树的差异const patches = diff(tree, newTree);// 5.根据变化了的部分去更新DOMpatch($dom, patches); 总结1.关键的几个文件就是： element.js, diff.js, patch.js; 2.github上有很多Virtual DOM实现的例子，博主也是参考了一下其他人的实现，感兴趣的可以去搜索看一下，或者自己实现一个 参考 深度剖析：如何实现一个 Virtual DOM 算法 Vue2.0 v-for 中 :key 到底有什么用？ React’s diff algorithm react源码解析]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中需要注意的问题总结(上)]]></title>
    <url>%2F2018%2F04%2F15%2F2018-04-15-vue%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言使用vue的时候经常会遇到一些问题,其实仔细阅读查阅官方文档,就会发现文档中已提到一些格外需要注意的点; 为了深入的理解官方文档中对这些问题的解释,查阅了一些资料,再加上自己的理解,整理了一些常见的问题;如果哪方面解释的不太合理希望各路大神指出; 文章篇幅较长,但是很实用; 目录 组件里面, data必须是一个函数 vue中$set的使用场景 vue生命周期详解 vue组件通信 vue组件之keep-alive 生命周期函数/methods/watch里面不应该使用箭头函数 methods/computed/watch 1.组件里面, data必须是一个函数类比引用数据类型Object是引用数据类型, 每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了; 那么用什么方法可以使每个组件的data相互独立,不受影响呢? 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 2.vue中$set的使用场景场景1:通过数组的下标去修改数组的值,数据已经被修改了,但是不触发updated函数,视图不更新,1234567891011121314151617181920export default &#123; data () &#123; return &#123; items: ['a', 'b', 'c'] &#125;; &#125;, updated () &#123; console.log('数据更新', this.items[0]); &#125;, methods: &#123; changeItem1 () &#123; this.items[0] = 'x'; console.log(111, this.items[0]); &#125;, changeItem2 () &#123; this.$set(this.items, 0, 'x'); console.log(222, this.items[0]); &#125;, &#125;&#125;; 执行changeItem1, 控制台打印 111 ‘x’, 没有触发updated,视图不更新执行changeItem1, 控制台打印 222 ‘x’, 数据更新 ‘x’; 触发updated,视图更新 场景2: vue中检测不到对象属性的添加和删除12345data() &#123; userProfile: &#123; name: '小明', &#125;&#125; 想要给userProfile加一个age属性1234addProperty () &#123; this.userProfile.age = '12'; console.log(555, this.userProfile);&#125; 执行addProperty函数时,打印如下 1555 &#123; name: '小明', age: '12'&#125; 但是没有触发updated, 视图未更新改成下面这种1234addProperty () &#123; this.$set(this.userProfile, 'age', '12'); console.log(666, this.userProfile); &#125; 再次执行, 数据发生变化, 触发updated, 视图更新; 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 这是vue中很典型的一个问题,使用的时候一定要注意! 简单的解释一下原理:vue在创建实例的时候把data深度遍历所有属性,并使用 Object.defineProperty 把这些属性全部转为 getter/setter。让 Vue 追踪依赖，在属性被访问和修改时通知变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。当你在对象上新加了一个属性 newProperty,当前新加的这个属性并没有加入vue检测数据更新的机制(因为是在初始化之后添加的),vue.$set是能让vue知道你添加了属性, 它会给你做处理 3.vue生命周期详解1. vue的生命周期 beforeCreate: 组件实例刚刚被创建,组件属性计算之前,如data属性 created: 组件实例创建完成,属性已绑定,但是DOM还未完成,$el属性还不存在 beforeMount:模板编译/挂载之前 mounted: 模板编译/挂载之后 beforeUpdate: 组件更新之前 updated: 组件更新之后 activated: for keep-alive,组件被激活时调用 deactivated: for keep-alive,组件被移除时调用 beforeDestroy: 组件销毁前被调用 destoryed: 组件销毁后调用 ps:下面代码可以直接复制出去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; a: 'vuejs', &#125;, beforeCreate: function() &#123; console.log('创建前'); console.log(this.a); console.log(this.$el); &#125;, created: function() &#123; console.log('创建之后'); console.log(this.a); console.log(this.$el); &#125;, beforeMount: function() &#123; console.log('mount之前'); console.log(this.a); console.log(this.$el); &#125;, mounted: function() &#123; console.log('mount之后'); console.log(this.a); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log('更新之前'); console.log(this.a); console.log(this.$el); &#125;, updated: function() &#123; console.log('更新完成'); console.log(this.a); console.log(this.$el); &#125;, beforeDestroy: function() &#123; console.log('组件销毁之前'); console.log(this.a); console.log(this.$el); &#125;, destroyed: function() &#123; console.log('组件销毁之后'); console.log(this.a); console.log(this.$el); &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreated: el和data并未初始化created: 完成data数据的初始化,el没有beforeMount: 完成了el和data初始化mounted: 完成挂载 1打开命令行在命令行中输入vm.a = &apos;change&apos;;查看效果 4.vue组件通信1.父组件给子组件传递数据vue中使用props向子组件传递数据1): 子组件在props中创建一个属性,用于接收父组件传过来的值2): 父组件中注册子组件3): 在子组件标签中添加子组件props中创建的属性4): 把需要传给子组件的值赋给该属性 2.子组件向父组件传递数据子组件主要通过事件传递数据给父组件1), 子组件中需要以某种方式,例如点击事件的方法来触发一个自定义事件2),将需要传的值作为$emit的第二个参数,该值将作为实参数传给相应自定义事件的方法3),在父组件中注册子组件并在子组件标签上绑定自定义事件的监听 3.子组件向子组件传递数据vue找那个没有直接子组件对子组件传参的方法,建议将需要传递数据的在组件,都合并为一个组件,如果一定需要子组件对子组件传参,可以先传到父组件,再传到子组件,为了方便开发,vue推出了一个状态管理工具vuex,可以啃方便的实现组件之间的参数传递 具体的实例代码如下:可以自行参考相关代码在编辑器中尝试父组件向子组件传递数据123456789101112131415161718192021222324252627282930313233// 父组件向子组件传递数据&lt;!--msg 是在data中(父组件)定义的变量如果需要从父组件中获取logo的值,就需要使用props['msg'], 如30行在props中添加了元素以后,就不需要在data中(子组件)中再添加变量了--&gt;&lt;template&gt; &lt;div&gt; &lt;child @transferuser="getUser" :msg="msg"&gt;&lt;/child&gt; &lt;p&gt;用户名为:&#123;&#123;user&#125;&#125;(我是子组件传递给父组件的数据)&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child, &#125;, data() &#123; return &#123; user: '', msg: '我是父组件传给子组件的信息', &#125;; &#125;, methods: &#123; getUser(msg) &#123; this.user = msg; console.log(msg); &#125;, &#125;, &#125;;&lt;/script&gt; 子组件向父组件传递数据12345678910111213141516171819202122232425262728293031323334// 子组件向父组件传递数据&lt;!--1.@ : 是 v-on的简写2.子组件主要通过事件传递数据给父组件3.当input的值发生变化时,将username传递给parent.vue,首先声明了一个setUser,用change事件来调用setUser4.在setUser中,使用了$emit来遍历transferUser事件,并返回this.username,其中transferuser是一个自定义事件,功能类似一个中转,this.username通过这个事件传递给父组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input v-model="username" @change='setUser'&gt;向父组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; username: '测试', &#125;; &#125;, props: &#123; msg: &#123; type: String, &#125;, &#125;, methods: &#123; setUser() &#123; this.$emit('transferuser', this.username); &#125;, &#125;, &#125;;&lt;/script&gt; 5.vue组件之keep-alive项目中写vue也没注意到&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件,最近在深入的研究vue组件的生命周期函数,每一个函数都是干嘛的,然后其中有activated和deactivated这两个函数与&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件有关 activated: keep-alive组件激活时调用 deactivated: keep-alive组件停用时调用keep-alive用法 &lt;keep-alive&gt;包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 &lt;keep-alive&gt;是一个抽象组件:它自身不会渲染一个DOM元素,也不会出现在父组件链中 当组件在&lt;keep-alive&gt;内被切换,它的activated和deactivated这两个生命周期钩子函数将会被对应执行具体的实例如下 是一个简单的tab切换,可以尝试把&lt;keep-alive&gt;去掉之后,对比一下,然后就会发现它的好处 test.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class="test"&gt; &lt;div class="testNav"&gt; &lt;div :class="&#123;'selected':tab === 1,'testTitle':true&#125;" @click="toTab(1)"&gt;标题一&lt;/div&gt; &lt;div :class="&#123;'selected':tab === 2,'testTitle':true&#125;" @click="toTab(2)"&gt;标题二&lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;keep-alive&gt; &lt;Test1 v-if="tab === 1"&gt; &lt;/Test1&gt; &lt;Test2 v-else&gt; &lt;/Test2&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test1 from './test1.vue'; import Test2 from './test2.vue'; export default &#123; data() &#123; return &#123; tab: 1, &#125;; &#125;, components: &#123; Test1, Test2, &#125;, methods: &#123; toTab(index) &#123; this.tab = index; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123; width: 100%; .testNav &#123; height: 60px; line-height: 60px; display: flex; border-bottom: 1px solid #e5e5e5; .testTitle &#123; flex: 1; text-align: center; &#125; .selected &#123; color: red; &#125; &#125;&#125;&lt;/style&gt; 测试结果如下:注意看一下页面和控制台输出的信息,可以更加直观的注意到&lt;keep-alive&gt;的作用及activated和deactivated这两个函数什么时候会被触发 打开页面,会出现下面这样 用setTimeout模拟请求后端接口的场景 点击title2,出现下面的情况 再次点击title1,出现下面的情况,你会发现从后端请求的数据会快速显示出来,但是如果你此时不用 test1.vue和test2.vue的相关代码如下: test1.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class="test1"&gt; test1 &#123;&#123;testInfo1&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo1: '', &#125;; &#125;, activated() &#123; console.log('测试1被激活'); &#125;, deactivated() &#123; console.log('测试1被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo1 = '这是测试一的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; test2.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; test2 &#123;&#123;testInfo2&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo2: '', &#125; &#125;, activated() &#123; console.log('测试2被激活'); &#125;, deactivated() &#123; console.log('测试2被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo2 = '这是测试二的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; 6. 生命周期函数/methods/watch里面不应该使用箭头函数es6的箭头函数的出现,是我们可以用更少的代码实现功能,但是应该注意箭头函数和普通函数的最大区别是this的指向问题: 箭头函数的this指向函数所在的所用域,普通函数的this指向函数的调用者; 官方文档中特别提醒中已经指出这一点: vue中生命周期函数, methods, watch 自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法, 这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同 7.methods/computed/watchmethods VS computed我们可以将同一个函数定义为methods或者computed,用这两种方式,得到的结果是相同的,不同的是computed是基于它们的依赖进行缓存的,计算属性只有在它相关的依赖发生改变时才重新求值; 适用场景:重新计算开销很大的话,选computed; 不希望有缓存的选methods computed vs watchwatch 有新旧值两个参数, 计算属性没有,但是计算属性可以从setter获得新值 关于computed对于计算属性要特别说明一点: vue的计算属性computed默认只有getter,需要使用getter的时候需要自己加一个setter 1234567891011121314151617181920212223242526272829export default &#123; data () &#123; return &#123; firstName: '张', lastName: '三', &#125;; &#125;, computed: &#123; fullName() &#123; return this.firstName + ' ' + this.lastName &#125;, &#125;, methods: &#123; changeFullName () &#123; this.fullName = '李 四'; &#125; &#125;,&#125;;其中computed里的代码完整写法是 computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, &#125; &#125;, 执行 changeFullName 发现报错[Vue warn]: Computed property &quot;fullame&quot; was assigned to but it has no setter. 我们需要给计算属性fullName添加一个setter 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125; &#125;, 总结上述这些问题从vue官方文档中均能找到答案,当然想要更深入的理解为什么,还需要从vue源码分析入手; 下一篇文章打算从源码入手去解释这些问题,理解vue整体的程序设计;]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么使用v-for时必须添加唯一的key?]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8v-for%E6%97%B6%E5%BF%85%E9%A1%BB%E6%B7%BB%E5%8A%A0%E5%94%AF%E4%B8%80%E7%9A%84key%2F</url>
    <content type="text"><![CDATA[v-for中的key使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但其实这是不推荐的一种使用方法; 举个🌰 1234567891011121314const list = [ &#123; id: 1, name: 'test1', &#125;, &#123; id: 2, name: 'test2', &#125;, &#123; id: 3, name: 'test3', &#125;,] 1&lt;div v-for="(item, index) in list" :key="index" &gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; 上面这种是我们做项目中常用到的一种场景,因为不加key,vue现在直接报错,所以我使用index作为key;下面列举两种种常见的数据更新情况 1.在最后一条数据后再加一条数据123456789101112131415161718const list = [ &#123; id: 1, name: 'test1', &#125;, &#123; id: 2, name: 'test2', &#125;, &#123; id: 3, name: 'test3', &#125;, &#123; id: 4, name: '我是在最后添加的一条数据', &#125;,] 此时前三条数据直接复用之前的,新渲染最后一条数据,此时用index作为key,没有任何问题; 2.在中间插入一条数据123456789101112131415161718const list = [ &#123; id: 1, name: 'test1', &#125;, &#123; id: 4, name: '我是插队的那条数据', &#125; &#123; id: 2, name: 'test2', &#125;, &#123; id: 3, name: 'test3', &#125;,] 此时更新渲染数据,通过index定义的key去进行前后数据的对比,发现 123456之前的数据 之后的数据key: 0 index: 0 name: test1 key: 0 index: 0 name: test1key: 1 index: 1 name: test2 key: 1 index: 1 name: 我是插队的那条数据key: 2 index: 2 name: test3 key: 2 index: 2 name: test2 key: 3 index: 3 name: test3 通过上面清晰的对比,发现除了第一个数据可以复用之前的之外,另外三条数据都需要重新渲染; 是不是很惊奇,我明明只是插入了一条数据,怎么三条数据都要重新渲染?而我想要的只是新增的那一条数据新渲染出来就行了 最好的办法是使用数组中不会变化的那一项作为key值,对应到项目中,即每条数据都有一个唯一的id,来标识这条数据的唯一性;使用id作为key值,我们再来对比一下向中间插入一条数据,此时会怎么去渲染 123456之前的数据 之后的数据key: 1 id: 1 index: 0 name: test1 key: 1 id: 1 index: 0 name: test1key: 2 id: 2 index: 1 name: test2 key: 4 id: 4 index: 1 name: 我是插队的那条数据key: 3 id: 3 index: 2 name: test3 key: 2 id: 2 index: 2 name: test2 key: 3 id: 3 index: 3 name: test3 现在对比发现只有一条数据变化了,就是id为4的那条数据,因此只要新渲染这一条数据就可以了,其他都是就复用之前的; 同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用id,也是这个原因; 其实,真正的原因并不是vue和react怎么怎么,而是因为Virtual DOM 使用Diff算法实现的原因: 原理简析 vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设： 两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。 同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。 引用React’s diff algorithm中的例子: 当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。比如一下这个情况：我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？ 所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。 所以一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 参考 vue官方文档 react官方文档 深度剖析：如何实现一个 Virtual DOM 算法]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么vue中data必须是一个函数]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13-%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本篇文章从javascript原型链来解释为什么vue中data必须是一个函数 vue组件中的data必须是函数类比引用数据类型Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了; javascipt只有函数构成作用域(注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响 举个🌰 1234567891011const MyComponent = function() &#123;&#125;;MyComponent.prototype.data = &#123; a: 1, b: 2,&#125;const component1 = new MyComponent();const component2 = new MyComponent();component1.data.a === component2.data.a; // true;component1.data.b = 5;component2.data.b // 5 如果两个实例同时引用一个对象,那么当你修改其中一个属性的时候,另外一个实例也会跟着改; 两个实例应该有自己各自的域才对,需要通过下面的方法来进行处理 123456789const MyComponent = function() &#123; this.data = this.data();&#125;;MyComponent.prototype.data = function() &#123; return &#123; a: 1, b: 2, &#125;&#125;; 这样么一个实例的data属性都是独立的,不会相互影响了.所以，你现在知道为什么vue组件的data必须是函数了吧。这都是因为js本身的特性带来的，跟vue本身设计无关。其实vue不应该把这个方法名取为data()，应该叫setData或其他更容易理解的方法名。 参考 为什么在vue的组件中，data要用function返回对象呢？ vue官网-data必须是函数]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Rollup打包JavaScript]]></title>
    <url>%2F2018%2F03%2F07%2F2018-03-07-%E4%BD%BF%E7%94%A8Rollup%E6%89%93%E5%8C%85JavaScript%2F</url>
    <content type="text"><![CDATA[rollup是一款小巧的javascript模块打包工具，更适合于库应用的构建工具;可以将小块代码编译成大块复杂的代码，基于ES6 modules,它可以让你的 bundle 最小化，有效减少文件请求大小,vue在开发的时候用的是webpack,但是最后将文件打包在一起的时候用的是 rollup.js rollup官方文档rollupgithub 全局安装12345678npm install --global rollup``` ## 开始使用rollup### 创建第一个bundle创建`main.js` console.log(111);12345执行 `rollup --input main.js --output bundle.js --format cjs`, 该命令编译 `main.js` 生成 `bundle.js`, `--format cjs` 意味着打包为 node.js 环境代码, 请观察 bundle.js 文件内容```js&apos;use strict&apos;console.log(111); 命令行参数简介: 输入(input -i/–input) String 这个包的入口点 (例如：你的 main.js 或者 app.js 或者 index.js) 文件(file -o/–output.file)String 要写入的文件。也可用于生成 sourcemaps，如果适用 格式(format -f/–output.format)关于format选项rollup提供了五种选项: amd – 异步模块定义，用于像RequireJS这样的模块加载器 cjs – CommonJS，适用于 Node 和 Browserify/Webpack es – 将软件包保存为ES模块文件 iife – 一个自动执行的功能，适合作为&lt;script&gt;标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。） umd – 通用模块定义，以amd，cjs 和 iife 为一体 使用配置文件rollup.config.js 1234567export default &#123; input: 'src/main.js', output: &#123; file: 'bundle.js', format: 'cjs' &#125;&#125;; 执行 rollup -c rollup.config.js启动配置项; rollup 提供了 –watch / -w 参数来监听文件改动并自动重新打包 使用rollup插件1npm install --save-dev rollup-plugin-json 我们用的是 –save-dev 而不是 –save，因为代码实际执行时不依赖这个插件——只是在打包时使用。 在配置文件中启用插件1234567891011import json from 'rollup-plugin-json';export default &#123; input: './main.js', output: &#123; file: 'bundle.js', format: 'umd' &#125;, plugins: [ json(), ],&#125; 新建文件 data.json1234&#123; "name": "xiaoming", "age": 12&#125; 在main.js 引入 data.json 12import &#123; name &#125; from './data.json';console.log(name); 执行 rollup -c rollup.config.js,并查看 bundle.js 1234567891011(function (global, factory) &#123; typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory() : typeof define === 'function' &amp;&amp; define.amd ? define(factory) : (factory());&#125;(this, (function () &#123; 'use strict';var name = "xiaoming";console.log(name);&#125;))); 看到bundle中仅引用了data.json中的name字段,这是因为rollup会自动进行 Tree-shaking,main.js中仅引入了name,age并没有没引用,所以age并不会被打包 rollup基础插件 rollup-plugin-alias: 提供modules名称的 alias 和reslove 功能 rollup-plugin-babel: 提供babel能力 rollup-plugin-eslint: 提供eslint能力 rollup-plugin-node-resolve: 解析 node_modules 中的模块 rollup-plugin-commonjs: 转换 CJS -&gt; ESM, 通常配合上面一个插件使用 rollup-plugin-serve: 类比 webpack-dev-server, 提供静态服务器能力 rollup-plugin-filesize: 显示 bundle 文件大小 rollup-plugin-uglify: 压缩 bundle 文件 rollup-plugin-replace: 类比 Webpack 的 DefinePlugin , 可在源码中通过 process.env.NODE_ENV 用于构建区分 Development 与 Production 环境. rollup于其他工具集成打包npm 模块于webpack和Browserify不同, rollup 不会去寻找从npm安装到你的node_modules文件夹中的软件包;rollup-plugin-node-resolve 插件可以告诉 Rollup 如何查找外部模块1npm install --save-dev rollup-plugin-node-resolve 打包 commonjs模块npm中的大多数包都是以CommonJS模块的形式出现的。 在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 处理。rollup-plugin-commonjs 插件就是用来将 CommonJS 转换成 ES2015 模块的。请注意，rollup-plugin-commonjs应该用在其他插件转换你的模块之前 - 这是为了防止其他插件的改变破坏CommonJS的检测1npm install --save-dev rollup-plugin-commonjs 使用babel使用 Babel 和 Rollup 的最简单方法是使用 rollup-plugin-babel 1npm install --save-dev rollup-plugin-babel 新建.babelrc12345678910&#123; "presets": [ ["latest", &#123; "es2015": &#123; "modules": false &#125; &#125;] ], "plugins": ["external-helpers"]&#125; 首先，我们设置&quot;modules&quot;: false，否则 Babel 会在 Rollup 有机会做处理之前，将我们的模块转成 CommonJS，导致 Rollup 的一些处理失败 我们使用external-helpers插件，它允许 Rollup 在包的顶部只引用一次 “helpers”，而不是每个使用它们的模块中都引用一遍（这是默认行为）运行 rollup之前, 需要安装latest preset 和external-helpers插件 1npm i -D babel-preset-latest babel-plugin-external-helpers 一个简单的配置项1234567891011121314151617181920212223import resolve from 'rollup-plugin-node-resolve';import commonjs from 'rollup-plugin-commonjs';import babel from 'rollup-plugin-babel';import json from 'rollup-plugin-json';export default &#123; input: './main.js', output: &#123; file: 'bundle.js', format: 'umd' &#125;, watch: &#123; exclude: 'node_modules/**' &#125;, plugins: [ resolve(), commonjs(), json(), babel(&#123; exclude: 'node_modules/**', plugins: ['external-helpers'], &#125;), ],&#125; rollup优势 自动 Tree-shaking(Tree-shaking, 也被称为 “live code inclusion,” 它是清除实际上并没有在给定项目中使用的代码的过程，但是它可以更加高效。) 打包速度快 配置简单 rollup VS webpackrollup更适合构建javascript库,也可用于构建绝大多数应用程序;但是rollup 还不支持一些特定的高级功能，尤其是用在构建一些应用程序的时候，特别是代码拆分和运行时态的动态导入 dynamic imports at runtime.如果你的项目中需要这些功能,则使用webpack更为适合;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meteor 填坑之旅]]></title>
    <url>%2F2018%2F02%2F11%2F2018-02-11-Meteor%E5%A1%AB%E5%9D%91%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[1. 是否有一个事件可以出发,放插入一条新的消息,我可以订阅?做一个聊天的功能,当有新消息插入到数据库时,我需要判断当前聊天是否存在于用户的聊天列表中(如果不存在也需要创建有新消息的聊天)以及在这个页面做声音,但是Meteor的前后端数据都是响应的,后端数据增加,前端数据自动更新显示.是否有一个事件可以出发,放插入一条新的消息,我可以订阅?meteor insert document eventMETEOR COLLECTIONFS – GET NOTIFIED WHEN A FILE STORAGE COMPLETESMeteor-CollectionFS 我的实现方法: 每条消息加一个ReadedMembers字段,记录消息是谁已经读过了,如果 ReadedMembers.includes(selfId)的值为false,就表明当前消息你还未读,依次来表示未读消息 2. 取出populate关联表数据Message 表的 from 字段关联到了 User 表, 默认情况下查询结果的 from 字段是 user id, 而我们需要的是该 user 的数据. 我们使用 reywood:publish-composite 获取关联表数据, 例如取出 message 的 from 字段的数据: 123456789101112131415161718publishComposite('message', &#123; find() &#123; return Message.find(&#123;&#125;); &#125;, children: [&#123; find(message) &#123; message.from = Meteor.users.findOne( &#123; _id: message.from &#125;, &#123; fields: &#123; username: 1, profile: 1, &#125;, &#125;, ); &#125;, &#125;],&#125;); 自己定义populate方法在做邀请新的好友入群的时候,添加新的好友,利用reywood:publish-composite并不会自动更新数据,所以以后直接自己在客户端定义方法这样做的好处是解决了取关联数据不会自动更新的bug,但是有点麻烦的是每次需要关联数据的时候必须在客户端调用一次方法,正在考虑有没有更好的解决方法123456789101112131415import &#123; Meteor &#125; from 'meteor/meteor';const PopulateUtil = &#123; group(group) &#123; if (group) &#123; group.members = Meteor.users.find(&#123; _id: &#123; $in: group.members &#125; &#125;).fetch(); group.admin = Meteor.users.findOne(&#123; _id: group.admin &#125;); &#125; &#125;, groups(groups) &#123; groups.forEach(group =&gt; PopulateUtil.group(group)); &#125;,&#125;;export default PopulateUtil; 3.代码高亮123456789getHighlightedText = (text, higlight) =&gt; &#123; // Split on higlight term and include term into parts, ignore case const parts = text.split(new RegExp(`($&#123;higlight&#125;)`, 'gi')); return (&lt;span&gt; &#123;parts.map((part, i) =&gt; (&lt;span key=&#123;i&#125; style=&#123;part.toLowerCase() === higlight.toLowerCase() ? &#123; color: '#29b6f6' &#125; : &#123;&#125;&#125;&gt; &#123;part&#125; &lt;/span&gt;)) &#125; &lt;/span&gt;); &#125; 4. 如何在Meteor.call()改为promise,async/await形式方法一:12345678910111213141516function callMeteorMethod(methodName, ...args) &#123; return new Promise((resolve, reject) =&gt; &#123; Meteor.call(methodName, ...args, (error, result) =&gt; &#123; if (error) reject(error) else resolve(result) &#125;) &#125;)&#125;async function main() &#123; let result = await callMeteorMethod('foo', 1, 2, 3) console.log(result)&#125;main() 方法二: 1meteor add deanius:promise deanius/meteor-promise 更多坑待填… 5.Meteor实现数据实时响应的原理6.Meteor和socket.io结合使用,总是重复的自己断开,自己连接7.写文件名的时候层级过长,有没有一种方法可以想vue,那套可以配置,用@代替的]]></content>
      <categories>
        <category>Meteor</category>
      </categories>
      <tags>
        <tag>Meteor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中检测不到数组变化的解决方案]]></title>
    <url>%2F2018%2F01%2F17%2F2018-01-17-vue%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[数组中当你利用索引设置一个项时,发现视图不发生变化 场景:最近做一个功能,要根据数组的index去修改对应项的isSave字段; 12345678910111213141516data() &#123; return &#123; arr: [ &#123; name: '测试1', id: 1, isSave: false, &#125;, &#123; name: '测试2', id: 2, isSave: false, &#125;, ], &#125;;&#125; 通过123changeStatus(index) &#123; this.arr[index].isSave = !this.arr[index].isSave;&#125; 最后视图并没有更新; 详解查了一下官方文档关于列表渲染的注意事项讲解; 由于javascript的限制,Vue不能检测一下变动的数组 1.当你利用索引设置一个项时, 例如: vm.items[indexOfItem] = newValue;2.当你修改数组的长度时,例如: vm.items.length = newLength; 为了解决第一类问题,一下方式都可以实现和 vm.items[indexOfItem] = newValue相同的效果,同时也将触发状态更新;1Vue.set(example1.item, indexOfItem, newValue); 1example1.items.splice(indexOfItem, 1, newValue); 为解决第二类问题,你可以使用splice: 1example1.items.splice(newLength) 解决方法12345changeStatus(index) &#123; const obj = this.ticketWatcher.goodVos[index]; obj.isSave = !obj.isSave; this.$set(this.ticketWatcher, index, obj);&#125; 参考文档 vue官网 vue数组中数据变化但是视图没有更新解决方案]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git仓库迁移]]></title>
    <url>%2F2018%2F01%2F06%2F2018-01-06-git%E4%BB%93%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[需求背景:需要将原来放置gitlab的仓库迁移到集团gitlab,需要将所有分支和tag都迁移过去 实现方式1.将代码从原有仓库中拉下来1git clone remote_git_address(remote_git_address为新服务器gitLab上新建的同名项目地址) 2.设置把本地gitlab地址替换成为集团gitlab地址1git remote set-url origin remote_git_address（remote_git_address为新服务器gitLab上新建的同名项目地址） 3.本地仓库推送到远程123git push origin --all 推送主干和分支git push --tags 推送标签 相关知识git checkout 用法1git checkout --orphan latest_branch 假如你的某个分支上，积累了无数次的提交，你也懒得去打理，打印出的log也让你无力吐槽，那么这个命令将是你的神器，它会基于当前所在分支新建一个赤裸裸的分支，没有任何的提交历史，但是当前分支的内容一一俱全新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支。 git remote用法git remote -v 查看现有远程仓库的地址url 修改及添加远程地址1.修改命令1git remote set-url origin &lt;URL&gt; 更换远程仓库地址,把&lt;URL&gt;更换为新的url地址 2.先删后加12git remote rm origingit remote add origin remote_git_address（remote_git_address为新服务器gitLab上新建的同名项目地址） 3.直接修改配置文件 你可能想让你的代码拥有两个甚至更多远程仓库,你可以再添加一个远程库: git remote add origin2; 这个方法很低效,因为你要git push 两次才能完成push到两个库 其实还有一个方法,git的一个远程库可以对应多个地址,即我能让远程库origin拥有多个url地址,方法如下:首先，我们从零开始，假设你现在想要增加3个远程库地址，分别为: 首先，先增加第一个地址 git remote add origin 然后增加第二个地址 git remote set-url –add origin 增加第三个地址 git remote set-url –add origin ….依次类推 这样就完成了添加多个地址到origin库中了，以后只要使用git push origin master 就可以一次性push到3各库里面了(使用git push也可) 原理解析git remote set-url –add origin 就是往当前git项目的congig文件里增加一行记录config文件打开方式有两种: 使用命令 git config -e 在当前git项目的根目录下，文件位于 .git/config (.git目录为隐藏文件)你每执行一次git remote set-url –add origin 就会增加一行，如下图： git remote -v:显示当前所有远程库的详细信息，显示格式为 远程库名字 url连接(类型)你直接在config里面直接添加url来修改也是可以的,不必去执行git命令 注意: 使用 git push origin master时,你可以push到origin的的多个url地址,但是使用git pull 时,只能拉去origin里的一个url地址(即fetch-url,如上图),这个fetch-url默认为添加的到origin的第一个地址;如果你想更改，只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。 参考 gitlab project项目迁移 Git远程仓库 git remote]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用脚本提升发布效率]]></title>
    <url>%2F2018%2F01%2F05%2F2018-01-05-shell%2F</url>
    <content type="text"><![CDATA[Node.js 命令行程序开发问题: 1.一些重复性的工作能否用脚本来实现? 2.实现自动化发布流程 一些重复性的工作可以考虑写一些脚本,写一个脚本有两个方案,一个是直接在npm scripts直接写命令(固定命令,不需要参数)二是用shelljs写一个脚本 场景: 当前博客是用hexo来搭建的,public目录下的文件是真正需要放在服务器上的代码,我现在的博客仓库管理方式,有两个仓库,一个funnycoderstar和一个deploy(注:针对该仓库写了一个定时任务,服务器定时拉取该仓库下的代码,即知道推送到该仓库下就以为了上线了),funnycoderstar是用来放置项目源码的仓库,deploy是用来发布到线上的代码,(即用来存储public目录下的文件),执行 hexo clean &amp;&amp; hexo g之后都需要将public目录下的文件移到deploy仓库下,每次都可以觉得太麻烦了,于是就考虑用shelljs写了一个脚本git.js12345678910111213const shell = require('shelljs');const yargs = require('yargs');require('shelljs/global');if(!shell.which('git')) &#123; shell.echo('Sorry, this script requires git'); shell.exit(1);&#125;const argv = yargs.argv._;cd('../deploy');exec('git add .');exec('git commit -m' +`feat:`+ `$&#123;argv[0]&#125;`);exec('git push'); 在npm scripts中写了如下脚本1"publish": "hexo clean &amp;&amp; hexo g &amp;&amp; cp -r public/* ../deploy &amp;&amp; node ./git.js", 嘿嘿,这样我每次发布一篇博客的时候直接在命令行执行如下命令就可以了;1npm run publish 新增博客 参考npm scripts 使用指南Node.js 命令行程序开发教程]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glob简介]]></title>
    <url>%2F2018%2F01%2F05%2F2018-01-05-glob%2F</url>
    <content type="text"><![CDATA[前言glob是shell使用的路径通配符,类似于正则表达式,但是与正则表达式不完全相同,在linux操作中如文件匹配等等已经使用了glob通配符; 语法和使用 *:匹配一个路径部分中0或多个字符, 注意不匹配以.开始的路径,比如.a **: 匹配0个或多个子文件夹 ?:匹配一个字符 […]: 匹配以系列字符,如[abc]匹配字符a,b,c,在[^…]和[!…]表示匹配不在列表中的字符,如[^abc]匹配出了a,b,c以外的字符. {a,b}: 匹配a或者b, a和b也是通配符,可以由其他通配符组成 !: 排除文件,如!a.js表示排除文件a.js glob非常强大的用途在于路径匹配，大部分的平台和开发语言都会在配置中使用glob路径匹配，其普遍性几乎使其成为一种标准。 实例1.基于node的gulp时遇到glob匹配文件路径获取js目录下的所有js文件.(不包括以’.’开头的文件)1234//*:匹配路径中某部分:0个或多个字符glob("js/*.js",function (er, files) &#123; console.log(files)&#125;) 2..gitignore中遇到glob匹配文件路径1234567891011# 此为注释 – 将被 Git 忽略 # 忽略所有 .a 结尾的文件 *.a # 但 lib.a 除外 !lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO /TODO # 忽略 build/ 目录下的所有文件 build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt doc/*.txt .gitigore的格式规范 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 参考node-globnode-glob使用记]]></content>
      <categories>
        <category>glob</category>
      </categories>
      <tags>
        <tag>glob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年末面试总结]]></title>
    <url>%2F2018%2F01%2F01%2F2018-01-01-2017%E5%B9%B4%E6%9C%AB%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[此次总结涉及58到家,阿里,支付宝面试; 面试的问题大多都是针对简历上问题来问,花环相扣,一层有一层深入,知道问到你说不上来位置,所以以下面试题只针对我的个人项目经历提问的,只能大致参考一下😁 58到家58到家一面 1.DOM0级事件和DOM2级事件的区别 2.移动端和pc端的区别 3.判断变量类型 4.事件委托及使用场景 5.作用域 6.原型链 58到家二面全程都在手写代码 1.斐波那契数列的实现函数 2.事件委托(e.currentTarget和e.target的区别) 3.求数组的交集 4.this 5.原型链 58三面 1.求数组的交集: 除了用循环的方法 2.存在两个数组,arr1和arr2,他们中的每一项满足 a1 &lt;=a2,求这两个数组的并集(按照从大到小排列,并且已去重) 3.写一个登录需求,需要知道什么: 跨域,是需要直接跳转页面还是弹出弹框,(ajax和form表单的区别), 4.已经实现该功能,但是线上代码出现一个问题,有人点击登录后无反应,怎么找问题,打断点之后发现(1),请求已发送,返回的信息都正常,就是没有弹窗;(2),请求没有发送,怎么找原因,(3),代码执行时才发现错误,(4)线上代码怎么部署 5.实现一个需求两个接口返回a和b,那个先返回回来就返回哪个 6.http协议 58四面 1.实现一个简单的聊天,一点进来页面就进入到这个聊天室(重点是没有登录注册,怎么区分每个人,我答的是可以通过ip,还有别的方法么) 面试完，感觉自己都要被掏空了，感觉把自己会的和不会的都交代出来了。 过了一个月星期告诉我面试通过了，本来以为已经挂了，因为一直没有回信 阿里文娱阿里一面 1.跨域是什么?什么时候会遇到跨域问题,怎么解决 2.原型链 3.有没有从零搭建过webpack/babel 4.babel怎么配置的,他会转换类似String.prototype，给上面增加includes方法么 5.使用vue/react做单页应用遇到什么问题么,或者说一下单页应用的优缺点(首屏渲染太慢),有没有好的解决方法 阿里二面 1.node有什么优点和缺点 2.说出几个数组的方法 3.react和vue的区别 4.Meteor内部实现 5.在app内嵌套h5页面实现原理 阿里三面 1.rem原理 2.javascript垃圾回收机制 3.内存原理 4.你觉得你这一年最大的进步是在什么时候 5.你除了做前端开发,还考虑做产品和测试么(不考虑) 阿里四面 1.你为什么不考研 2.河北的为什么不考虑去雄安 3.你说之前待的公司给不了你想要的,那你去公司面试的时候为什么不提前调查清楚呢,你知道各公司的竞争力和优势么,你为什么想来我们这儿 面完最后一面，感觉自己的价值观都不对了，最后一面问到的问题都不知道该怎么答（哎，看来不应该只想着提高技术，还应该提高自己的情商）；不过开心的是当天晚上被通知说面试通过了让去体检； 支付宝支付宝一面 1.你怎么转专业学的前端 2.react和vue组件通信 3.你做过最骄傲的项目是什么 4.对于node你了解过多少 5.自己配置过服务器么 6.有没有用node做过类似监听服务器动态的东西 7.项目中的消息模块你们用了几个服务器(就一个)肯定经常崩吧(刚刚崩了),有什么解决方法 支付宝二面 1.react和vue组件通信 2.egg解决了什么问题 3.你觉github上比较好的开源项目 4.你最崇拜的前端开发工作者 5.egg+react和Meteor开发有什么区别 6.Meteor开发的内部实现机制是什么 7.说一下你用Meteor实现聊天的逻辑 8.说一下你最近写的一些项目,用的什么技术栈,遇到什么问题,怎么解决的 后来知道支付宝这个部门就是写antd和egg等开源库的部门，当时二面过了，三面也就是终面是视频面试来着，但是当时已经收到大文娱的offer,而且也有点不自信自己可以通过终面，所以就拒绝了。后来面试我的那个小哥哥还给我做过思想工作，说他们面试那么多人，有的都工作好几年了，都没通过面试，只有我一个通过的，而且终面都不问技术，主要是问一些价值观的问题，所以希望我好好考虑一下。真的很感谢小哥哥那么相信我。 哎，我真的是一个非常纠结的人，没收到大文娱offer之前，一直特开心，能去58到家也特别开心，后来收到阿里大文娱的offer，支付宝二面通过的好消息（阿里规定同一个人不能同时面试多个部门，所以当时支付宝面试没走系统的面试），一下子选择太多真的不知道怎么选，虽然真的是很想去支付宝，但是因为大文娱的offer有有限期，而且自己有有点不太自信能通过终面，哎，忍痛拒绝，希望自己以后技术强大可以转岗去支付宝！ 希望以后遇到选择不要这么优柔寡断！ 心得 1.基础真的很重要； 2.还有对于简历上写的一些东西一定是自己最熟悉的，不然一定要慎重往简历上写； 3.平常遇到什么问题一定要多想想为什么，有没有更好的方法 4.要懂一些原理]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年小结]]></title>
    <url>%2F2017%2F12%2F29%2F2017-12-29-2017%E5%B9%B4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[马上就2018年了,真的很快,在2017年底收到了阿里的offer,进入了自己一直都想去的公司,给2018年开了一个好头. 大概做一个2017年的简单总结,主要用于反思这一年及对2018年的展望. 很多人问我,你,一个普通学校的二本, 刚毕业半年,而且还不是计算机专业的,居然能收到阿里的offer,阿里社招不都是三年工作经验么,不都是只招211和985学校的么.先简单的给大家解答一下疑惑. 首先阿里社招并没有必须是三年工作经验,学历强制要求211和985,只要你有能力,这里就欢迎你.阿里是一个只要你有能力,这里是可以让你能力得到发挥的舞台. 对于面试其实从面试问的问题基本就能了解到公司在技术上面主要的侧重点,之前面试都是如果有机会就会去,然后碰到很多面试不到五分钟,十分钟的就出来了,去了大多问你会切图么,会ui么,考虑转后端么,所以有面试机会的时候一定要查一下这个公司,是不是互联网公司,因为本人想去一个互联网公司(比较注重技术,有技术追求的),加入公司主要业务不是靠技术支撑,这种我就不会想去浪费时间了. 关于我的经历2016年11月份刚来北京的时候,也就是第一份工作,一个前端(我),一个后端,不择手段的完成需求,不考虑性能,优化等等.也不能说公司怎么怎么样,主要是侧重点不一样吧. 后来又去了一家创业公司,从0开始重构项目,不得不说,我还是比较幸运的,因为没有接手别人写的代码,完全就是自己从0开始选择技术栈,搭建项目架构,向身边的技术大佬们请教(没事的时候就会去参加一些线下的技术分享活动,当时他们讲的我还是听不太懂,总是就是去膜拜一下各位大佬们,看看大家目前都关注哪些点),加入了eslint,用上了webpack,用vue,react进行组件式的开发,从以前用jq操作DOM,到现在用virtural dom. 经验太少,遇到问题只能自己摸索.所在公司基本都是我主要负责前端,慢慢的,差不多产品给的需求,都能实现,但是可能性能和优化上做的不够好,主要是没有那个意识,产品用户量没有那么大,所以只有极少用户会反映一些奇怪的bug,然后公司没有能复现问题的手机,哎,这个就有点难了,随之问题就被搁置了,不然就是改需求.然后有一些二三线大厂的面试机会,面试的问题很多都是我没有考虑到的,比如性能优化,最佳实践,问的问题很简单,但是面试官想知道最佳实践,我是一脸懵逼,意识到这些问题之后,就知道以后写代码的时候不能只考虑实现需求,还应该怎么去实现好需求. 7月份开始有意识的搞一个自己的博客,把自己遇到的问题总结一下,常反思,大家看到之后也会给我指出一些问题;遇到新的技术出现,就会去看一下这个技术解决了什么问题,这个技术又会有什么问题; 18年展望能进入阿里,并不是因为我现在技术多好,面试官偷偷告诉我说,我刚毕业半年,对于其他大多数毕业半年来说是不错的,但是需要不断的学习;尤其在这个身边人都比自己优秀的环境,不努力怎么行; 技术方面 1.深入的学习一下js,重新好好看一下 你不知道的javascript javascript高级程序设计(第三版) 2.了解一下设计模式 大话设计模式 javascript设计模式 3.性能,http方面 图解HTTP Web性能权威指南 4.nodejs Nodejs实战 5.代码质量方面的 编写可维护的javascript 编写高质量代码 代码大全(第二版) 6.能看懂一些库的源码 … 生活 1.可以多去几个地方旅游 2.抽出时间锻炼身体 3.好好吃饭😆,好好睡觉,开开心心的写代码 最想说的,希望和大家共勉 1.一定要夯实基础,不要盲目的去追求框架 2.学会用谷歌搜索,尽量用英文搜索,还有学习一个新技术主要是从官方文档入手,尽量看英文的 3.搜文档上MDN 来一个招聘广告,欢迎有能力的人将简历发到 `yaxing.wyx@alibaba-inc.com`]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint配置]]></title>
    <url>%2F2017%2F12%2F28%2F2017-12-28-eslint%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[eslint配置全局安装1npm install -g eslint 局部安装1npm i -D eslint 接下来新建一个配置文件.eslintrc.js,或执行以下命令自动生成1eslint --init 制定环境要指定配置文件中的环境，请使用env键并指定要启用的环境true。例如，以下启用浏览器和Node.js环境：123456&#123; "env": &#123; "browser": true, "node": true &#125;&#125; 或者在一个package.json文件中12345678910&#123; "name": "mypackage", "version": "0.0.1", "eslintConfig": &#123; "env": &#123; "browser": true, "node": true &#125; &#125;&#125; 配置规则ESLint带有大量的规则。您可以使用配置注释或配置文件修改您的项目使用的规则。要更改规则设置，您必须将规则ID设置为以下值之一： “off”或者0- 关闭该规则 “warn”或者1- 将规则打开为警告（不影响退出代码） “error”或者2- 将规则打开为错误（触发时退出代码为1） 通过内联注释禁用规则 要在整个文件中禁用规则警告，请在文件/ eslint-disable /顶部添加块注释： 123/* eslint-disable */alert('foo'); 要禁用特定行上的所有规则，请使用以下格式之一的行注释： 1234alert('foo'); // eslint-disable-line// eslint-disable-next-linealert('foo'); 制定全局 可以使用文件内部的注释或配置文件来定义全局变量。 1.使用文件内部注释(1).要在JavaScript文件中使用注释来指定全局变量，请使用以下格式1/* global var1, var2 */ (2).如果你想要指定这些全局变量不应该被写入（只读），那么你可以设置每个false标志：1/* global var1:false, var2:false */ 2.要在配置文件中配置全局变量，请使用globals键并指示要使用的全局变量。将每个全局变量名称设置为等于true允许覆盖变量或false禁止覆盖。例如：123456&#123; "globals": &#123; "var1": true, "var2": false &#125;&#125; 使用心得目前使用vscode,安装eslint插件,然后在配置中加入关于eslint的配置123456789101112131415161718192021&#123; "eslint.autoFixOnSave": true, "eslint.enable": true, "eslint.options": &#123; "extensions": [".js", ".vue", ".jsx"] &#125;, "eslint.validate": [ &#123; "language": "vue", "autoFix": true &#125;, &#123; "language": "javascript", "autoFix": true &#125;, &#123; "language": "javascriptreact", "autoFix": true &#125; ],&#125; &quot;eslint.autoFixOnSave&quot;: true,配置完这个之后,当你在保存的时候可以自动按照你在.eslintrc.js目录中设置的规则自动修复一些空格缩进,单双引号及语句末尾是否需要加;或,的一些错误,但是有一些错误,比如变量声明未定义等得需要你手动去修改. 刚开始用到eslint的时候也是相当痛苦,毕竟在代码中看到一大堆红线(注: 红线为eslint的错误,鼠标划上去就会看到对应的违反了哪个规则,可以去eslint的官网查看),但是当你养成良好的习惯之后,这些习惯包括变量命名,函数命名等,其实会大大的提高工作效率,规范起来之后尤其会提高团队之前的工作效率. 我现在就有严重的代码洁癖,看到整洁的代码,心情就会十分愉悦.当然在看到团队有小伙伴一点都不注意这些,尤其需要忙他debug的时候,真的很难受,变量命名a,b, a1等.所以哪怕为了不坑团队成员的,也要养成良好的习惯. 参考 eslint.org/docs/]]></content>
      <categories>
        <category>eslint</category>
      </categories>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在npm上发布包]]></title>
    <url>%2F2017%2F12%2F27%2F2017-12-27-%E5%9C%A8npm%E4%B8%8A%E5%8F%91%E5%B8%83%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在npm上发布自己的包发布包1.创建你要发布的包12345678mkdir test-wyxcd test-wyxnpm inittouch readme.mdtouch index.jsmkdir libcd libtouch test.js /lib/test.js123456const a = &#123; fun : function() &#123; console.log( '这是我的第一个npm包' ); &#125;;&#125;module.exports = a; // 把a暴漏出去 index.js12const a = require( './lib/test.js' );module.exports = a; //把a暴漏出去 现在的目录结构123456-test-wyx -lib -test.js -index.js -package.json -readme.md 2.创建npm账号,两种方式第一种: 打开npm注册第二种: 命令行注册1npm adduser 依次输入用户名，密码，邮箱就注册成功了。注册成功会自动登录，所以现在已经在本地登录成功。如果你已经有npm账号可通过如下命名登录1npm login 输入用户名账号和密码即可登录 3.发布包 1npm publish 4.这时你就可以在npm官网 ,通过在搜索框中输入test-wyx来查询到你刚才发布的包了。5.更新包，你修改过包里的js文件时，同时还得修改package.json里version的版本号后才可重新发布。 应用包1.新建一个文件夹12mkdir testcd test 2.安装这个包1npm install test-wyx 3.然后，在test文件夹下新建index.js文件，输入如下代码12const test = require( 'test-wyx' );test.fun(); 4.在test文件夹,右键选择git bash here,输入如下命令1node index.js 就可以输出这是我的第一个npm包 参考 【npm】利用npm安装/删除/发布/更新/撤销发布包 在npm发布自己的包]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react和vue对比]]></title>
    <url>%2F2017%2F12%2F18%2F2017-12-18-react%E5%92%8Cvue%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[相同点 都支持服务器端渲染 都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范 数据驱动视图 都有支持native的方案,React的React native,Vue的weex 不同点 React严格上只针对MVC的view层,Vue则是MVVM模式 virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制 组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件; 数据绑定: vue实现了数据的双向绑定,react数据流动是单向的 state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理 后续将会对vue和react的这些对比做详细的分析讲解,敬请期待😊]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中受控与非受控组件]]></title>
    <url>%2F2017%2F12%2F12%2F2017-12-12-react%E4%B8%AD%E5%8F%97%E6%8E%A7%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[受控组件123456789&lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;(e) =&gt; &#123; this.setState(&#123; value: e.target.value.toUpperCase(), &#125;); &#125;&#125;/&gt; &lt;input&gt;或&lt;select&gt;都要绑定一个change事件;每当表单的状态发生变化,都会被写入组件的state中,这种组件在React中被称为受控组件;在受控组件中,组件渲染出的状态与它的value或者checked prop向对应.react通过这种方式消除了组件的局部状态,是的应用的整个状态可控.react官方同样推荐使用受控表单组件,总结下React受控组件更新state的流程: 1.可以通过初始state中设置表单的默认值; 2.每当表单的值发生变化时,调用onChange事件处理器; 3.事件处理器通过合成事件对象e拿到改变后的状态,并更新应用的state. 4.setState触发视图的重新渲染,完成表单组件值得更新 react中数据是单向流动的.从示例中,我们能看出来表单的数据来源于组件的state,并通过props传入,这也称为单向数据绑定.然后,我们又通过onChange事件处理器将新的表单数据写回到state,完成了双向数据绑定. 非受控组件 如果一个表单组件没有value props(单选按钮和复选按钮对应的是 checked props)时,就可以称为非受控组件; 使用defaultValue和defaultChecked来表示组件的默认状态; 通过 defaultValue和defaultChecked来设置组件的默认值,它仅会被渲染一次,在后续的渲染时并不起作用12345678910111213141516171819import React, &#123; Component &#125; from 'react';class UnControlled extends Component &#123; handleSubmit = (e) =&gt; &#123; console.log(e); e.preventDefault(); console.log(this.name.value); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" ref=&#123;i =&gt; this.name = i&#125; defaultValue="BeiJing" /&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125;export default UnControlled; 对比受控组件和非受控组件将输入的字母转化为大写展示123456789&lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;(e) =&gt; &#123; this.setState(&#123; value: e.target.value.toUpperCase(), &#125;); &#125;&#125;/&gt; 直接展示输入的字母123456789&lt;input type="text" defaultValue=&#123;this.state.value&#125; onChange=&#123;(e) =&gt; &#123; this.setState(&#123; value: e.target.value.toUpperCase(), &#125;); &#125;&#125;/&gt; 1.性能上的问题在受控组件中,每次表单的值发生变化,都会调用一次onChange事件处理器,这确实会带来性能上的的损耗,虽然使用费受控组件不会出现这些问题,但仍然不提倡使用非受控组件,这个问题可以通过Flux/Redux应用架构等方式来达到统一组件状态的目的. 2.是否需要事件绑定使用受控组件需要为每一个组件绑定一个change事件,并且定义一个事件处理器来同步表单值和组件的状态,这是一个必要条件.当然,某些情况可以使用一个事件处理器来处理多个表单域12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';class Controlled extends Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; name: 'xingxing', age: 18, &#125;; &#125; handleChange = (name, e) =&gt; &#123; const &#123; value &#125; = e.target; this.setState(&#123; [name]: value, &#125;); &#125; render() &#123; const &#123; name, age &#125; = this.state; return ( &lt;div&gt; &lt;input type="text" value=&#123;name&#125; onChange=&#123;this.handleChange.bind(this, 'name')&#125; /&gt; &lt;input type="text" value=&#123;age&#125; onChange=&#123;this.handleChange.bind(this, 'age',)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default Controlled; 表单组件的几个重要属性1.状态属性React的form组件提供了几个重要的属性,用来显示组件的状态 value: 类型为text的input组件,textarea组件以及select组件都借助value prop来展示应用的状态 checked: 类型为radio或checkbox的组件借助值为boolean类型的selected prop来展示应用的状态 selected: 该属性可作用于select组件下面的option上,React并不建议这种方式表示状态.而推荐在select组件上使用value的方式 2.事件属性当状态属性改变时会触发onChange事件属性.受控组件中的change事件与HTML DOM中提供的input事件更为类似;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中组件通信的几种方式]]></title>
    <url>%2F2017%2F12%2F10%2F2017-12-10-react%E4%B8%AD%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需要组件之进行通信的几种情况 父组件向子组件通信 子组件向父组件通信 跨级组件通信 没有嵌套关系组件之间的通信 1. 父组件向子组件通信React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息Child.jsx12345678910import React from 'react';import PropTypes from 'prop-types';export default function Child(&#123; name &#125;) &#123; return &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;&#125;Child.propTypes = &#123; name: PropTypes.string.isRequired,&#125;; Parent.jsx123456789101112131415import React, &#123; Component &#125; from 'react';import Child from './Child';class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Child name="Sara" /&gt; &lt;/div&gt; ); &#125;&#125;export default Parent; 2. 子组件向父组件通信 利用回调函数 利用自定义事件机制 回调函数实现在子组件中点击隐藏组件按钮可以将自身隐藏的功能 List3.jsx123456789101112131415161718import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class List3 extends Component &#123; static propTypes = &#123; hideConponent: PropTypes.func.isRequired, &#125; render() &#123; return ( &lt;div&gt; 哈哈,我是List3 &lt;button onClick=&#123;this.props.hideConponent&#125;&gt;隐藏List3组件&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default List3; App,jsx1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';import List3 from './components/List3';export default class App extends Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; isShowList3: false, &#125;; &#125; showConponent = () =&gt; &#123; this.setState(&#123; isShowList3: true, &#125;); &#125; hideConponent = () =&gt; &#123; this.setState(&#123; isShowList3: false, &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.showConponent&#125;&gt;显示Lists组件&lt;/button&gt; &#123; this.state.isShowList3 ? &lt;List3 hideConponent=&#123;this.hideConponent&#125; /&gt; : null &#125; &lt;/div&gt; ); &#125;&#125; 观察一下实现方法,可以发现它与传统回调函数的实现方法一样.而且setState一般与回调函数均会成对出现,因为回调函数即是转换内部状态是的函数传统; 3. 跨级组件通信 层层组件传递props 例如A组件和B组件之间要进行通信,先找到A和B公共的父组件,A先向C组件通信,C组件通过props和B组件通信,此时C组件起的就是中间件的作用 使用context context是一个全局变量,像是一个大容器,在任何地方都可以访问到,我们可以把要通信的信息放在context上,然后在其他组件中可以随意取到;但是React官方不建议使用大量context,尽管他可以减少逐层传递,但是当组件结构复杂的时候,我们并不知道context是从哪里传过来的;而且context是一个全局变量,全局变量正是导致应用走向混乱的罪魁祸首. 使用context下面例子中的组件关系: ListItem是List的子组件,List是app的子组件 ListItem.jsx12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class ListItem extends Component &#123; // 子组件声明自己要使用context static contextTypes = &#123; color: PropTypes.string, &#125; static propTypes = &#123; value: PropTypes.string, &#125; render() &#123; const &#123; value &#125; = this.props; return ( &lt;li style=&#123;&#123; background: this.context.color &#125;&#125;&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;/li&gt; ); &#125;&#125;export default ListItem; List.jsx123456789101112131415161718192021222324252627282930313233import ListItem from './ListItem';class List extends Component &#123; // 父组件声明自己支持context static childContextTypes = &#123; color: PropTypes.string, &#125; static propTypes = &#123; list: PropTypes.array, &#125; // 提供一个函数,用来返回相应的context对象 getChildContext() &#123; return &#123; color: 'red', &#125;; &#125; render() &#123; const &#123; list &#125; = this.props; return ( &lt;div&gt; &lt;ul&gt; &#123; list.map((entry, index) =&gt; &lt;ListItem key=&#123;`list-$&#123;index&#125;`&#125; value=&#123;entry.text&#125; /&gt;, ) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;export default List; app.jsx12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';import List from './components/List';const list = [ &#123; text: '题目一', &#125;, &#123; text: '题目二', &#125;,];export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;List list=&#123;list&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 4. 没有嵌套关系的组件通信 使用自定义事件机制 在componentDidMount事件中,如果组件挂载完成,再订阅事件;在组件卸载的时候,在componentWillUnmount事件中取消事件的订阅;以常用的发布/订阅模式举例,借用Node.js Events模块的浏览器版实现 使用自定义事件的方式下面例子中的组件关系: List1和List2没有任何嵌套关系,App是他们的父组件; 实现这样一个功能: 点击List2中的一个按钮,改变List1中的信息显示首先需要项目中安装events 包：1npm install events --save 在src下新建一个util目录里面建一个events.js123import &#123; EventEmitter &#125; from 'events';export default new EventEmitter(); list1.jsx12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import emitter from '../util/events';class List extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; message: 'List1', &#125;; &#125; componentDidMount() &#123; // 组件装载完成以后声明一个自定义事件 this.eventEmitter = emitter.addListener('changeMessage', (message) =&gt; &#123; this.setState(&#123; message, &#125;); &#125;); &#125; componentWillUnmount() &#123; emitter.removeListener(this.eventEmitter); &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.message&#125; &lt;/div&gt; ); &#125;&#125;export default List; List2.jsx123456789101112131415import React, &#123; Component &#125; from 'react';import emitter from '../util/events';class List2 extends Component &#123; handleClick = (message) =&gt; &#123; emitter.emit('changeMessage', message); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick.bind(this, 'List2')&#125;&gt;点击我改变List1组件中显示信息&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; APP.jsx123456789101112131415import React, &#123; Component &#125; from 'react';import List1 from './components/List1';import List2 from './components/List2';export default class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;List1 /&gt; &lt;List2 /&gt; &lt;/div&gt; ); &#125;&#125; 自定义事件是典型的发布订阅模式,通过向事件对象上添加监听器和触发事件来实现组件之间的通信 总结 父组件向子组件通信: props 子组件向父组件通信: 回调函数/自定义事件 跨级组件通信: 层层组件传递props/context 没有嵌套关系组件之间的通信: 自定义事件 在进行组件通信的时候,主要看业务的具体需求,选择最合适的;当业务逻辑复杂到一定程度,就可以考虑引入Mobx,Redux等状态管理工具 参考reactjs官方文档深入React技术栈React中组件间通信的几种方式]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript项目开发规范实例]]></title>
    <url>%2F2017%2F12%2F04%2F2017-12-04-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[总结一下个人在开发及review同事代码的过程中遇到的因为一些项目规范带来的问题及认为比较好的解决方法;由于个人经验和认知水平有限,下面仅代表我的个人观念,欢迎各位大佬多给我提建议; 以本人最近写的一个项目(技术栈为Meteor + React + MongoDB)为例 readme的使用因为一个项目往往需要很多人一起协助开发,还有可能会不断有新手接手项目,所以readme里面一定要仅可能多的信息 项目启动命令 代码规范 Commit Message 编写规范 命名: class命名,变量命名,函数命名,组件命名等 组件 目录结构 常遇到的问题及解决方案 也可以加一些项目中遇到的设计到的文档链接 代码规范eslint使用eslint来约束团队统一的代码规则eslint规则在.eslintrc.js中定义,觉得不合理的可以跟团队成员商量禁掉某条规则,或者有好的建议的也可以添加;主要注意一下几条: 代码缩进用4空格 语句必须默认后加分号 使用单引号 提交代码前将console.log语句删掉或注释掉(不然影响其他开发人员调试) 禁止使用var,使用es6的let,const声明变量 还有一些情况是不需要检测的,例如第3方的库, 框架、组件、ui库等等,可以将这些文件放在.eslintignore文件中,可以忽略eslint的检测 在文件顶部加上下面这行,可以禁掉整个文件的eslint规则1/* eslint-disable */ pre-commit 的使用使用方法1.在命令行安装1npm i --save-dev pre-commit 2.在package.json中配置12345678910&#123; "scripts": &#123; "eslint": "eslint ./ --ext js,vue --ignore-pattern .eslintignore --cache --fix", "lint-message": "echo '开始 eslint 检查, 存在 error 则会拒绝提交'" &#125;, "pre-commit": [ "lint-message", "eslint" // 进行eslint检查并自动修复一些简单的格式错误 ],&#125; 代码提交之前会强制code-review,不符合规范的不允许提交代码 如果项目实在没时间去改的话，可以git commit -m ‘XXX’ –no-verify 或 git commit -n ‘xxx’强制提交 小技巧-vscode可以配置保存自动修复eslint错误vscode安装eslint插件,在配置中配置如下12345678910111213141516171819202122&#123; "eslint.autoFixOnSave": true, "eslint.enable": true, "eslint.options": &#123; "extensions": [".js", ".vue", ".jsx"] &#125;, "eslint.validate": [ &#123; "language": "vue", "autoFix": true &#125;, &#123; "language": "javascript", "autoFix": true &#125;, &#123; "language": "javascriptreact", "autoFix": true &#125; ],&#125; Commit Message 编写规范编写Commit Message需要遵循一定的范式，内容应该清晰明了，指明本次提交的目的，便于日后追踪问题。1234567feat: 新功能fix: 修补bugdocs: 文档style: 格式(不影响代码运行的变动)refactor: 重构test: 添加测试chore: 构建过程或辅助工具的变动 命名命名的语义化真的特别特别重要,哪怕不知道要命名的这个词的英文是什么,也要去查一下;千万不要以a,b,c等没有任何语义的词去命名;之前我也总是注意不到这一点,但是最近在看同事的代码还有重构自己之前写的部分代码,命名压根看不明白这个变量的意思,总之,看这样的代码怎一个痛苦了得 常见class命名关键词： 布局类：header, footer, container, main, content, aside, page, section 包裹类：wrap, inner 区块类：region, block, box 结构类：hd, bd, ft, top, bottom, left, right, middle, col, row, grid, span 列表类：list, item, field 主次类：primary, secondary, sub, minor 大小类：s, m, l, xl, large, small 状态类：active, current, checked, hover, fail, success, warn, error, on, off 导航类：nav, prev, next, breadcrumb, forward, back, indicator, paging, first, last 交互类：tips, alert, modal, pop, panel, tabs, accordion, slide, scroll, overlay, 星级类：rate, star 分割类：group, seperate, divider 等分类：full, half, third, quarter 表格类：table, tr, td, cell, row 图片类：img, thumbnail, original, album, gallery 语言类：cn, en 论坛类：forum, bbs, topic, post 方向类：up, down, left, right 其他语义类：btn, close, ok, cancel, switch; link, title, info, intro, more, icon; form, label, search, contact, phone, date, email, user; view, loading… 变量命名: 名字要能准确的描述出该变量所代表的事物比如表示user的id就叫userId,而不要只叫user 函数命名建议：可使用常见动词约定 动词 含义 get 获取某个值 set 设置某个值 is 判断是否为某个值 has 判断是否有某个值 以下规则是此项目中使用的,主要看团队代码习惯: 组件名和组件所在文件名使用大驼峰式 css类名使用小写单词并用横线(-)分割 dom节点以$开头 组件 每个组件占一个文件 组件不包含状态则应写为 stateless 组件 非 stateless 组件使用 pure-render-decorator 优化 目录结构12345678910111213141516171819├── client │ ├── main.html 客户端页面模板│ └── main.js 客户端入口 ├── imports │ ├── client │ │ ├── App.jsx 顶层组件 │ │ ├── components 公共组件 │ │ ├── routers 前端路由 │ │ ├── styles 样式 │ │ └── views 视图 │ │ ├── header 公共头 │ │ ├── login 登录注册 │ ├── schema 模型 │ └── util 工具函数 ├── packages 自定义 meteor 包 ├── public 客户端资源 └── server ├── main.js 服务端入口 └── user 用户接口 issues的使用项目中总会遇到很多奇奇怪怪的问题,当时印象深刻,过了一段时间,就忘了具体的问题及解决办法,虽然每次可以通过查commit为fix的记录,但是这样查找起来很麻烦,我们项目是用gitlab来托管,可以合理的理由issues,每次遇到很棘手的问题的时候,可以提一个issues,等后期把这个问题解决了再把这个issues给关闭,并写上问题原因及解决办法分析 下面补充的是项目中针对Meteor后端开发的一些规范 数据库Collection 定义所有 Collection 定义放在 imports/schema 目录, 每个 Collection 务必定义 Schema 来约束字段 Schema 定义Schema 定义使用 SimpleSchema, 数据插入数据库前必须通过 schema 校验, 调用校验语句为 表名.schema.validate(要插入的数据); 过滤 Collection 字段默认情况下, 数据查询语句会返回所有字段, 比如 Memete.users.find({}) 会将用户的密码和 token 一并返回, 这样是不安全不正确的, find / findOne 的第二个参数是查询选项, fields 字段可以控制返回字段, 例如: 123456789Meteor.users.find( &#123; &#125;, &#123; fields: &#123; username: 1, profile: 1, &#125;, &#125;,); 该查询会返回 _id, username, profile 字段, 其中 _id 是默认返回的 自己定义populate方法(取出关联数据)在做邀请新的好友入群的时候,添加新的好友,利用reywood:publish-composite并不会自动更新数据,所以以后直接自己在客户端定义方法这样做的好处是解决了取关联数据不会自动更新的bug,但是有点麻烦的是每次需要关联数据的时候必须在客户端调用一次方法,正在考虑有没有更好的解决方法123456789101112131415import &#123; Meteor &#125; from 'meteor/meteor';const PopulateUtil = &#123; group(group) &#123; if (group) &#123; group.members = Meteor.users.find(&#123; _id: &#123; $in: group.members &#125; &#125;).fetch(); group.admin = Meteor.users.findOne(&#123; _id: group.admin &#125;); &#125; &#125;, groups(groups) &#123; groups.forEach(group =&gt; PopulateUtil.group(group)); &#125;,&#125;;export default PopulateUtil; 因为这次项目需要自己设计数据库,还有自己定义后端方法,之前没有任何经验,做到现在也总结出一点心得: 数据库设计一定要根据具体的业务逻辑(开始设计之前一定要和产品沟通清楚产品逻辑) 能在后端取到的数据,在接口定义的时候不要让前端去传 最后感觉后端的逻辑真的很复杂,需要各种判断,各种情况都得想到 推荐看一下这本代码大全(第二版),等看完这本书再好好的完善一下这篇文章 参考class如何命名更规范代码大全(第二版)Commit Message 编写指南]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中基础但是很容易忽略的点(一)]]></title>
    <url>%2F2017%2F11%2F27%2F2017-11-27-javascript%E4%B8%AD%E5%9F%BA%E7%A1%80%E4%BD%86%E6%98%AF%E5%BE%88%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E7%82%B9%2F</url>
    <content type="text"><![CDATA[引言: 本篇文章主要总结了一些javascript中特别基础的内容,主要涉及到DOM0级和DOM2级事件,事件流, 事件委托, 判断变量的类型每次被问到,总是能想起一点,但是也总记不全,所以遇到这种情况的时候,就简单的记录一下. DOM0级事件和DOM2级事件的区别DOM0事件 在标签内写onclick事件 在js中写onclick=function(){}函数 1&lt;input id="myButton" type="button" value="Press Me" onclick="console.log('thanks');" &gt; 123document.getElementById("myButton").onclick = function () &#123; console.log('thanks');&#125; 删除事件的方法是1btn.onclick = null; DOM2级事件监听方法: 两个方法用来添加和移除事件处理程序: addEventListener()和removeEventLister()他们都有三个参数: 事件名(如click); 事件处理程序函数 true表示在捕获阶段调用,false在冒泡阶段调用 addEventListener()可以为元素添加多个处理程序函数,触发时按照添加顺序依次调用;removeEventLister()不能移除匿名添加的函数 DOM0级事件和DOM2级事件的区别在一个标签上绑定多个事件处理程序,DOM0级只能覆盖,不会连续触发,但是DOM2级事件就不会出现这样的情况,它不会被覆盖,而且会连续触发 事件流 事件冒泡: 事件开始时是从最具体的元素接受,然后逐级向上传播: 比如点击了div, div-&gt;body-&gt;html-&gt;Document 事件捕获: 和事件冒泡相反,从最外面的元素向下传播: 比如同样点击了div: Document-&gt;html-&gt;body-&gt;div 事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先是事件捕获阶段；然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出相应。所有的浏览器都支持冒泡,我们通常使用事件冒泡,很少使用事件捕获 事件委托(事件代理)及使用场景事件委托原理:事件冒泡 使用场景:DOM需要事件处理程序,一般都是直接给她这种事件处理程序;但是有很多个DOM需要添加相同的事件处理程序呢,比如,每个li都有相同的click事件,如果按照之前的做法,用for循环,给每个元素添加事件,可想而知,会出现什么样的问题; javascript中,添加到页面上的事件程序直接影响到页面整体运行性能,因为需要不断的与DOM节点进行及哦啊胡,访问DOM次数越多,引起浏览器重绘与重排的次数也就越多,就会延长整个页面的交互准备时间,这就是为什么性能优化的重要思想之一就是减少DOM操作的原因;每个函数都是一个对象,是对象就会占用内存,对象越多,内存占用率就越大,自然性能就越差; 这下子知道为什么使用事件委托,只对它的父级这一对象进行操作会大大节省内存和优化性能了吧; 事件委托的核心代码如下: 1234567891011 window.onload = function() &#123; const ul = document.getElementById("ul"); ul.onclick = function(ev) &#123; const ev = ev || window.event; const target = ev.target || ev.srcElement; if (target.nodeName === 'li') &#123; console.log(123); console.log(target.innerHTML); &#125; &#125;&#125; Event对象提供了一个属性target,表示事件的目标节点,即触发该事件的节点(想具体了解一些这个事件的可以执行下面代码看浏览器的console内容)123document.onclick = function(e) &#123; console.log(e);&#125; 适合及不适合使用事件委托的事件适合: click, mousedown, mouseup, keydown, keyup, keypress;不适合:mouseover和mouseout虽然也有事件冒泡,但是需要经常计算他们的位置,处理起来有点麻烦;mousemove,每次都要计算它的位置,不好控制;还有一些本身没有冒泡的特性,如focus,blur等 mouseenter事件类似于mouseover事件。唯一的区别是 mouseente事件不支持冒泡。 判断变量类型 javaSctipt数据类型7种: Number, String, Boolean, Null, Undefined, Object, Symbol typeof操作符可能返回的值如下 undefined boolean string number object function注意: typeof 的能力有限，其对于null, Date、RegExp类型返回的都是”object”1234typeof null // 'object'typeof &#123;&#125;; // "object" typeof []; // "object" typeof new Date(); // "object" 使用场景:区分对象和原始类型,要区分一种对象类型和另一种对象类型,可以使用: instanceof运算符或对象contructor属性 instanceof运算符用法: 左边的运算数是一个object,右边运算数是对象类的名字或者构造函数;返回true或false1234[] instanceof Array; // true[] instanceof Object; // true[] instanceof RegExp; // falsenew Date instanceof Date; // true 如果object是class或者构造函数的实例,则返回true,如果不是或者是null也返回falseinstanceof运算符判断是否为数组类型123function isArray(arr)&#123; return arr instanceof Array; &#125; contructor属性所有的对象都有一个constructor属性,指向该对象的基本对啊性构造函数类型的属性12345var a = new Array;a.constructor === Array // truevar n = new Number(3);n.constructor === Number; // true 判断为数组还可以这样123function isArray(arr)&#123; return typeof arr === "object" &amp;&amp; arr.constructor === Array; &#125; Object.ProtoType.toString()每个对象都有一个toString()方法,返回”[object type]”,其中type是对象的类型当执行该方法时,执行以下步骤1,获取对象的class属性2,连接字符串 “[object “+结果1+”]” ; 所以可以通过toString()来获取每个对象的类型,为了每个对象都可以通过Object.protoType.toString()来检测,需要以Funciton.prototype.call()或Function.prototype.apply()的形式来调用,传递要检查的对象作为第一个参数,称为thisArg123Object.prototype.toString.call(new Date); // "[object Date]"Object.prototype.toString.call([]); // "[object Array]"Object.prototype.toString.call(/reg/ig); // "[object RegExp]" 参考JavaScript中判断对象类型的几种方法总结js中的事件委托或是事件代理详解]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html代码实现一些符号]]></title>
    <url>%2F2017%2F11%2F22%2F2017-11-22-html%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[整理常用的一些html特殊符号在写html的时候经常会遇到一些特殊符号,例如&gt;等,大家都知道直接写&lt;或者&gt;等代码会报错,原因是因为&lt;div&gt;&lt;/div&gt;,标签是用这个符号的,代码执行的时候会以为你只写了一半,所以报错,今天就整理一写这些特殊符号用html怎么表示 html符号 特殊符号 含义 &amp;lt; &lt; 小于或显示标记 &amp;gt; &gt; 大于或者显示标记 &amp;amp; &amp; 用于显示其他特殊字符 &amp;quot; &quot; 引号 &amp;reg; &reg; 已注册 &amp;copy; &copy; 版权 &amp;trade; &trade; 商标 参考HTML特殊字符编码对照表]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请看我漂亮的坚持]]></title>
    <url>%2F2017%2F11%2F21%2F2017-11-21-%E8%AF%B7%E7%9C%8B%E6%88%91%E6%BC%82%E4%BA%AE%E7%9A%84%E5%9D%9A%E6%8C%81%2F</url>
    <content type="text"><![CDATA[今天是2017年11月21日,一周年纪念~ 今天是2017年11月21日,嘿嘿,说的是一周年纪念不是爱情的纪念,因为去年的今天我入职第一家公司,从此开始了程序媛的生活~ 记得2016年11月21日是个周一.那天下着雪,在经过一个多星期的奔波,还清晰的记得那会每天奔波的北京的各个地方,面试,很多时候,一天安排两个面试,而两个面试地点距离非常远,那会每天基本都没时间吃饭,一个星期,瘦了差不多10斤,晚上回来的时候就随便在路边买点吃的,整理今天一天面试中被问到的问题,没有回答上来或者回答不好的地方,就去网上查资料,看书查.珍惜每一次面试机会,终于找到了一家肯接受我的公司,周日那天,整整睡了一天,记得那天醒来就下午三点多了吧.入职后的每一天都小心翼翼的,因为没有经验,遇到很多问题,经常加班到晚上11点才回来,然后晚上回来还要写代码到一两点,刚来北京那会,没有钱,租的那种500块钱一个人的床位,每天回来的时候大家都已经睡着了,小心翼翼的开开门,此时别人的一个转身我都害怕是被自己吵醒的,然后洗漱完,在床位上打开电脑,把屏幕调到最暗,开始解决今天遇到的在有道云笔记上记录的问题,实在太困了,就睡;那时,就是一个想法,好好干,别被开除了,还年轻,吃点苦算什么.累的时候就会跟自己对话,当初为什么要选择这一行,不是计算机专业出身,决定从事这一行业的时候,就想到要比别人付出更多才能补回来自己缺的一些东西. 记得当时还犯了一个很严重的错误,虽然只是写写静态页面,但是写了一个星期之后,技术老大(虽然当时研发只有他和我)发现我写的代码不兼容,我能看出他看着我很无奈的样子,我立马承认自己的错误,并给他保证不用重新写,是可以改好的,自己就主动申请加班,内心里想着不要开除我就好. 后来开始做移动端,技术老大说不然咱们就试试比较流行的框架,react , vue, angular,记得当时angular还是1.0,选技术栈的过程比较曲折,终于最后选择了vue,不知道有多少人和我又一样的感受,之前一直写jq,一下子换成vue,首先思考问题的角度都要转换一下,jq是直接操作DON的,但是vue不是.印象深刻的还有,当时记得写了两个星期vue,遇到很多问题,比如路由怎么实现,等等,技术老大说,咱们能hold住新技术么,不行就换回jq,我说:现在社区这么活跃,你遇到的问题大家都遇到过,肯定是可以解决的.真的很感谢,给我机会去尝试新技术. 也许是骨子里带着一股不服输的精神,坚持一直学,天道酬勤,终于后来慢慢在公司里有点权威,最起码,产品提的需求,别人实现不了,我可以实现.就是这样慢慢建立起了自信,经过自己的努力实现的那种成就感,很爽! 到今天整整一年了,技术上相比去年也增长了很多,大概在今年夏天的时候开始写自己的博客,在简书上发表文章,看到下面有人给我评论,和我交流技术,真的很开心,看到很多人通过博客加我好友,支持我,鼓励我,给我提建议,还有前几天第一次在掘金上发表文章,很多人给我点赞,还有大佬给我提建议,真的发自内心的感谢! 这一年接触了很多东西,写过vue,react,koa,玩过小程序,现在在用Meteor+react+mongoDB写全栈,但是对于具体的原理了解的可能还不是很深入,所以接下来一年,我给自己制定的目标,学好js的基础,在此基础上学一些主流框架原理上的一些东西,还有目前实现产品提的需求已经不是什么大的问题了,问题是如果写好,比如代码的组织和性能等,总之路漫漫其兮远,慢慢一步一步脚踏实地的来. 大概就写到这儿吧,看到这篇文章的有缘人,不知道你是否和我一样也有这些经历,不过,肯定是和我一样希望让自己变得更优秀的人,只要用心学习,付出努力,技术肯定是会慢慢提高的. 给大家推荐几本书: Javascript高级程序设计(3),(记得我看的是第三版,或者权威指南,讲的js的知识特别全) 你不知道的JavaScript系列(深入的讲解javascript) 深入理解es6 深入浅出react技术栈 图解http 大话设计模式 NodeJs实战]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两句话理解js中的this]]></title>
    <url>%2F2017%2F11%2F16%2F2017-11-06-this%2F</url>
    <content type="text"><![CDATA[前言: 一直都搞不清javascript中this的指向,&lt;你不知道的javascript(上卷)&gt;这本书中有3章都是在讲解this,去年第一次看完还是觉得似懂非懂的,一深入的问还是不清楚,现在在看一遍,真心觉得这本书里将的是真好,想深入了解一下的,这本书是一个不错的选择. 下面我就简单的说一下我的理解,用两句话记住了javascrpt中this的指向: this的指向 普通函数指向函数的调用者:有个简便的方法就是看函数前面有没有点,如果有点,那么就指向点前面的那个值; 箭头函数指向函数所在的所用域: 注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域; 12345678910111213// const obj = &#123; name: 'objName', say() &#123; console.log(this.name); &#125;, read: () =&gt; &#123; console.log(this.name); &#125;&#125;obj.say(); // objNameobj.read(); // undefined 普通函数,调用者是obj,所以结果是 objname;也是理解say()是普通函数,前面有点,所以this指向obj; 箭头函数,this指向函数所在的作用域,当前的作用域为全局环境,所以this.name为undefined, 举下面的例子更清楚的了解一下箭头函数this的指向,箭头函数所在的作用域是普通函数say,say()的调用者是obj12345678const obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj,此时this指的是定义他的obj 补充知识点 浏览器默认的this为window 1234function test() &#123; console.log(this);&#125;test(); //window node.js中全局环境默认this为{},普通函数中默认this为global 123456console.log(this); // &#123;&#125;function test() &#123; console.log(this);&#125;test(); //global 来两道题检查你是否掌握了example11234567891011121314const length = 10;function fn() &#123; console.log(this.length);&#125;const obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 输出 10, 2 刚开始看到这道题我也是蒙蒙的,现在也终于理解了,method这个函数传入了两个参数,一个参数为fn(),fn()为普通函数,this指向函数的调用者,此时指向全局(也可以看这个函数前面没有点),所以运行结果为10,arguments是函数的所有参数,是一个类数组的对象,arguments0,可以看成是arguments.0(),调用这个函数的是arguments,此时this就是指arguments,this.length就是angument.length,就是传入的参数的总个数2 注: 上面例子在node环境中的运行结果为 undefined 2, const length = 10改成global.length = 10;是因为node环境下定义在全局的变量不会绑定到global,浏览器也会自动绑定到全局环境window 改成下面这样结果又是什么呢?12345678910111213141516const length = 10;function fn() &#123; console.log(this.length);&#125;const obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10, 10 example 212345678910111213window.val = 1;var obj = &#123; val: 2, dbl: function() &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;obj.dbl(); // 2 4var func = obj.dbl;func(); // 8 8 这个就是有点绕了,不过一步步来分析就很容易理解了: obj.dbl();执行这行代码时，this指的是obj，所以this.val === obj.val*=2,最后结果为4,val*=2 === window.val *= 2，最后结果是2 func()，执行这行代码时，func()没有任何前缀，this指的是window.func();所以此时this值得是window，this.val === window.val *= 2,此时window.val 为4，val*=2 === window.val *2,最后结果为8，最后console.log(this.val),与console.log(val),指的都是window.val，最后结果都是8]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探React生命周期]]></title>
    <url>%2F2017%2F11%2F14%2F2017-11-14-%E5%88%9D%E6%8E%A2React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[react生命周期挂载和卸载过程1,组件挂载是最基本的过程,这个过程主要做组件状态的初始化.12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class App extends Component &#123; // 1,这两个属性被声明成静态属性,意味着你也可以再类外面访问他们: App.propTypes和 App.defaultProps static propTypes = &#123; // props的类型检查 &#125; static defaultProps = &#123; // props的默认类型 &#125; constructor(props) &#123; super(props); this.state = &#123; // &#125; &#125; // 2,componentWillMount和componentDidMount分别代表了渲染前后的时刻 componentWillMount() &#123; // 在render方法之前执行 &#125; componentDidMount() &#123; //render方法之后执行 &#125; // 3,这个初始化过程没什么特别的,包括读取初始state和props以及这两个生命周期的方法componentWillMount和componentDidMount,这些都只会在组件初始化时运行一次 // 4,如果我们在componentWillMount中执行setState方法,会发生什么呢?组件会更新state,但是组件只渲染一次,初始化的state都可以放在this.state // 5,我们在componentDidMount中执行setState方法,又会发生什么呢?组件当然会再次更新,不过在初始化阶段就渲染了两次,这并不是一件好事. // 但是实际的情况是,有一些场景不得不需要setState,比如计算组件的宽高时,就不得不让组件先渲染,更新必要的信息,再次渲染 componentWillUnmount() &#123; // 组件卸载只有componentWillUnmount,这是一个卸载前状态 // 在这个方法中,我们常常会执行一些清理方法,如事件回收或是清理定时器 &#125; render() &#123; return ( &lt;div&gt; this is demo &lt;/div&gt; ); &#125;&#125;export default App; 数据更新过程12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class App extends Component &#123; componentWillReceiveProps(nextProps) &#123; // this.setState(&#123;&#125;) &#125; shouldComponentUpdate(nextProps, nextState) &#123; // return true // shouldComponentUpdate是一个特别的方法,他接受需要更新的props和state,让开发者增加必要的条件判断,让其在需要时更新.因此,当方法返回false的时候,组件不再向下执行生命周期方法 &#125; componentWillUpdate(nextProps, nextState) &#123; // 需要提供更新的props和state // 这里不能执行setState &#125; componentDidUpdate(prevProps, prevState) &#123; // 提供更新前的props和state &#125; render() &#123; return ( &lt;div&gt; this is demo &lt;/div&gt; ); &#125;&#125;export default App; 如果组件自身的state更新了,那么会依次执行shouldComponentUpdate,componentWillUpdate,render, componentDidUpdate. shouldComponentUpdate是一个特别的方法,他接受需要更新的props和state,让开发者增加必要的条件判断,让其在需要时更新.因此,当方法返回false的时候,组件不再向下执行生命周期方法 本质是用来进行正确的组件渲染(也是性能优化的手段之一): 当父节点props改变的时候,在理想情况下,只渲染在一条链路省有相关props改变的节点即可,但是默认情况下,React会渲染所有的节点,因为shouldComponentUpdate默认返回true 值得注意的是,无状态组件是没有生命周期方法的,这也意味着它没有shouldComponentUpdate,渲染到该类组件时,每次都会重新渲染,不少开发者在使用无状态组件开发的时候都会纠结这一点,为了更方心得使用,我们可以选择用Recompose库的pure方法; const optionmizeComponent = pure(ExpensiveComponent) pure方法做的事情就是将无状态组件转换成class语法加上PureRender后的组件 如果组件是由父组件更新props而更新的,那么在shouldComponentUpdate之前会先执行componentWillReceiveProps方法,此方法可以作为React在props传入后,渲染之前setState的机会,在此方法中调用setState是不会二次渲染的 整体流程React的生命周期流程我们用一张图来表示 Aboutgithubblog]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解git系列]]></title>
    <url>%2F2017%2F11%2F02%2F2017-11-02-git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文章参考: http://git.oschina.net/progit/ 1,git简介版本控制简而言之,就是可以报存你所有的修改,所有的历史版本;有了它,就可以将某个文件回溯到之前的状态,甚至可以将整个项目回退到过去某个时间点的状态;你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等 类别集中化的版本控制系统(eg: svn) 分布式版本控制系统(eg: git) 文件的三种状态对于任何一个文件，在 Git 内都只有三种状态： 已提交（committed），已提交表示该文件已经被安全地保存在本地数据库中了； 已修改（modified,已修改表示修改了某个文件，但还没有提交保存； 已暂存（staged）。已暂存表示把已修改的文件放在下次提交时要保存的清单中。git管理项目时,文件流转的三个工作区域:git的工作目录,暂存区域,本地仓库 每个项目都有一个Git目录(如果 git clone 出来的话，就是其中 .git 的目录) 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中 2,git基础取得项目的Git仓库有两种方法:1,在现存的目录下,通过导入所有文件来创建新的Git仓库;2,从已有的Git仓库克隆出一个新的镜像仓库 在工作目录中初始化新仓库 123git init // 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中git add README // 如果当前目录下有几个文件想要纳入版本控制,需要先用`git add`命令告诉git开始对这些文件进行跟踪,并进行提交git commit -m 'initial project version' 从现有仓库克隆克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： 1git clone git://github.com/schacon/grit.git 当前目录下创建一个名为grit的目录,其中包含一个.git的目录用于保存下载下来的所有版本记录,然后从中取出最新版本的文件拷贝如果希望在git clone的时候,自己定义要新建的项目目录的名称,可以再上面的命令的末尾指定新的名字1git clone git://github.com/schacon/grit.git mygrit 现在新建的目录就成了mygrit 文件状态git status 可以查看文件目前处于什么状态git add xx 这是一个多功能命,根据目标文件的状态不同,此命令的效果也不同;可以用它开始跟踪新文件,或者把已跟踪的文件放到暂存区,还能用于合并时把有冲突的文件标记为已解决状态 忽略某些文件我们可以创建一个.gitignore的文件,列出要忽略的文件模式.gitignore的格式规范如下: 所有空行或者以注释符号#开头的行都会被Git忽略 可以使用标准的glob模式匹配(shell所使用的简化了的正则表达式) 匹配模式最后跟反斜杠(/)说明要忽略的是目录 要忽略指定模式以外的文件或目录,可以再模式前加上(!)取反 1234567891011# 此为注释 – 将被 Git 忽略 # 忽略所有 .a 结尾的文件 *.a # 但 lib.a 除外 !lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO /TODO # 忽略 build/ 目录下的所有文件 build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt doc/*.txt 查看已暂存和未暂存的更新12git diffgit diff --cached 提交更新12git commitgit commit -m&apos;docs: change readme&apos; // -m参数后跟提交的方式 git commit 规范参考 跳过使用暂存区域 git commit -a -m&#39;feat: add new tasks&#39;git 提供了一个跳过使用暂存区域的方式，只要在提交的时候给git commit加上-a选项，git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add步骤1git commit -a -m&apos;feat: add new tasks&apos; 移除文件 git rm从git中移除某个文件，必须要从已跟踪文件清单移除（从暂存区域移除）,然后提交,git rm命令完成此项工作，并连带从工作目录中删除制定的文件，这样以后就不会出现在未跟踪文件清单了1git rm .test 如果是简单从工作目录中手工删除文件，仅删除了工作目录中的，仍在追踪名单中然后再运行 git rm记录此次移除文件的操作最后提交就不会被跟踪了。但是如果删除文件之前修改过且已经放到暂存区，则必须要加-f(即force的首字母)在实际项目中，经常会遇到下面的情况需要删除文件想把文件从git仓库中删除，但是仍希望保留在工作目录中，就是仅从跟踪清单中删除，比如一些大型日志或一堆.a的编译文件，不小心纳入仓库，但是要移除追踪但不删除文件，以便稍后在.gitignore文件中补上，加参数--cached1git rm --cached readme.txt 后面可以列出文件或者目录的名字，也可以使用 glob 模式。注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，12git rm log/\*.log // 此命令删除所有 log/ 目录下扩展名为 .log 的文件git rm \*~ //会递归删除当前目录及其子目录中所有 ~ 结尾的文件。必须加反斜杠 移动文件git mv1git mv file_from file_to 相当于运行123mv README.txt READMEgit rm README.txtgit add README 查看提交历史 git log123git log -p -2 // -p选项展开每次提交的内容差异， -2则仅显示最近两次更新， 做代码审查，或者快速浏览其他写作者提交的更新都做了哪些git log --stat // 仅显示简要的增改行数git log --pretty // 指定使用完全不同于默认风格的方式展示提交历史，比如`git log --pretty=oneline`将每个提示放在一行显示，另外还有short， full和fuller format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析1234git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 11 months ago : changed the version number085bb3b - Scott Chacon, 11 months ago : removed unnecessary test codea11bef0 - Scott Chacon, 11 months ago : first commit 用 oneline 或 format 时结合 –graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况1234567891011$ git log --pretty=format:&quot;%h %s&quot; --graph * 2d3acf9 ignore errors from SIGCHLD on trap * 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit |\ | * 420eac9 Added a method for getting the current branch. * | 30e367c timeout code and tests * | 5a09431 add timeout protection to grit * | e1193f8 support for heads with slashes in them |/ * d6016bc require time for xmlschema * 11d191e Merge branch &apos;defunkt&apos; into local 列出了常用的格式占位符写法及其代表的意义。12345678910111213141516选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 一些其他常用的选项及其释义。12345678910选项 说明 -p 按补丁格式显示每个更新之间的差异。 --stat 显示每次更新的文件修改统计信息。 --shortstat 只显示 --stat 中最后的行数修改添加移除统计。 --name-only 仅在提交信息后显示已修改的文件清单。 --name-status 显示新增、修改、删除的文件清单。 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 --graph 显示 ASCII 图形表示的分支合并历史。 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制输入长度 –since 和 –unti1234567git log --since=2.weeks // 列出所有最近两周内的提交选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 如果要查看 Git 仓库中，2017 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令1git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ 撤销操作修改最后一次提交 git commit --amend123git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交：上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。 取消已经暂存的文件 git reset HEAD &lt;file&gt;...有两个修改过的文件，我们想要分开提交，但不小心用 git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢1git reset HEAD benchmarks.rb 取消对文件的修改 git checkout -- &lt;file&gt;..如果觉得刚才对 benchmarks.rb 的修改完全没有必要，该如何取消修改，回到之前的状态（也就是修改之前的版本）呢1git checkout -- benchmarks.rb 任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的 远程仓库的使用 查看当前的远程库 git remove -v,名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库 添加远程仓库git remote add [shortname] [url] 从远程仓库抓取数据git fetch [remote-name] 推送数据到远程仓库 git push [remote-name] [branch-name] 查看某个远程仓库信息git remote show [remote-name] 远程仓库的删除和重命名 git remote rename pb paul git remote rename rm [remote-name]1234567891011121314git remove -vgit remote add pb git://github.com/paulboone/ticgit.gitgit fetch pb // git push origin master //把本地的 master 分支推送到 origin 服务器上git remote show origin // 要看所克隆的 origin 仓库$ git remote rename pb paul $ git remote origin paulgit remote rm paul $ git remote origin git fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支,git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 打标签 列显已有的标签 git tag 新建标签,含附注的标签 3，分支简单的分支与合并，实际工作中大体的工作流程1，开发某个网站2，为了实现某个需求，创建一个分支3，在这个分支上开展工作；假设此时，突然有个紧急的问题要修复，那么你可以按照下面的方式处理:1,返回原先已经发布到生产服务器上的分支；2，为这次紧急修补创建一个新分支，并在其中修复问题3，通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上4，切换到之前实现新需求的分支，继续工作 新建分支 新建分支 git branch xx,这条命令是新建了一个分支，但是当前工作分支仍在mater分支上，要想把当前工作分支切换到新建的分支上，要执行git checkout xx 新建并切换到某分支git checkout -b xx相当与下面这两条命令12git branch xxgit checkout xx 切换分支的时候要确保你当前分支不存在没有提交的修改，否则git会阻止你切换分支 删除分支 删除分支 git branch -d xx合并分支 分支的合并，比如master分支要合并xx分支，首先切换到master分支，然后执行git merge xx,此时xx分支已经合并到master分支上，接下来删除xx分支 123git checkout mastergit merge xxgit branch -d xx 遇到冲突时的合并，如果在不同的分支中都修改看同一个文件，git就无法将两者合并到一起 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id="footer"&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html =======隔开的上半部分，即HEAD(即master分支，在运行merge命令时所切换到的分支)，下半部分是xx分支的内容你可以二者选其一或者整合两者到一起，然后删除&lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行.解决完所有冲突后，运行git add将他们标记为已解决状态(实际就是将该文件存到暂存区，因为一旦暂存，就表示冲突已经解决) 分支的管理1234git branch // 列出当前所有分支，注意看master分支前的 * 字符：它表示当前所在的分支git branch -v // 查看各个分支最后一个提交对象的信息git branch --merged // 筛选与当前分支合并的分支git branch --no-merged // 筛选与当前分支尚未合并的分支，此时如果使用`git branch -d xx`删除该分支会提示错误，因为这样会丢失数据，如果你确实想删除该分支上的改动，运行`git branch -D xx`强制删除 利用分支开发的工作流程长期分支在master分支中保留完全稳定的代码，即已经发布或即将发布的代码，与此同时，还有一个名为develop或next的平行分支，专门用于后续的开发或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。 特性分支一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。 远程分支远程分支是对远程仓库中分支的索引。(远程仓库)/(分支名)表示远程分支 推送远程分支git push (远程仓库名) (分支名)12345678 git push origin serverfix Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。仓库中去，仍旧称它为 servergit push origin serverfix:serverfix上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支git push origin serverfix:awesomebranch上传我本地的 serverfix 分支到远程仓库中去，称它为 awesomebranch 分支 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix 想要基于远程分支上新建一个新的分支 git checkout -b serverfix origin/serverfix 跟踪远程分支从远程分支checkout出来的本地分支，成为跟踪分支。跟踪分支是一种和某个远程分支有直接联系的公司；克隆仓库时，git通常会自动创建一个名为master分支来跟踪origin/master;这正是 git push 和 git pull 一开始就能正常工作的原因 git checkout -b serverfix origin/serverfix 可以用 –track 简化: git checkout –track origin/serverfix 本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字: git checkout -b sf origin/serverfix 删除远程分支 git push [远程名] :[分支名] git push [远程名] [本地分支]:[远程分支],如果省略 [本地分支]，如果省略 [本地分支] 分支的衍合把一个分支整合到另一个分支的办法有两种: merge rebase使用衍合的目的是想要得到一个能在远程分支上干净应用的补丁,简单的说就是修改提交历史一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。12345git rebase --onto master server client取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍”git rebase [主分支] [特性分支] 命令会先取出特性分支 server，然后在主分支 master 上重演：git rebase master server]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC]]></title>
    <url>%2F2017%2F11%2F02%2F2017-11-02-WebRTC%2F</url>
    <content type="text"><![CDATA[1,WebRTC入门基础什么是WebRTCWebRtc(Web Real-Time Communication)支持网页浏览器进行实时语音对话或视频对话的技术; 浏览器本身不支持互相之间直接建立信道进行通信,都是通过服务器进行中转.比如现在有两个客户端,甲和乙,他们俩想要通信,首先需要甲和服务器.乙和服务器之间建立信道.甲给乙发送消息时,甲先将消息发送到服务器上,服务器对家的消息进行中转,发送到乙处,反过来也是一样.这样甲和乙之间的依次消息要通过两段信道,通信的效率同时受制于这两端信道的带宽.同时这样的信道并不适合数据流的传输 WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口;让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频 三个接口WebRTC实现了三个API,分别是: MediaStream: 通过MediaStream的API能够通过设备的摄像头及话筒获得视频,音频的同步流 RTCPeerConnection: RTCPeerConnection是WebRTC用于构建点对点之间稳定高效的流传输的组件 RTCDataChannel: RTCDataChannel使得浏览器之间(点对点)建立一个高吞吐量.低延时的信道,用于传输任意数据 MediaStream(getUserMedia)通过MediaStream的API能够通过设备的摄像头及话筒获得视频,音频的同步流 如果调用可以通过调用navigator.getUserMedia(),这个方法接受三个参数:1,一个约束对象(constrains object)2,一个调用成功的回调函数,如果调用成功,传递给他一个流对象3,一个调用失败的额回调函数,如果调用失败,传递给他一个错误对象 浏览器的兼容性1234const getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); 约束对象可以被设置在getUserMedia()和RTCPeerConnection的 addStream方法中,这个约束对象是WebRTC用来指定接受什么样的流,其中可以定义如下属性 video: 是否接受视频流 audio: 是否接受音频流 MinWidth: 视频流最小宽度 MaxWidth: 视频流最大宽度 MinHeight: 视频流最小高度 MaxHeight: 视频流最大高度 MinAspectRatio: 视频流最小宽高比 MaxAspectRatio: 视频流最大宽高比 MinFramerate: 视频流最小帧速率 MaxFramerate: 视频流最大帧速率 例子1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;GetUserMedia实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id="video" autoplay&gt;&lt;/video&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); getUserMedia.call(navigator, &#123; video: true, audio: true &#125;, function(localMediaStream) &#123; var video = document.getElementById('video'); video.src = window.URL.createObjectURL(localMediaStream); video.onloadedmetadata = function(e) &#123; console.log("Label: " + localMediaStream.label); console.log("AudioTracks" , localMediaStream.getAudioTracks()); console.log("VideoTracks" , localMediaStream.getVideoTracks()); &#125;; &#125;, function(e) &#123; console.log('Reeeejected!', e); &#125;);&lt;/script&gt;&lt;/html&gt; 这里使用getUserMedia获得流之后,需要将其输出,一般绑定到video标签上输出,需要使用window.URL.createObjectURL(localMediaStream)来创造能在video中使用 src属性播放的Blob URL,注意在video上加入autoplay属性,否则只能扑火到一张图片流创建完毕后可以通过label属性来获得其唯一的标识，还可以通过getAudioTracks()和getVideoTracks()方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组） PTCPeerConnectionWebRTC使用RTCPeerConnection来在浏览器之间传递流数据,这个流数据通道是点对点的,不需要经过服务器进行中转.但是这并不意味着我们能抛弃服务器.我们仍然需要它来为我们传递信令来建立这个信道.WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分 信令既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道.比如可以用node的ws模块,在在WebSocket上传递信令需要信令来交换的信息有三种： session的信息:用来初始化通信还有报错 网络配置: 比如IP地址和端口啥的 媒体适配: 发送方和接受方的浏览器能接受什么样的编码器和分辨率 通过服务器建立信道就算WebRTC提供浏览器之间点对点信道的数据传输,但是建立这个信道,必须有服务器的参与,WebRTC需要服务器对其进行4方面的功能支持 1,用户发现以及通信 2,信令传递 3,NAT/防火墙穿越 4,如果点对点通信建立失败,可以作为中转服务器 NAT/防火墙穿越技术建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越 ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。 RTCDataChannel既然能建立点对点的信道来传递实时的视频,音频数据流.为什么不你能用这个信道传一点其他数据呢?RTCDataChannel就是用来干这个的,基于它我们可以再浏览器之间传输任意数据,DataChannel是建立在PeerConnection上的,不能单独使用 我们可以使用channel = pc.createDataCHannel(“someLabel”);来在PeerConnection的实例上创建Data Channel，并给与它一个标签DataChannel使用方式几乎和WebSocket一样，有几个事件： onopen onclose onmessage onerror 同时它有几个状态，可以通过readyState获取： connecting: 浏览器之间正在试图建立channel open：建立成功，可以使用send方法发送数据了 closing：浏览器正在关闭channel closed：channel已经被关闭了两个暴露的方法: close(): 用于关闭channel send()：用于通过channel向对方发送数据 通过Data Channel发送文件大致思路JavaScript已经提供了File API从input[type=’file’]的元素中提取文件，并通过FileReader来将文件的转换成DataURL，这也意味着我们可以将DataURL分成多个碎片来通过Channel来进行文件传输 2,信令WebRTC的服务器WebRTC提供了浏览器到浏览器（点对点）之间的通信，但并不意味着WebRTC不需要服务器。暂且不说基于服务器的一些扩展业务，WebRTC至少有两件事必须要用到服务器： 浏览器之间交换建立通信的元数据（信令）必须通过服务器 为了穿越NAT和防火墙为什么需要信令我们需要通过一系列的信令来建立浏览器之间的通信.而具体需要通过信令交换哪些内容,下面简单的列了一下1,用来控制通信开启或者关闭的连接控制信息2,发生错误时用来彼此告知的信息3,媒体流元数据,比如像解码器,解码器的配置,带宽,媒体类型4,用来建立安全连接的关键数据5,外界所看到的网络上的数据,比如IP地址,端口等在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。 会话描述协议(Session Description Protocol)JSEP将客户端之前传递的信令分为两种:offer信令和answer信令.他们主要内容的格式都遵循会话描述协议(Session Description Protocol,简称SDP)是一个在点对点连接中描述自己的字符串.我们可以将其封装在JSON中进行传输,在PeerConnection建立后将通过服务器中转后,将自己的SDP描述符和对方的SDP描述符交给PeerConnection就行了 信令与PTCPeerConnection建立1,通过offer和answer交换SDP描述符大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况，RTCPeerConnection简称PC）： 甲和乙各自建立一个PC实例 甲通过PC所提供的createOffer()方法建立一个包含甲的SDP描述符的offer信令 甲通过PC所提供的setLocalDescription()方法，将甲的SDP描述符交给甲的PC实例 甲将offer信令通过服务器发送给乙 乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的setRemoteDescription()方法交给乙的PC实例 乙通过PC所提供的createAnswer()方法建立一个包含乙的SDP描述符answer信令 乙通过PC所提供的setLocalDescription()方法，将乙的SDP描述符交给乙的PC实例 乙将answer信令通过服务器发送给甲 甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用setRemoteDescripttion()方法交给甲自己的PC实例 甲和乙所创建的PC实例都包含了甲和乙的SDP描述符,接下来–获取连接两端主机的网络地址 2,通过ICE框架建立NAT/防火墙穿越的连接123456var iceServer = &#123; "iceServers": [&#123; "url": "stun:stun.l.google.com:19302" &#125;]&#125;;var pc = new RTCPeerConnection(iceServer); 当然这两个地址也需要交换,交换流程如下(RTCPeerConnection简称PC);1,甲,乙各创建配置了ICE服务器的PC实例,并为其添加onicecandidate事件回调2,当网络候选可用时,将会调用onicecandidate函数3,在回调函数内部,甲或乙将网络候选色消息封装在ICE Candidate命令中,通过服务器中转,传递给对方4,甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时,将其解析并并获得网络候选,将其通过PC实例的addIceCandidate()添加到PC实例中 这样连接就创建完成了,可以向RTCPeerConnection中通过addStream()加入流来传输媒体流出具.将流加入到RTCPeerConnection实例中,对方就可以通过onaddstream所绑定的回调函数监听到了,调用addStream()可以再连接完成之前,在连接建立之后,对方一样能监听到媒体流 聊天室中的信令用户操作1,打开页面连接到服务器2,进入聊天室3,与其他所有已在聊天室的用户建立点对点的连接,输入到页面4,若有聊天室内其他用户离开,得到通知,关闭与其的连接并移除其在页面中的输出5,若又有其他用户加入,应得到通知,建立与新加入用户的连接,并输出在页面上6.离开页面,关闭所有连接 实现思路以使用WebSocket为例1,浏览器与服务器建立WebSocket连接2,发送一个加入聊天室的信令(join),信令中需要包含用户所进入的聊天室名称3,服务器根据用户所加入的房阿金,发送一个其他用户信令(peers);信令中包含聊天室其他用户的信息,浏览器根据信息来逐个构建与其他用户的点对点连接4,若有用户离开,服务器发送一个用户离开信令(remove_peer),信令中包含离开的用户的信息,浏览器根据信息关闭与离开用户的信息,并作相应的清除操作5,若有新用户加入,服务器发送一个用户加入信令(new_peer),信令中包含新加入的用户信息,浏览器根据信息来建立与这个新用户的点对点连接;6,用户离开页面,关闭WebSocket连接 服务器端实现由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了WebSocket的连接：由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。 同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）: 参考 使用WebRTC搭建前端视频聊天室——入门篇 使用WebRTC搭建前端视频聊天室——信令篇 使用WebRTC搭建前端视频聊天室——点对点通信篇 使用WebRTC搭建前端视频聊天室——数据通道篇 使用 WebRTC 构建简单的前端视频通讯 直播和截图]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组减去另一数组(数组的每一项都是一个对象)]]></title>
    <url>%2F2017%2F10%2F21%2F2017-10-21-%E6%95%B0%E7%BB%84%E5%87%8F%E5%8E%BB%E5%8F%A6%E4%B8%80%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[做聊天项目的时候遇要实现这样的一个功能: 邀请新的好友入群;点击邀请好友会弹出一个好友列表,显示你除了在群里面的好友外剩下的所有好友;我的思路是取到你所有的好友,然后所有好友中过滤掉已经是群成员的好友 123456789101112131415161718192021222324const users = [ &#123; _id: 1, name: '好友1' &#125;, &#123; _id: 2, name: '好友1' &#125;, &#123; _id: 3, name: '好友1' &#125;,];const groupMembers = [ &#123; _id: 1, name: '好友1' &#125;, &#123; _id: 2, name: '好友1' &#125;,] 现在一步一步来看数组的操作 一,两个数组里的每一项分别为元素时12345const arr1 = ['', '100', '120', '125', '125', '130', '130'];const arr2 = ['', '120', '125', '125', '130'];请问如何求得两个数组之差？使得新数组为 arr3 = ['100','130'] 方法一:思路:用for循环比较arr1和arr2的每一项,如果相等,就删除1234567891011121314151617const arr1 = ['', '120', '125', '125', '130', '130', '130', '130', '130'];const arr2 = ['', '120', '125', '130'];for (let i = arr1.length - 1; i &gt;= 0; i--) &#123; a = arr1[i]; for (let j = arr2.length - 1; j &gt;= 0; j--) &#123; b = arr2[j]; if (a == b) &#123; arr1.splice(i, 1); arr2.splice(j, 1); break; &#125; &#125;&#125;console.log(arr1); // ['125','130','130','130','130'] 方法二:思路:将第一个数组存入一个对象，这样就已经去重了；再把第二个数组中的元素当作key从对象中删除。1234const m = &#123;&#125;;arr1.forEach(function(al)&#123;m[al]=al;&#125;)arr2.forEach(function(bl)&#123;delete m[bl];&#125;)console.dir(Object.keys(m)) 方法三:思路:声明一个新的数组arr3,比较arr1和arr2,如果arr1中有和arr2不相等的就放入arr3中,用到了es6中关于数组的新方法findIndex(),稍后会详细的介绍;123456789const arr1 = ['', '100', '120', '125', '125', '130', '130'];const arr2 = ['', '120', '125', '125', '130'];const arr3 = [];arr1.forEach((a)=&gt;&#123; let c = arr2.findIndex(b =&gt;a === b); if (c &gt; -1) delete arr2[c]; else arr3.push(a);&#125;);console.log(arr3) //['100', '130'] 二, arr1中的每一项都是对象,arr2中的每一项都是元素12const a = [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;];const b = [15, 3]; 方法一123a.filter(item =&gt; &#123; return !b.includes(item.id); &#125;);或a.filter(item =&gt; &#123; return b.indexOf(item.id) === -1; &#125;); 方法二:1a=a.filter((x)=&gt;b.every((y)=&gt;y!=x.id)) 方法三:1234567891011const a = [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;];const b = [15, 3];for(index in a)&#123; if(b.indexOf(a[index]['id'])&gt;=0) a.splice(index,1);&#125;console.log(a);或const result = a.filter(function (item) &#123; return b.indexOf(item.id) &lt; 0; &#125;) 三,arr1中的每一项都是对象,arr2中的每一项也都是对象,现在回到主题123456789const a = [ &#123;_id: 1&#125;, &#123;_id: 2&#125;, &#123;_id: 3&#125;,];const b = [ &#123;_id: 2&#125;, &#123;_id: 4&#125;,] 解决方法一:1const c = a.filter(x =&gt; !b.find(y =&gt; y._id === x._id)); // [ &#123; _id: 1 &#125;, &#123; _id: 3&#125; ] 解决方法二:1const c = a.filter(x =&gt; b.every(y =&gt; y._id !== x._id)); 四,介绍一下上面用到的数组实例中的find(), findIndex(), includes()find()find()用于找出第一个符合条件的数组成员,它的参数是一个回调函数,所有的数组成员依次执行该回调函数,直到找到第一个返回值为true的成员,然后返回该成员,如果没有的话,返回undefined12[0, 4, -5, -10].find((n) =&gt; n &lt; 0);// -5 上面代码找出数组中第一个小于0的成员1234[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 find方法的回调函数可以接受三个参数,当前的值,当前的位置和原数组 findIndex()findIndex()方法的用法与find()方法类似,返回第一个符合条件的数组成员的位置,如果所有成员都不符合,则返回-1.1234[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 两个方法都可以发现NAN,弥补了数组的indexOf方法的不足12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 indexOf方法无法识别数组的NaN成员,但是findIndex方法可以借助Object.is方法做到 includes()Array.prototype.includes方法返回一个布尔值,表达某个数组是否包含给定的值,与字符串的includes方法类似 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置,默认为0,如果第二个参数为负数,表示倒数的位置;如果这是它大于数组长度(比如第二个参数为-4.但是数组长度为3),则会重置为从0开始12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前,我们通常使用数组的indexOf方法,检查是否包含某个值123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点,一是不够语义化.它的含义是找到参数值的第一个出现位置.所以要去比较是否不等于-1,而是,它内部使用严格相等运算符(===)进行判断,这会导致对NaN的误判12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。12[NaN].includes(NaN)// true 参考 数组减去另一个数组 js 根据一个数组元素，删除另一个数组中的对象 ECMAScript6入门之数组的拓展]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB]]></title>
    <url>%2F2017%2F10%2F14%2F2017-10-14-mongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB是一个通用的非关系型数据库;把文档存在集合中;它们不需要相同的schema,每个文档都可以有不同的schemaMongoose是一个Node模块;Mongoose的基础知识如下: 打开或关闭MongoDB连接; 注册schema; 添加任务; 搜索文档 更新文档 删除文档首先可以用npm 命令安装Mongoose; 1npm install mongoose 1,连接的打开和关闭装好Mongoose,启动MongoDB服务器,用下面的代码建立到MongoDBd的连接,在下面的例子中是一个叫tasks的数据库12const mongoose = require(' mongoose');const db = mongoose.connect(' mongodb:// localhost/ tasks'); 如果要终止MongoDB创建的连接,1mongoose.disconnect(); 2,注册schema在用MongoDB管理数据时,需要注册schema123456const Schema = mongoose.Schema;const Tasks = new Schema(&#123; project: String, description: String &#125;);mongoose.model(' Task', Tasks); Mongoose的schema很强大.除了定义数据结构,还可以设定默认值,处理输入,以及加强校验 3,添加任务schema注册好后,你可以访问它,让Mongoose去工作,下面的代码用模型添加了一项任务12345678const Task = mongoose. model(' Task');const task = new Task();task.project = 'Bikeshed';task.description = 'Paint the bikeshed red.';task.save( function( err) &#123; if (err) throw err; console.log(' Task saved.');&#125;); 4,搜索文档Task模型的find方法可以用来查找所有文档,或者用一个JavaScript对象指明一个过滤标准来选择特定的文.下面这段代码搜索跟特定项目相关的任务,并输出每项任务的唯一ID和描述1234567const Task = mongoose.model(' Task');Task.find(&#123;' project': 'Bikeshed'&#125;, function( err, tasks) &#123; for (const i = 0; i &lt; tasks.length; i++) &#123; console.log(' ID:' + tasks[ i]._ id); console.log( tasks[ i]. description); &#125;&#125;); 5,更新文档尽管用模型的find方法可以定位一个文档,然后修改并保存它,但Mongoose还有一个update方法专门来做这个.下面的代码用Mongoose更新了一个新的文档 12345678910const Task = mongoose. model(' Task');Task.update( &#123;_id: '4e65b793d0cf5ca508000001'&#125;, // 用 内部 ID 更新 &#123;description: 'Paint the bikeshed green.'&#125;, &#123;multi: false&#125;, //只 更新 一个 文档 function( err, rows_ updated) &#123; if (err) throw err; console.log(' Updated.'); &#125;); 6,删除文档在Mongoose中,一旦你取到了文档,要删除它很容易.你可以用文档的内部ID(或其他任何条件,如果你用find代替finById的话)获取和删除文档,代码就像下面弄这样1234const Task = mongoose.model(' Task');Task.findById(' 4e65b3dce1592f7d08000001', function( err, task)&#123; task. remove();&#125;); 友情链接 robomongo下载]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F10%2F12%2F2017-10-12-git%2F</url>
    <content type="text"><![CDATA[1,工作区,暂存区,本地仓库,远程仓库 2,git 添加远程仓库地址/拉项目/推项目1234567891011git remote add mayun https://git.oschina.net/fenmiaojinrong/fmjr.gitgit branch --set-upstream master mayun/mastergit pullgit add .git commit -m&quot;解决冲突&quot;git push 3,git -版本回退本地回退版本1git reset &lt;the-hash&gt; 远程回退版本12git push --force &lt;remote&gt; &lt;the-hash&gt;:&lt;the remote branch&gt; rebase1git rebase -i &lt;the-hash&gt; 清空本地改动1git clean -fd 取消应该被跟踪的改动12git rm --cached &lt;file&gt; 临时取消工作区指定文件改动123git update-index --assume-unchanged &lt;file&gt; git update-index --no-assume-unchanged &lt;file&gt; 4,在master上建了一个分支next,但是master上有改动,需要next主动去合并master分支1next merge master 5,git -远程仓库法人删除和重命名在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成paul，可以这么运行：1234$ git remote rename pb paul$ git remoteoriginpaul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master分支现在成了paul/master。 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令123$ git remote rm paul$ git remoteorigin git -拉取远程分支1git checkout --track remotes/origin/react 6,友情链接 windows上Git下载 progit]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年国庆节-杭州&&上海]]></title>
    <url>%2F2017%2F10%2F09%2F2017-10-09-%E5%9B%BD%E5%BA%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[10.01~10.02 coding at home今年的国庆节和中秋节一共八天假,期待了很久的假期;前两天自己在家写了两天代码,研究了一下项目用meteor和react结合做全栈; 10.03 浙大 + 将军山 5点起床,打车去首都机场,前往杭州,打印登机牌,办理行李托运,最后安检的时候被扣下了一瓶海飞丝,(规定是不允许带超过100ml的液体,哎,也是第一次做飞机,平常去的地方都特别近),大概在天上飞了两个半小时,飞机上的风景很美很美,看到了蓝天白云,上午10点左右,到达杭州,跟在天上看到的完全是两个样子,没有蓝天白云. 查找路线,坐公交去定好的酒店,杭州的公交支持支付宝直接付款,这个真的很方便,不用直接去换零钱; 在酒店里休息了一下就开始规划这几天在杭州的路线,浙大就在酒店的附近,就骑着车子去了,杭州的路比北京的要宽很多,路两边的树很多,而且树长的都很大; 浙大玉泉校区 将军山 10.04 西湖 + 杭州海底世界 + 京杭运河来杭州当然一定要去看一下西湖,于是就骑着车子去西湖了,人特别的多, 晚上,游京杭运河,夜景真的很美很美,杭州真的很会使用灯光搭配;武林门码头坐游船,差不多一百元一位,白天有水上的公交,才三元,所以你可以晚上早点去,然后做最后一班公交,这样即会节省一部分开支,又可以看到晚上的夜景 10.05 西溪 + 断桥 大概断桥就是被人压断的吧,O(∩_∩)O哈哈~ 10.06 东方明珠 + 上海世贸大厦最高观光厅 10.07 上海迪士尼迪士尼人真的太多了,基本玩一个项目都得等一个多小时,所以去玩的时候一定要提前做好攻略;(看过欢乐颂2的大概都知道,里面有一个特别浪漫的情节就是在迪士尼拍的,但是电视剧毕竟是电视,看看就好,✧(≖ ◡ ≖✿)嘿嘿,真实的情况你懂得) 10.08 回北京]]></content>
      <categories>
        <category>life</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现toolTip]]></title>
    <url>%2F2017%2F09%2F27%2F2017-09-27-css%E5%AE%9E%E7%8E%B0toolTip%2F</url>
    <content type="text"><![CDATA[1,常用border来实现三角形 原理: 宽高都不设置(即为0),只设置边框,如果4个边框都设置宽度(border-width),样式(border-style)和颜色(border-color)12345678.test &#123; width:0; height: 0; border-top: 100px solid red ; border-bottom: 100px solid blue; border-left: 100px solid green; border-right: 100px solid yellow;&#125; 效果如图 上面看到的都是三角形,其实想实现单个三角形只需把其他三个三角形的border-color设置为透明色就可以了这样就实现了三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;各种三角形&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; margin-top: 50px; &#125; .triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; &#125; .triangle-down &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; &#125; .triangle-left &#123; width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-right &#123; width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-topleft &#123; width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-topright &#123; width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; &#125; .triangle-bottomleft &#123; width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-bottomright &#123; width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li class="triangle-up"&gt;&lt;/li&gt; &lt;li class="triangle-down"&gt;&lt;/li&gt; &lt;li class="triangle-left"&gt;&lt;/li&gt; &lt;li class="triangle-right"&gt;&lt;/li&gt; &lt;li class="triangle-topleft"&gt;&lt;/li&gt; &lt;li class="triangle-topright"&gt;&lt;/li&gt; &lt;li class="triangle-bottomleft"&gt;&lt;/li&gt; &lt;li class="triangle-bottomright"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2,css实现toolTip(实心三角箭头)原理: 一个三角形绝对定位到主体元素边界处并连接起来 把三角形的颜色换成和主体元素一致的背景色就可以123456789101112131415161718.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC;&#125; 3,css实现toolTip(空心三角箭头)源码如下原理: 一个边框颜色的三角形绝对定位到主体元素边界处并连接起来 另一个主体元素背景色的三角形绝对定位并覆盖到第一个三角形上面 第二个三角形相较于第一个三角形定位上偏移距离应等于边框厚度1234567891011121314151617181920212223242526272829.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; border: 6px solid blue; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid blue;&#125;.test:after&#123; content: ''; display: block; position: absolute; bottom: -14px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 1000px; margin: 0 auto; &#125; /* 向下 */ .toolTip-bottom &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-bottom:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC; &#125; .toolTip-bottom:after&#123; content: ''; display: block; position: absolute; bottom: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff; &#125; /* 向上 */ .toolTip-top &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-top:before&#123; content: ''; display: block; position: absolute; top: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-bottom: 20px solid #A5C4EC; &#125; .toolTip-top:after&#123; content: ''; display: block; position: absolute; top: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #fff; &#125; /* 向左 */ .toolTip-left &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-left:before &#123; content: ''; display: block; position: absolute; left: -20px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #A5C4EC; &#125; .toolTip-left:after &#123; content: ''; display: block; position: absolute; left: -18px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #fff; &#125; /* 向右 */ .toolTip-right &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-right:before &#123; content: ''; display: block; position: absolute; right: -20px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #A5C4EC; &#125; .toolTip-right:after &#123; content: ''; display: block; position: absolute; right: -18px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="toolTip-bottom"&gt;&lt;/div&gt; &lt;div class="toolTip-top"&gt;&lt;/div&gt; &lt;div class="toolTip-left"&gt;&lt;/div&gt; &lt;div class="toolTip-right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下 参考 aboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下运行Rocket.chat]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-Mac%E4%B8%8B%E8%BF%90%E8%A1%8CRocket-chat%2F</url>
    <content type="text"><![CDATA[1,简介 github Rocket.chat是特性最丰富的Slack开源替代品之一 主要功能：群组聊天，直接通信，私聊群，桌面通知，媒体嵌入，文件上传，语音/视频聊天，截图等等 Rocket.chat原生支持windows,Mac OSX, Linux, ios和Android平台 2，准备工作由于Rocket.chat使用的是Meteor框架，而Meteor框架是对Node.js的封装，源码中又使用到了CoffeeScript.js,使用数据库是MongDB，所以在Rocker.chat上做二次开发，需要学习的技术有Meteor, Node.js, CoffeeScript.js,MongDB； 其他资料 CoffeeScipt中文网 Meteor中文网 Rocket.chat要运行，必须安装Node.js,NPM,Meteor(包含了Mongdb)node和npm的安装大家肯定特别熟悉，下面说一下meteor的安装过程 3,安装meteor1curl https://install.meteor.com/ | sh 创建一个小工程的指令，123meteor create meteorAppcd meteorAppmeteor 在浏览器中输入：http://localhost:3000/ 4,下载和运行Rocket.chat下载Rocet.chat最好使用git 的命令1git clone git clone https://github.com/RocketChat/Rocket.Chat.git 等工程源码下载完毕后，进入对应的文件夹，然后运行12cd Rocket.Chatnpm start 在执行npm start的过程中，需要注意一下问题，否则可能会启动不了 1,运行会特别慢,建议加上修改源为淘宝源，具体方法如下参考： 1npm config set registry https://registry.npm.taobao.org 2,运行过程需要翻墙，因为国外的npm包在国内下载可能就被墙了 我在安装的过程中出现报错： 找了phantomjs镜像单独安装了一下速度很快，就成功了,😊,然后把phantomjs添加到环境变量(方法如下)12345671,cd phantomjs2,cd bin3,pwd //注: 需要输出的复制地址4,cd ~ // 回到根目录5,vim .zshrc6,添加到path7,source .zshrc // 保存修改 运行成功命令行如下 运行成功浏览器中如下 参考 如果运行中出现其他的问题欢迎与我交流aboutmegithubblog]]></content>
      <categories>
        <category>meteor</category>
        <category>Rocket.chat</category>
      </categories>
      <tags>
        <tag>meteor</tag>
        <tag>Rocket.chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由history vs hash]]></title>
    <url>%2F2017%2F09%2F10%2F2017-09-10-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1history-vs-hash%2F</url>
    <content type="text"><![CDATA[history路由机制用户访问网页的历史记录通常会被保存在一个类似栈对象中,即history对象,点击返回就出栈,跳下一页就入栈.它提供了一些方法来操作页面的前进和后退: window.history.back()返回到上一个页面 window.history.forward()进入到下一个页面 window.history.go([delta])跳转到指定页面HTML5对history Api进行了增强,新增了两个Api和一个事件,分别为pushState,replaceState和onpopstatepushState是往history对象里添加一个新的历史记录,即压栈replaceState是替换history对象中的当前历史;这两个API相同之处都会操作浏览器的历史记录,而不会引起页面的刷新;不同之处在于,pushState会增加一条新的历史记录,而replaceState则会替换当前的历史记录当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件,与其类似的还有一个事件:onhashchange hash路由机制我们经常在url中看到#,这个#有两个情况,一个是我们所谓的锚点,比如典型的回到顶部按钮原理,github上各个标题之间的跳转等,路由里的#不叫锚点,我们称之为hash,大型框架的路由系统大多都是哈希实现的onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 hashhistory与browserhistory 使用 hashHistory，浏览器上看到的 url 会是这样的: /#/user/haishanh?_k=adseis 使用 browserHistory，浏览器上看到的 url 会是这样的：/user/haishanh 看起来当然browerHistory很好很理想,但browweHistory需要server端支持,而使用hashHistory的时候，因为 url 中 # 符号的存在，从 /#/ 到 /#/user/haishanh 浏览器并不会去发送一次 request，react-router 自己根据 url 去 render 相应的模块。 而使用 browserHistory 的时候，浏览器从 / 到 /user/haishanh 是会向 server 发送 request 的。所以 server 端是要做特殊配置的。比如用的 express 的话，你需要 handle 所有的路由 app.get(‘*’, (req, res) =&gt; { … })，使用了 nginx 的话，nginx也要做相应的配置。所以你的 App 是静态，没有服务端的话，只能用 hashHistory。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心塞！又一次被自己蠢哭]]></title>
    <url>%2F2017%2F09%2F08%2F2017-09-08-%E8%A2%AB%E9%AA%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很晚了，但是今天就是睡不着，想把今天发生在我身上的事情总结一下，看完之后肯定会觉得我很傻很笨，这一次我将不会再为自己辩解；承认自己被骗是一个很痛苦的事情，不知道谁能体会到； 我发现我真的好笨，这次被骗很难过，并不仅仅是骗了200块钱，而是她还欺骗了我的感情，我那么相信她，跟她聊了好多实话，很多人跟我说过不要太容易去相信别人，我爸妈，还有很多朋友都这么跟我说，我很不愿意接受现实生活中哪有那么多坏人，每次都会反驳一句：你们不要老把别人想得那么坏。。。所以就有了之后的一次又一次被骗，之前碰到乞丐都会给一些钱，还有路边说钱包被偷的没钱吃饭的，借钱回家的，还有1700多买了个酷派合约机，一个月话费120(当时都没工作，那来那么多钱交话费)甚至还有骗你拿自己身份证办银行卡的，很多很多，经历了那么多被骗，以为自己现在成熟很多了， 这次美容院被骗事件，我真的是不知道怎么办，只是问个路，然后那个人就拐着你的胳膊就说我领你去，当时还特庆幸自己遇到一个特别好的人，结果就把我领到店里了，我真的很生气，当时准备扭头就走，可是接下来发生的事就像下面百度到的这些美容院骗术发生的一模一样； //jingyan.baidu.com/article/a17d52855420a78098c8f2f9.html 让脸上抹了一些膏状液体，拿着电疗忆，过一会就变成了黑色(（PS 涂的东西是一种重金属测试膏，百度“美容院用重金属测试膏欺诈顾客”，可以看到相关新闻报道，据说这是十年前就有的骗局。。）)，说是原价700多的现在因为4周年店庆，300多，最后一天，我坚持不做，想走，她死活不让我走，说现在不能走，出去就会感染，过敏，皮囊炎，毁容。。。。(正常人听到这些多少都会还害怕吧，不过现在想想她说怎样就会怎么样么，20多年了，皮肤就这样，很多人一辈子没去去过美容院，也没见自己长着长着毁容的)说你现在不能走，她要对你负责，怎么办，她又说这样吧，给你个学生特惠的190，然后你下次来体验一把全脸的，我意识到这是不掏钱不让走的节奏啊，而且他们人多，我自己，又不敢怎么，但是又不愿相信自己被骗了，还是愿意相信那个人所说的，还傻乎乎的打算有空来体验一把（被自己蠢哭）。 百度完之后，终于意识到自己真的是被骗了，看着百度搜索出来的美容院骗局，解析街边美容院骗局；很多评论都是2017年的。老掉牙的骗局，现在我还被骗，哎，不过看到他们比我骗得钱多，而且很多人都被骗过，心里平衡了很多（明明知道这是一种很不好的心里活动，就当是安慰自己吧） 真的很希望骗子你们不要再找我了，骗我就是一骗一个准，突然想到，自己能安全活这么大还是很不容易的，所以身边的你们要好好珍惜 很渴望骗子能少一些，人与人之前多一点真诚。这样当真正有需要帮助的人需要帮助的时候，大家才不会那么冷漠。希望那些骗子们不要再玩心理战了，这样真的很可恶，不仅骗钱，还骗感情。]]></content>
      <categories>
        <category>life</category>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用vue,你知道 keep-alive 么]]></title>
    <url>%2F2017%2F09%2F06%2F2017-09-06-vue%E7%BB%84%E4%BB%B6%E4%B9%8Bkeep-alive%2F</url>
    <content type="text"><![CDATA[项目中写vue也没注意到&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件,最近在深入的研究vue组件的生命周期函数,每一个函数都是干嘛的,然后其中有activated和deactivated这两个函数与&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件有关 activated: keep-alive组件激活时调用 deactivated: keep-alive组件停用时调用keep-alive用法 &lt;keep-alive&gt;包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 &lt;keep-alive&gt;是一个抽象组件:它自身不会渲染一个DOM元素,也不会出现在父组件链中 当组件在&lt;keep-alive&gt;内被切换,它的activated和deactivated这两个生命周期钩子函数将会被对应执行具体的实例如下 是一个简单的tab切换,可以尝试把&lt;keep-alive&gt;去掉之后,对比一下,然后就会发现它的好处 test.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class="test"&gt; &lt;div class="testNav"&gt; &lt;div :class="&#123;'selected':tab === 1,'testTitle':true&#125;" @click="toTab(1)"&gt;标题一&lt;/div&gt; &lt;div :class="&#123;'selected':tab === 2,'testTitle':true&#125;" @click="toTab(2)"&gt;标题二&lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;keep-alive&gt; &lt;Test1 v-if="tab === 1"&gt; &lt;/Test1&gt; &lt;Test2 v-else&gt; &lt;/Test2&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test1 from './test1.vue'; import Test2 from './test2.vue'; export default &#123; data() &#123; return &#123; tab: 1, &#125;; &#125;, components: &#123; Test1, Test2, &#125;, methods: &#123; toTab(index) &#123; this.tab = index; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123; width: 100%; .testNav &#123; height: 60px; line-height: 60px; display: flex; border-bottom: 1px solid #e5e5e5; .testTitle &#123; flex: 1; text-align: center; &#125; .selected &#123; color: red; &#125; &#125;&#125;&lt;/style&gt; 测试结果如下:注意看一下页面和控制台输出的信息,可以更加直观的注意到&lt;keep-alive&gt;的作用及activated和deactivated这两个函数什么时候会被触发 打开页面,会出现下面这样 用setTimeout模拟请求后端接口的场景 点击title2,出现下面的情况 再次点击title1,出现下面的情况,你会发现从后端请求的数据会快速显示出来,但是如果你此时不用,会重新请求数据,你可以尝试一下 test1.vue和test2.vue的相关代码如下: test1.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class="test1"&gt; test1 &#123;&#123;testInfo1&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo1: '', &#125;; &#125;, activated() &#123; console.log('测试1被激活'); &#125;, deactivated() &#123; console.log('测试1被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo1 = '这是测试一的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; test2.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; test2 &#123;&#123;testInfo2&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo2: '', &#125; &#125;, activated() &#123; console.log('测试2被激活'); &#125;, deactivated() &#123; console.log('测试2被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo2 = '这是测试二的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2017%2F09%2F06%2F2017-09-06-flex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[使用flex布局flex使用方法很简单,只需要将其display属性设置为flex即可,也可以设置行内的flex,记得webkit内核的浏览器,必须加上-webkit, 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。123456.ele &#123; display: -webkit-flex; diaplay: flex; display: inline-flex; display: -webkit-inline-flex;&#125; 在flex中,最核心的概念就是容器和轴,其中容器分为父容器和子容器,轴分为主轴和交叉轴(主轴默认为水平方向,方向向右,交叉轴为主轴顺时针旋转90度) 父容器属性父容器有六个属性 1,flex-direction: 主轴方向. 2,flex-wrap: 超出父容器子容器的排列方式 3,flex-flow: flex-direction属性和flex-wrap属性的简写方式 4,justify-content: 子容器在主轴的排列方向 5,align-items: 子容器的交叉轴上的排列方式 6,align-content: 多根轴线的对齐方式 flex-direciton属性flex-direction属性决定主轴的方向(主轴的方向不一定是水平的,这个属性就是设置主轴的方向,主轴默认是水平方向,从左至右)123456.box &#123; flex-direction: row; // 默认值,主轴为水平方向,起点在左端,从左到右 flex-direction: row-reverse; // 主轴为水平方向,起点在右端,从右到左 flex-direction: column; // 主轴为垂直方向,起点在上端,从上到下 flex-direction: column; // 主轴为垂直方向,起点在下端,从下到上&#125; flex-wrap属性flex-wrap属性决定自容器如果在一条轴线排不下时,如何换行12345.box &#123; flex-wrap: nowrap; // 默认,不换行 flex-wrap: wrap; // 换行,第一行在下面 flex-wrap: column; // 换行,第一行在=上面&#125; 子容器也有6个属性 1,order: 子容器的排列顺序 2,flex-grow: 子容器剩余空间的拉伸比例 3,flex-shrink: 子容器超出空间的压缩比例 4,flex-basis: 子容器不伸缩情况下的原始尺寸 5,flex: 子元素的flex属性是flex-grow, flex-shrink, flex-basis的简写 6,align-self: 允许单个子容器与其他字容器不一样的对齐方式,可覆盖父元素aligns-items属性(交叉轴),默认是auto,表示继承父元素的align-items属性,如果没有付元素,则等同于strech order属性order属性定义子容器的排列顺序,数值越小,排列越靠前123item &#123; order: &lt;interger&gt;&#125; flex-grow属性flex-grow属性定义子容器的放大比例,默认为0123item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果子容器的flex-grow属性都为1,则他们将等分剩余空间(如果有的话).如果一个项目的flex-grow属性为2,其他项目都为1,则前者占据的剩余空间将比其他项多一倍; flex-shrink属性flex-shrink定义了子容器的缩小比例,默认为1,如果空间不足,该项目将缩小123item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有子容器的flex-shrink属性都为1,当空间不足时,都将等比例缩小.如果一个项目的flex-shrink的属性为0,其他项目都为1,则空间不足时,前者不缩小;负值对该属性无效 flex-basis属性flex-basis属性定义了在分配多余空间之前,项目占据了主轴空间,浏览器根据这个属性,计算主轴是否有多余空间.它的默认值为auto,即项目的本来大小;123item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设置跟width和height属性一样的值(比如350px),则项目将占据固定空间 flex属性flex是flex-grow,flex-shrink,flex-basis的缩写,默认值为0 1 auto。后两个属性可选123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; align-self属性align-self属性允许单个子容器有与其他子容器不一样的对齐方式，可覆盖align-items属性，默认为auto,表示继承父元素align-items属性，如果没有父元素，则等同于stretch123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto,其他都与align-items属性完全一致。 参考]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除css默认样式的总结]]></title>
    <url>%2F2017%2F09%2F06%2F2017-09-06-css%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[我们写css的时候经常会遇到要清楚一些默认的样式,其实每次做项目中需要清除的样式就经常是那么几个,最常见的比如 清除表单元素input,select,textarea`的默认样式, CSS3中隐藏滚动条但仍能继续滚动, 多行文本溢出省略号显示等等, 所以就总结了一下,持续更新中…,也请大家多多贡献更多的常见的需要清除默认样式的方法😊 1,多行文本溢出省略号显示 让文本只显示一行，然后溢出省略号显示 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 让文本显示两行，然后溢出部分省略号显示12345line-height: 1.3rem;max-height: 2.6rem;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; 2，CSS3中隐藏滚动条但仍能继续滚动1234::-webkit-scrollbar &#123; width: 0px; height: 0px;&#125; 3, 解决iPhone中overflow:scroll;滑动速度慢或者卡的问题1-webkit-overflow-scrolling : touch; 4,消除input,textarea等的默认样式123456789input, button, select, textarea &#123; outline: none; -webkit-appearance: none; border-radius: 0; border:0;&#125;textarea&#123; resize:none;&#125; outline: none;去掉chrome浏览器自带的点击input框出现边框情况 -webkit-appearance: button;使元素标签看起来像个按钮样式,意思定义了按钮样式-webkit-appearance: none;去掉按钮样式 border-radius: 0; 去掉圆角border:0; 去掉border textarea{resize:none}取消chrome下textarea可拖动放大：Aboutaboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结微信小程序开发中遇到的坑]]></title>
    <url>%2F2017%2F09%2F01%2F2017-09-01-wxapp%2F</url>
    <content type="text"><![CDATA[总结微信小程序开发中遇到的坑,一些坑你得一个一个的跳啊,/(ㄒoㄒ)/~~ 1,页面跳转和参数传递实例 首先说一下我遇到的需求有一个我的消息页面,里面的数据都是后端返回的,返回的数据大致如下,有一个是数据url是要控制跳转到哪个页面,可能是tab页面也可能是非tab页面,但是微信小程序中跳转到tab和非tab页面用的api不是同一个,但是在页面中渲染肯定是要用到循环的,难道要再多个参数来判断是跳转到tab页面还是非tab页面? 1234567891011121314151617[ &#123; "id": 2121, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;, &#123; "id": 2122, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;,] 后一般的小程序中我用的框架是wepy,底部的tab组件就是我自己写的,没有用到小程序自己提供的那一个,因为我们还要实现一个需求,有消息时,底部tab会出现小红点,还有以下弹窗要把底部tab覆盖掉,这些需求如果用小程序提供的那一个tab组件的话根本实现不了;而且不用wepy框架的话,自己做一个tab实现的过程很恶心,小程序虽然实现了组件化,但是它实现的组件化bong不想vue和react那样实现的是真正的组件化,你需要哪个组件就直接import进来,小程序的组件化实现可查看官方文档,js,css和html都是要分别引入的 自己实现的tab页面整体是一个非tab页面,所有整个小程序中就不存在绝对的tab页面,所以用navigator这个组件,想要跳转到tab页面可以通过在url上拼接参数 123456&lt;view class="mesList" wx:for="&#123;&#123;unReadList&#125;&#125;" wx:key="unique"&gt; &lt;navigator url="/pages/index?tab=0" hover-class="none" &gt; &lt;text&gt;&#123;&#123;item.body&#125;&#125;&lt;/text&gt; &lt;view class="messageTime"&gt;&#123;&#123;item.created_at&#125;&#125;&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 然后再index页面的onload中判断显示哪个tab123456onLoad(options) &#123; if (options &amp;&amp; options.tab) &#123; this.tab = parseInt(options.tab); this.$apply(); &#125;&#125; 2,微信小程序授权处理 微信小程序提示授权弹窗,如果用户第一次点击拒绝之后,一段时间将不会再次弹出来,然后用户又不知道什么原因用不了小程序,这是个很糟糕的用户体验,我们应该优雅的处理这种情况 采用的解决方法参考 3, 登录问题的处理 两个登录接口,一个get,判断是否已经还需要登录,如果返回true,则需要登录,如果返回false,则不需要登录 如果返回true,则需要去请求更一个post的登录接口,这时,你需要获取第一个get请求的返回信息中的session,之后每次请求求都需要带上他 在返回true的时候还需要做一件事儿,就是把返回信息中的session存储到storage,即调用setStorage,然后在之后每次请求数据的时候在headers里加上这个字段1234567891011121314151617181920212223242526272829function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); &#125;, &#125;); &#125;);&#125;function setStorage(key, value) &#123; return new Promise(function (resolve, reject) &#123; wx.setStorage(&#123; key: key, data: value, success: function (res) &#123; // TODO: 不知道返回什么 resolve(res.data); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 4,wx.getStorage安卓手机上返回的错误信息是getStorage:fail,ios,getStorage:fail data not found 在判断一些api返回的错误信息时,最好不要通过判断具体的错误信息来处理错误12345678910111213141516171819202122function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); // 下面注释的部分即为刚开始犯的错误,导致有可能ios或安卓或部分机型显示不出数据 // if (res.errMsg == 'getStorage:fail' || res.errMsg == 'getStorage:fail data not found') &#123; // console.log('没有cookie'); // resolve(null); // &#125; else &#123; // console.log('这是一个问题'); // reject(res.errMsg); // &#125; &#125;, &#125;); &#125;);&#125; 5,小程序解决异步 如果项目中没有用到babal,小程序本身的支持只支持到es6的语法,所以解决异步的问题就不能使用es7的async和await,只能使用promise来解决异步,但是每个api上都进行一次封装(如下),这种做法太恶心了 123456789101112function login() &#123; return new Promise(function (resolve, reject) &#123; wx.login(&#123; success: function (res) &#123; resolve(res); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 基于微信的API的prototype上进行了promise的封装 123456789101112131415function promiseify(func) &#123; return (args = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; func.call(wx, Object.assign(args, &#123; success: resolve, fail: reject, &#125;)); &#125;) &#125;&#125;for (const key in wx) &#123; if (Object.prototype.hasOwnProperty.call(wx, key) &amp;&amp; typeof wx[key] === 'function') &#123; wx[`_$&#123;key&#125;`] = promiseify(wx[key]); &#125;&#125; 6,怎么保证在调用其他接口之前已经调用过登录的接口了 我采用执行队列的方式来解决,问题可以简化为有两个按钮,点击第一个按钮输出这是第几次输出d1,但是必须在点击完d2之后,isPrint变为true时,才允许输出,在isPrint为false的时候点击d1,需要把要输出的内容暂时存储起来,等isPrint变为true时,暂存起来的输出现在才可以输出出来12345678910111213141516171819202122232425262728293031323334// html &lt;div class="first"&gt;按钮一&lt;/div&gt; &lt;div class="second"&gt;按钮二&lt;/div&gt;// js const d1 = document.querySelector('.first'); const d2 = document.querySelector('.second'); let count = 0; // 用来记录第几次输出 let isPrint = false; // 是否允许输出 let arr = []; // 声明一个数组,用来存储 function clickCount() &#123; count++; console.log('这是第' + count + '次输出d1'); &#125; d1.onclick = function () &#123; console.log(isPrint); console.log(arr); if (isPrint) &#123; if (arr.length === 0) &#123; clickCount(); &#125; else &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i](); &#125; &#125; &#125; else &#123; arr.push(clickCount); console.log('不允许输出'); &#125; &#125;; d2.onclick = function () &#123; isPrint = true; console.log(isPrint); &#125; 6,小程序问题 不支持跳转外部链接 text可以解析/n, 目前不支持识别图中二维码， 背景图片不能用本地图片， wx.navigateTo需要跳转的应用内非 tabBar 的页面的路径 wx.switchTab跳转到tabBar页面， wx.showToast(),icon只支持success和loading,但是支持image,且image优先级高于icon tabBar页面A navigatorTo 到页面B，然后B switchTab 到A，这里A会执行onShow()；但是我再从A跳到B再switchTab回来，A就不会再执行onShow()了， 7,总结 有时候在开发者工具上测试时是没有问题的,但是真机测试却有问题,所有开发过程中一定要在多个不同型号的手机上测试;很多时候IOS和安卓api返回的信息不同 在手机上打开调试的时候是好的,但是关闭调试后就会出现各种bug,遇到这种情况一定要一步步的去排查原因 8,后采用wepy重构小程序遇到的一些坑wepy文档1，Q: 怎么在page组件和component组件中回去到getApp(),就是app里面定义的函数,通过this.$parent只能拿到数据，拿不到方法?A:可以在this.$parent的_proto上拿到方法,即this.$parent.onLogin2, Q:怎么实现按需加载A:在compoent组件中自定义生命周期函数,并手动触发]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期详解]]></title>
    <url>%2F2017%2F08%2F29%2F2017-08-29-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vue声明周期,在每个声明周期中都干了些什么? 1, vue的生命周期 beforeCreate: 组件实例刚刚被创建,组件属性计算之前,如data属性 created: 组件实例创建完成,属性已绑定,但是DOM还未完成,$el属性还不存在 beforeMount:模板编译/挂载之前 mounted: 模板编译/挂载之后 beforeUpdate: 组件更新之前 updated: 组件更新之后 activated: for keep-alive,组件被激活时调用 deactivated: for keep-alive,组件被移除时调用 beforeDestroy: 组件销毁前被调用 destoryed: 组件销毁后调用 ps:下面代码可以直接复制出去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; a: 'vuejs', &#125;, beforeCreate: function() &#123; console.log('创建前'); console.log(this.a); console.log(this.$el); &#125;, created: function() &#123; console.log('创建之后'); console.log(this.a); console.log(this.$el); &#125;, beforeMount: function() &#123; console.log('mount之前'); console.log(this.a); console.log(this.$el); &#125;, mounted: function() &#123; console.log('mount之后'); console.log(this.a); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log('更新之前'); console.log(this.a); console.log(this.$el); &#125;, updated: function() &#123; console.log('更新完成'); console.log(this.a); console.log(this.$el); &#125;, beforeDestroy: function() &#123; console.log('组件销毁之前'); console.log(this.a); console.log(this.$el); &#125;, destroyed: function() &#123; console.log('组件销毁之后'); console.log(this.a); console.log(this.$el); &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreated: el和data并未初始化created: 完成data数据的初始化,el没有beforeMount: 完成了el和data初始化mounted: 完成挂载 1打开命令行在命令行中输入vm.a = &apos;change&apos;;查看效果 activated和deactivated这两个生命周期函数涉及到&lt;keep-alive&gt;这个组件,所以想了解这个生命周期函数的可以看一下我的另一篇文章]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2017%2F08%2F29%2F2017-08-29-vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是很重要的一部分,父组件怎么传数据给子组件,子组件怎么传递数据给父组件? 1,父组件给子组件传递数据 vue中使用props向子组件传递数据1): 子组件在props中创建一个属性,用于接收父组件传过来的值2): 父组件中注册子组件3): 在子组件标签中添加子组件props中创建的属性4): 把需要传给子组件的值赋给该属性 2,子组件向父组件传递数据 子组件主要通过事件传递数据给父组件1), 子组件中需要以某种方式,例如点击事件的方法来触发一个自定义事件2),将需要传的值作为$emit的第二个参数,该值将作为实参数传给相应自定义事件的方法3),在父组件中注册子组件并在子组件标签上绑定自定义事件的监听 3,子组件向子组件传递数据 vue找那个没有直接子组件对子组件传参的方法,建议将需要传递数据的在组件,都合并为一个组件,如果一定需要子组件对子组件传参,可以先传到父组件,再传到子组件,为了方便开发,vue推出了一个状态管理工具vuex,可以啃方便的实现组件之间的参数传递 具体的实例代码如下:可以自行参考相关代码在编辑器中尝试 父组件向子组件传递数据 123456789101112131415161718192021222324252627282930313233// 父组件向子组件传递数据&lt;!--msg 是在data中(父组件)定义的变量如果需要从父组件中获取logo的值,就需要使用props['msg'], 如30行在props中添加了元素以后,就不需要在data中(子组件)中再添加变量了--&gt;&lt;template&gt; &lt;div&gt; &lt;child @transferuser="getUser" :msg="msg"&gt;&lt;/child&gt; &lt;p&gt;用户名为:&#123;&#123;user&#125;&#125;(我是子组件传递给父组件的数据)&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child, &#125;, data() &#123; return &#123; user: '', msg: '我是父组件传给子组件的信息', &#125;; &#125;, methods: &#123; getUser(msg) &#123; this.user = msg; console.log(msg); &#125;, &#125;, &#125;;&lt;/script&gt; 子组件向父组件传递数据 12345678910111213141516171819202122232425262728293031323334// 子组件向父组件传递数据&lt;!--1.@ : 是 v-on的简写2.子组件主要通过事件传递数据给父组件3.当input的值发生变化时,将username传递给parent.vue,首先声明了一个setUser,用change事件来调用setUser4.在setUser中,使用了$emit来遍历transferUser事件,并返回this.username,其中transferuser是一个自定义事件,功能类似一个中转,this.username通过这个事件传递给父组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input v-model="username" @change='setUser'&gt;向父组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; username: '测试', &#125;; &#125;, props: &#123; msg: &#123; type: String, &#125;, &#125;, methods: &#123; setUser() &#123; this.$emit('transferuser', this.username); &#125;, &#125;, &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的函数节流]]></title>
    <url>%2F2017%2F08%2F27%2F2017-08-27-js%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是函数节流?为什么要用到函数节流?函数节流可以解决哪写问题? 函数节流 使用场景: (1)对于常见的场景，如网页滚动时，经常会有滚动到哪时做什么样的动画效果，遂要注册onscroll事件，如何减少触发次数，到达优化性能，同时又满足效果要求不卡顿，一个是优化事件内代码，减少代码量，二就是做函数节流。 (2)在前端开发中，有时会为页面绑定resize事件，或者为一个页面元素绑定拖拽事件（其核心就是绑定mousemove），这种事件有一个特点，就是用户不必特地捣乱，他在一个正常的操作中，都有可能在一个短的时间内触发非常多次事件绑定程序。而大家知道，DOM操作时很消耗性能的，这个时候，如果你为这些事件绑定一些操作DOM节点的操作的话，那就会引发大量的计算，在用户看来，页面可能就一时间没有响应，这个页面一下子变卡了变慢了。甚至在IE下，如果你绑定的resize事件进行较多DOM操作，其高频率可能直接就使得浏览器崩溃。原理 定时器，当触发一个事件时，先setTimeout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行 123456789function throttle(method, context) &#123; clearTimeout(method, tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;)&#125;window.onresize = function() &#123; throttle(myFunc);&#125; 1234567891011var throttle = function(fn, delay) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;window.onresize = throttle(myFunc, 100); 12345678910111213141516171819var throttleV2 = function (fn, delay, mustRunDelay) &#123; var timer = null; var t_start; return function() &#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start) &#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context, args); &#125; else &#123; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125; &#125;&#125;window.onresize = throttleV2(myFunc, 50, 100);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js垃圾回收机制]]></title>
    <url>%2F2017%2F08%2F27%2F2017-08-27-js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你了解javascript的垃圾回收机制么? 引用计数此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 标记清除当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个怎样都不想认输的🌹]]></title>
    <url>%2F2017%2F08%2F26%2F2017-08-26-%E4%B8%8D%E6%83%B3%E5%83%8F%E7%94%9F%E6%B4%BB%E4%BD%8E%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[毕业两个月,在北京已待了一年多,我成长了很多,无论技术,还是心理…现在有点开始明白之前为什么一个要晚上十点下班的公司,当时面试技术过了,但是最后却要了一个男生,(最后没被面试上,那个技术面试官还特意打电话说,不是因为你技术不行,而是我们这儿加班很严重,所以综合考虑招了个男同事,让我继续💪); 连续快一个月了,每天晚上一点睡,现在感觉真的身体快吃不消了,昨天上班头疼的已坚持不住,所有跟老大说了一下,晚上八点就早点回去了,电梯里碰到了清洁工阿姨,阿姨会问,吃饭了么,又加班了么,这个点下班真的是太晚了,回去早点休息…(突然想起我妈对我的唠叨) 本来打算晚上回去就睡,躺在床上,突然想起一个解决今天复杂的数据关系的一个思路,于是爬起来打开电脑开始尝试,看了看时间,晚上9点,心里想着最晚11点一定要睡,可是写代码的过程中又遇到很多不会的问题,于是好奇心促使我弄明白我什么… 就这样过了12点…, 一点的时候,实在太困,匆忙把代码传到git上,倒头就睡… 闹钟响了,实在挣不开眼,想着再睡十分钟,一会洗漱一定不墨迹; 10分钟搞定,出门的时候看着天气不对,又赶紧找了把伞,看了一个,好,衣服没穿反,放心的找了辆小黄,骑着飞速跑起来,不好,这两车骑得有点费劲,算了,还是赶紧走吧,有辆车就不错了,路上很堵,堵到一路上都被自行车骑着走,但是心理还是很庆幸自己今天没有做公交车; 到了一个红绿灯路口,看到指挥交通的大爷,等红灯的时候大爷很热情的跟我聊天,说今天要下大雨,问我有没有带雨伞,(有一次因为胃疼差点晕倒,这位大爷看到了就扶了我一下,还打算送我去医院,说小姑娘一个人在外面要好好照顾自己,当时眼泪真的就下来了,在帝都这样冷漠的城市,有个陌生人能对你这样,突然感觉很温暖) 有时候会想是不是自己老了啊,去年这会刚工作,也是每天很累,因为很多东西要学,记得当时每天晚上看书到两点,周末不加班的时候,也是推了很多’约会’,睡上一上午,然后又开始敲代码… 很累的时候,有时候真的是想放弃,有亲戚跟我打电话,说他们那儿招这种刚毕业的学计算机的,一个月刚开始5000,还给解决住房问题,问我要不要考虑回去,毕竟帝都真的很恐怖;可是我刚毕业技术还有很大的上升空间,还是北京这样的大城市技术发展比较好,更能快速成长, 有时候也会想不如拿着自己的高中教师证回去当老师,或者考个公务员,或者找的对自己好的男的,直接结婚,像很多身边的女朋友一样,然后带孩子…可是那样的生活好像一眼就能望到头,那是我喜欢的生活么? 想起当初自己为什么铁了心的要转行,当时也是能想到以后会遇到很多困难,会很累,找工作的时候,学历就是普通本科,专业又是农业,我只能靠自己过硬的技术来比过自己的竞争者. 我正在为自己想要的生活去奋斗,不想平庸的过一辈子,在外面的时候,不要把自己当成一个女生,因为生活并不会因为你是女生而对你手下留情,所有还是像个汉子一样去努力吧,我相信越努力越幸运]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嘿,使用vue,你注意到了这些了么?]]></title>
    <url>%2F2017%2F08%2F23%2F2017-08-23-vue%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用vue过程中,遇到了一些问题,这里先总结以下两个: 问题一:vue组件之间传递数据,在子组件中我想改变一个从父组件中传过来的值 这是父组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;Child :message="message"&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child.vue';export default &#123; data() &#123; return &#123; message: '这是传给子组件的信息', &#125;; &#125;, components: &#123; Child, &#125;,&#125;;&lt;/script&gt; 这是子组件123456789101112131415161718192021&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, methods: &#123; handleChange() &#123; this.message = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 如果你这样写就会报一下错误但是在子组件中，我们不要去修改 prop。如果你必须要修改到这些数据，你可以使用以下方法： 把 prop 赋值给一个局部变量，然后需要修改的话就修改这个局部变量，而不影响 prop1234567891011121314151617181920212223242526&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;newMessage&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, data() &#123; return &#123; newMessage: this.message, &#125;; &#125;, methods: &#123; handleChange() &#123; this.newMessage = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 问题二:vue中检测不到data的变化,我想把给data中的a赋值一个新的对象(添加一个它本身不存在的属性),然而经过尝试发现直接赋值是行不通的,以下是我做的一下尝试12345&lt;template&gt; &lt;div&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt;&lt;/template&gt; 123456789101112131415 data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a.b = 1; &#125;, 1000) &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;,&#125;, 上面这样写(给对象a添加一个本来不存在的属性b,并给他赋值)并不会触发watch, vue文档中也明确表示添加到对象上的新属性不会触发更新,所以我们应该新建一个新的对象并将这个心对象的值赋值给原有的对象12345678910111213141516171819export default &#123; data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a = &#123; b: 1, &#125;; &#125;, 500); &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;, &#125;,&#125;; 由此给大家拓展一个对象的一些知识tips1: js取值的两种方式的区别123const obj = &#123;abc:"ss",nn:90&#125;;const v1 = obj.abc; // 使用点的方式const v2 = obj["abc"]; // 使用中括号的方式 在实际项目中一般使用.会方便很多,但是key是变量的话就不能使用.,js对象会理解变量为对象的key值, 1const v3 = obj[key]; tips2: 对象深拷贝实现方法 先解释什么是深拷贝和浅拷贝 浅拷贝是对对象地址的复制,并没有开辟新的栈,复制的结果是两个对象指向同一个地址,修改其中一个对象的属性,另一个对象的属性也会改变 深拷贝是开辟新的栈,两个对象对应两个不同的地址,修改一个对象的属性,不会改变另一个对象的属性 最简单的如下(方法一) 1b = JSON.parse( JSON.stringify(a) ) 但是会存在一些问题 无法复制函数 原型链没了，对象就是object，所属的类没了。 使用递归(方法二) 12345678910111213141516171819202122232425262728const obj1 = &#123; name: 'cehsi', age: 13, friends:['sk','ls'],&#125;function deepCopy(o, c) &#123; var c = c || &#123;&#125;; for(const i in o) &#123; if(typeof o[i] === 'object') &#123; // 判断是对象 if(o[i].constructor === Array) &#123; // 数组 c[i] = []; &#125; else &#123; c[i] = &#123;&#125;; &#125; deepCopy(o[i], c[i]); &#125; else &#123; c[i] = o[i]; &#125; &#125; return c;&#125;let obj2 = &#123;name: 'result'&#125;;obj2 = deepCopy(obj1, obj2);console.log(obj2); // &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125;obj2.age = 20;console.log(obj2, obj1); // &#123; name: 'cehsi', age: 20, friends: [ 'sk', 'ls' ] &#125; &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125; 使用npm install deepcopy tips3: 深对比,方法参考 http://stackoverflow.com/questions/1068834/object-comparison-in-javascript 方法一:Object.toJSON() 1这个方法简单,但是只适用于两个对象属性相同的情况,在没有方法和DOM节点的情况下，您可以使用简单的JSON样式对象： 123456789101112131415const obj1 = &#123; a: 1, b: 2,&#125;const obj2 = &#123; a: 1, b: 2,&#125;const obj3 = &#123; b: 2, a: 1,&#125;console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // trueconsole.log(JSON.stringify(obj1) === JSON.stringify(obj3)); // false 方法二: 深度比较两个对象 1比较对象而不挖掘原型，然后递归地比较属性的投影，还可以比较构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function deepCompare(x, y) &#123; var i, l, leftChain, rightChain; function compare2Objects(x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof(x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); if (!compare2Objects(x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw "Need two or more arguments to compare"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true;&#125; 已知问题（他们的优先级很低，可能你永远不会注意到） 具有不同原型结构但相同投影的物体 函数可能具有相同的文本，但是指的是不同的闭包原型]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭开vue神秘面纱]]></title>
    <url>%2F2017%2F08%2F20%2F2017-08-20-%E6%8F%AD%E5%BC%80vue%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[带你一步一步走进vue About源码aboutmegithubblog 实现过程,直接上代码1,实现简单的v-model的绑定1234567891011121314151617&lt;body&gt; &lt;input type="text" id="input" v-model="a"/&gt; &lt;p&gt;可以打开控制台,然后输入vm.查看view到model的绑定;然后改变input的值,再次在控制台输出vm.查看model到view的绑定&lt;/p&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; b: 10000, a: 1 &#125;, el: '#input' &#125;); setInterval(() =&gt; &#123; vm.a++; &#125;, 1000); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930function Vue(data) &#123; const input = document.querySelector(data.el); let model = input.getAttribute('v-model'); if(!data.data) &#123; console.warn(`你没有定义data`); return; &#125; if(model &amp;&amp; data.data.hasOwnProperty(model))&#123; // 实现model到view的绑定 input.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function() &#123; return data.data[model]; &#125;, set: function(newVal) &#123; input.value = data.data[model] = newVal; &#125;, &#125;) // 实现view到model的绑定 input.addEventListener("input", () =&gt; &#123; this[model] = input.value; &#125;); &#125; else &#123; console.warn(`你没有定义$&#123;model&#125;属性`); return; &#125;&#125; 把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 给input添加oninput事件实现view到model的绑定,即在input中输入一个值,vm.a也会跟着发生变化 2,实现多个v-model的绑定123456789101112131415161718192021&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125;&#125; 实现原理个实现一个v-model差不多 3,实现模板的绑定 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &#123;&#123; b &#125;&#125; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); console.log(vm); &lt;/script&gt;&lt;/body&gt; 用正则匹配到html中的模板字符串,然后将相应的部分替换成变量 匹配html中多个模板,必须先了解dom的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125; const pss = document.querySelector(data.el).childNodes; let ps = []; let arr = []; function getText(value) &#123; for (var i = 0, len = value.length; i &lt; len; i++) &#123; if (value[i].nodeType === 1) &#123; getText(value[i].childNodes); &#125; else if (value[i].nodeType === 3) &#123; ps.push(value[i]); &#125; &#125; &#125; getText(pss); const reg = /&#123;&#123;(.*)&#125;&#125;/; ps.forEach((i) =&gt; &#123; if (reg.test(i.nodeValue)) &#123; arr.push(i); &#125; &#125;); console.log(arr); for (const p of arr) &#123; let $p = reg.exec(p.nodeValue)[0].slice(2, p.nodeValue.length - 2).replace(/\s/g, ''); p.nodeValue = data.data[$p]; Object.defineProperty(this, $p, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[$p]; &#125;, set: function (newVal) &#123; p.nodeValue = data.data[$p] = newVal; &#125;, &#125;) &#125;&#125;// 错在多次赋值被覆盖的错误,所以思路应该变为找到所有绑定a, b, c的值,然后统一赋值 4,实现v-bind,v-on的绑定12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="form"&gt; &lt;h4&gt;这是测试v-model的效果&lt;/h4&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;hr&gt; &lt;h4&gt;这是测试&#123;&#123;&#125;&#125;的效果&lt;/h4&gt; &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &#123;&#123; a &#125;&#125;&#123;&#123; b &#125;&#125; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;h4&gt;这是测试v-bind和v-on的效果&lt;/h4&gt; &lt;img v-bind:src="src" v-bind:width="width1" :height="height" v-on:click="log" /&gt; &lt;p&gt;打开控制台,点击img,查看v-on的绑定效果&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.obj = &#123; a: 0, b: 100, c: '这是测试', src: "http://cdn.suisuijiang.com/message_1492395396308.png?imageView2/2/w/40/h/40", width1: 100, height: 100, &#125;; window.vm = new Vue(&#123; el: '#form', data: obj, methods: &#123; log: function() &#123; console.log('你点击了图片'); console.log(`当前c的值为 $&#123;this.c&#125;`); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; /** * 解析dom指令 * @param {*} $dom 根节点 * @param {*} instructs 解析结果 */ function handleInstruct($dom, instructs = {}) { function addInstruct(model, type, $node) { if (instructs[model]) { if (instructs[model][type]) { instructs[model][type].push($node); } else { instructs[model][type] = [$node]; } } else { instructs[model] = { [type]: [$node] }; } } if ($dom.attributes) { for (const attr of $dom.attributes) { if (attr.name === 'v-model') { const model = $dom.getAttribute('v-model'); addInstruct(model, 'model', $dom); } else if (/^(v-bind|:)/.test(attr.nodeName)) { const parseResult = attr.nodeName.match(/^(?:v-bind)?:([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'bind', { $dom, attr: parseResult[1] }); } } else if (/^(v-on|@)/.test(attr.name)) { const parseResult = attr.name.match(/^(?:v-on:|@)?([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'on', { $dom, event: parseResult[1] }); } } } } if ($dom.childNodes) { for (const $child of $dom.childNodes) { switch ($child.nodeType) { // ELEMENT_NODE case 1: { handleInstruct($child, instructs); break; } // TEXT_NODE case 3: { const parseResult = $child.data.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const model = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (model) { addInstruct(model, 'expression', { $dom: $child, exp: $child.data }); } }); } break; } default: break; } } } return instructs; } function updateDom(vm, instructs, model, shouldRegisterEvent = false) { // 实现v-model的绑定 if (instructs[model].model) { for (const $el of instructs[model].model) { $el.value = vm[model]; if (shouldRegisterEvent) { $el.oninput = () =&gt; { this[model] = $el.value; }; } } } // 实现{{}}的绑定 if (instructs[model].expression) { for (let { $dom, exp } of instructs[model].expression) { const parseResult = exp.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const m = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (m) { exp = exp.replace(new RegExp(`{{[ ]*${m[0]}[ ]*}}`), vm[m[0]]); } }); } $dom.textContent = exp; } } // 实现v-bind的绑定 if (instructs[model].bind) { for (const {$dom, attr} of instructs[model].bind) { $dom.setAttribute(attr, vm[model]); } } } function Vue(params) { const $dom = document.querySelector(params.el); if (!$dom) { console.error(`dom "${params.el}" not exist`); return; } const vm = {}; const instructs = handleInstruct($dom); // console.log(instructs); for (const model in instructs) { if (model &amp;&amp; params.data &amp;&amp; Object.prototype.hasOwnProperty.call(params.data, model)) { vm[model] = params.data[model]; Object.defineProperty(this, model, { get: function() { return vm[model]; }, set: function(newValue) { vm[model] = newValue; updateDom(vm, instructs, model); } }); updateDom.call(this, vm, instructs, model, true); } // 实现v-on的绑定 if (instructs[model].on) { for (const { $dom, event } of instructs[model].on) { $dom.addEventListener(event, params.methods[model].bind(this)); } } } } window.Vue = Vue;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for in vs for of]]></title>
    <url>%2F2017%2F07%2F03%2F2017-07-03-for-in-vs-for-of%2F</url>
    <content type="text"><![CDATA[for in 和 for of 的区别 for in 更适合遍历对象，不要使用for in 遍历数组 for in 遍历的是数组的索引(即键名)，而for of 遍历的是数组元素值 12345678910111213141516171819202122232425262728293031323334Object.prototype.methods = function () &#123; console.log(this);&#125;;var myObject = &#123; a: 1, b: 2, c: 3,&#125;;使用for in 遍历对象的键名 for (var key in myObject) &#123; console.log(key); &#125; a b c methodsfor in 可以遍历到myObject的原型方法methods，如果不想遍历原型方法和属性的话.可以用hasOwnPropery方法可以判断某属性是否是该对象的实例属性 for (var key in myObject) &#123; if(myObject.hasOwnProperty(key))&#123; console.log(key); &#125; &#125; a b c console.log(Object.keys(myObject)); [ 'a', 'b', 'c' ]Object.keys(myObject).forEach(function(key, index)&#123; console.log(key, myObject[key]);&#125;) a 1 b 2 c 3 同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。 for of 用来遍历数组的值]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中scroll的用法]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-vue-scroll%2F</url>
    <content type="text"><![CDATA[12345678910111213141516data () &#123; return &#123; scrolled: false &#125;;&#125;,methods: &#123; handleScroll () &#123; this.scrolled = window.scrollY &gt; 0; &#125;&#125;,created () &#123; window.addEventListener('scroll', this.handleScroll);&#125;,destroyed () &#123; window.removeEventListener('scroll', this.handleScroll);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之尾调用]]></title>
    <url>%2F2017%2F06%2F01%2F2017-06-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[尾调用，就是在函数的最后一步调用另一个函数123function foo(x) &#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作就行 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 函数m和n都属于尾调用，他们都是函数的最后一步操作 尾调用优化函数调用会在内存形成一个’调用记录‘，保存调用位置和内部变量等信息，如果在A函数中调用B函数，在A函数的调用记录上还会形成一个B的调用记录，等到B函数运行结束后，把结果返回到A，B的调用记录才会消失。如果函数B内部还调用C函数，那就是还有一个C的调用记录栈，以此类推，所有的调用记录，就会形成一个’调用栈‘。 尾调用在于它特殊的调用位置。由于是函数最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置和内部变量都不会再用到了。 ’尾调用优化‘，只调用内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2F2017%2F05%2F24%2F2017-05-24-react-redux%2F</url>
    <content type="text"><![CDATA[reduxredux的三个概念: action reducer store action: 一个包含type的object, 通常把一个返回action对象的函数称为action函数, 直接简称为action 1234567function action(data) &#123; return &#123; type: 'Action1', data, &#125;;&#125; reducer: 一个根据action type来更新数据的函数 123456789101112131415function reducer(state = &#123; data: 1 &#125;, action) &#123; switch (action.type) &#123; case 'action1': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; case 'action2': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; default: &#123; return state; &#125; &#125;&#125; store: 使用createStore从reducer函数创建的数据对象, 包含getState和dispatch方法 1234567import &#123; createStore &#125; from 'redux';let store = createStore(reducer);console.log(store.getState())store.dispatch(action(0))console.log(store.getState()) 注意! 更新数据需要dispatch对应的action react-redux用于将redux于react结合 Provider: 顶层组件, 注入store对象 12345678import &#123; Provider &#125; from 'react-redux';ReactDom.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('app'),); connect: 工具函数, 参数一为函数, 该函数接收state, 返回一个对象, 对象包含一系列数据. 参数二为函数, 该函数接收dispatch, 返回一个对象, 对象包含一系列方法123456789101112131415161718192021222324252627import &#123; connect &#125; from 'react-redux'; class App extends Component &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'action1', data: 1, &#125;); &#125; render() &#123; // this.props.func1(); // this.props.func2(); return ( &lt;div&gt; &lt;/div &gt; ); &#125;&#125;export default connect( state =&gt; (&#123; data: state.data, obj: state.obj, &#125;), dispatch =&gt; (&#123; dispatch &#125;),)(App); immutable.js特殊的object(MAP)/array(LIST) 更新数据: set setIn update updateIn 读取数据: get getIn 可以直接比较(深层比较) 创建(fromJS), 还原(toJS) 123456789101112131415上述的reducer可以用下面的代码优化function reducer(state = immutable.fromJS(&#123; data: 1, obj: &#123; aa: 1 &#125; &#125;), action) &#123; switch (action.type) &#123; case 'action1': &#123; return state.set('data', action.data * 10); &#125; case 'action2': &#123; return state.setIn(['obj', 'aa'], action.data); &#125; default: &#123; return state; &#125; &#125;&#125; 优点 无需深复制, 更新数据自动返回一个新对象 适合与react shouldComponentUpdate结合来优化性能 pure-render-decorator自动创建shouldComponentUpdate的工具, 需要配置babel decorator特性才能使用]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全家桶+crawler+koa2 实现阴阳师小助手]]></title>
    <url>%2F2017%2F05%2F20%2F2017-05-20-vue%E5%85%A8%E5%AE%B6%E6%A1%B6-crawler-koa2-%E5%AE%9E%E7%8E%B0%E9%98%B4%E9%98%B3%E5%B8%88%E5%B0%8F%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[最近一直在玩阴阳师，看了好多小助手，觉得太复杂了，还得登录什么的，想着自己写一个简单的小助手，只要输入要搜索的式神，我想知道的关于这个式神的数据就能显示出来。只是第一版，前端用vue全家桶实现的，很适合刚开始接触vue的，后端用node实现的，如果有更好的建议或者想一起合作写个更好用点的，欢迎联系 作者。 yys-fe(阴阳师小助手前端) A Vue.js project github项目链接 阴阳师小助手后端实现 nodejs + crawler + koa2 + mongoose 效果图 基本- 构建工具：webpack； - 语言：Es6； - 代码规范：eslint - 应用：vue， vuex（数据管理架构）， vue-router（路由）， mint-ui（ul组件）， vue-axios（vue做的ajax请求） 目录结构1234567891011121314151617|-- [build] //构建服务和webpack配置|-- [config] //项目不同环境的配置|-- [dist] //文件服务器根目录 |-- [node_modules] //项目依赖|-- [src] //源码| |-- [assets] //资源文件| |-- [components] //项目模块文件夹| |-- [store] //存储数据| | |-- index.js //vuex store 定义| |-- App.vue //主页面 | |-- main.js //webpack预编译入口| |-- [router] //全局路由定义|-- .babelrc //babel配置|-- .eslintrc.js //eslint rule 定义|-- index.html //项目入口文件|-- package.json //项目配置文件|-- README.md //关于启动项目的命令和含义 已经完成的模块 式神搜索页面(支持模糊搜索) 式神搜索结果页面 式神列表页面 式神详细信息页面 [X] 推荐御魂 [X] 推荐搭配 [X] 式神点评 待完成与优化 搜索功能添加历史搜索和热门搜索 式神攻略 式神视频 页面样式的优化 Build Setup` bash install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build 关于用vue时遇到的坑，记录在我的博客,希望可以对大家有用目前小编在学react，所以用react也写了一版,所以刚开始接触react的童鞋也可以看一下，想着第二版的ui设计的好看一点儿，功能再多一点儿，期待更多的建议。 Aboutgithubblog]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F05%2F03%2F2017-05-03-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。 排序算法 冒泡算法 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort([1,23,4,3])); 快速排序,通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for(let i = 1; i&lt;arr.length;i++) &#123; if(arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr),[q],quickSort(rightArr));&#125;console.log(quickSort([1,23,4,3]));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端拿高薪必看面试题]]></title>
    <url>%2F2017%2F05%2F02%2F2017-05-02-js%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试之前都会从网上找很多面试题来看,尤其是看到经典面试题,及必会的面试题,都是好好的看上几遍(其实更多的时候都是在背),可是总感觉面试之前看题作用并不大,因为你不理解的问题,还是会不理解,面试管随便一问,就不行了.其实面试几次后就会发现,经常问的问题也就那几个,比如,闭包,原型链,this,等.刚开始的时候真的是理解不了,然后就看书,强烈推荐《javascript高级程序设计(第三版)》以及《你不知道的javascript系列》,在实际项目中遇到坑的时候,就反复看,看的时候很难受,但是当真正理解了之后,就会恍然大悟,所以功夫还是下在平时,临时抱佛脚真的没啥用~ 以下是我总结的面试题中常问到的,很多都是我亲身经历的面试中遇到的一些问题,刚开始遇到的时候也不是太清楚,面试完之后就深入的学习了一下相关的知识😜 1,考察this 1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 10 ，2 第一次输出10应该没有问题。我们知道取对象属于除了点操作符还可以用中括号，所以第二次执行时相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。 123456789101112131415var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10 102,var和函数的提前声明 12345678function fn(a) &#123; console.log(a); var a = 2; function a() &#123;&#125; console.log(a); &#125;fn(1); function a() {} 2 var和function是会提前声明的.而且function是优先于var声明的(如果同时存在的话),所以刚开始输出的就是一个funciton,接着往下执行a进行重新赋值了,故第二次输出的是2； 3，局部变量和全局变量1234567891011121314var f = true;if (f === true) &#123; var a = 10;&#125;function fn() &#123; var b = 20; c = 30;&#125;fn();console.log(a);console.log(b);console.log(c); 输出 10 报错 30 这是个我犯了很久的错误，很长一段时间我都以为{…}内的新声明的变量是局部变量，后来我才发现function内的新声明的变量才是局部变量，而没有用var声明的变量在哪里都是全局变量。再次提醒切记只有function(){}内新声明的才能是局部变量，while{…}、if{…}、for(..) 之内的都是全局变量（除非本身包含在function内）。 4，变量隐式声明1234if( 'a' in window) &#123; var a = 10;&#125;console.log(a); 10 funciton和var会提前声明,而其实{…}内的变量也会提前声明，于是代码还没执行前a已经被声明了。所以 ‘a’ in window会返回true,a被赋值 5，给基本类型数据添加属性，不报错，但取值时是undefined1234567var a = 10;a.pro = 10;console.log(a.pro + a);var s = 'hello';s.pro = 'world';console.log(s.pro + s); NaN undefinedhello 给基本类型数据加属性不报错，但是引用的话返回undefined,10+undefined返回NaN,而undefined和string相加时转变成了字符串 6，函数声明优先于变量声明123console.log(typeof fn);function fn() &#123;&#125;;var fn; function 因为函数声明优于变量声明。我们知道在代码逐行执行前，函数声明和变量声明会提前进行，而函数声明又会优于变量声明，这里的优于可以理解为晚于变量声明后，如果函数名和变量名相同，函数声明就能覆盖变量声明。所以以上代码将函数声明和变量声明调换顺序还是一样结果。 7,判断一个字符串中出现次数最多的字符，并统计次数1234567891011121314151617181920var s = 'aaabbbcccaaabbbaaa';var obj = &#123;&#125;;var letter;var maxn = -1;for (let i = 0; i&lt; s.length; i++) &#123; if(obj[s[i]]) &#123; obj[s[i]] ++; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; else &#123; obj[s[i]] = 1; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; &#125;console.log(`$&#123;letter&#125;:$&#123;maxn&#125;`); 正则12345678910var s = 'aaabbbcccaaabbbaaa';var a = s.split('');a.sort();s = a.join('');var pattern = /(\w)\1*/g;var ans = s.match(pattern);ans.sort(function(a, b) &#123; return a.length &lt; b.length;&#125;)console.log(ans[0][0] + ':' + ans[0].length); 8， 经典闭包123456789101112131415161718192021222324252627282930&lt;!--html--&gt;&lt;ul&gt; &lt;li&gt;这是第1个&lt;/li&gt; &lt;li&gt;这是第2个&lt;/li&gt; &lt;li&gt;这是第3个&lt;/li&gt; &lt;li&gt;这是第4个&lt;/li&gt;&lt;/ul&gt;&lt;!--js--&gt;一：for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; alert(this.index); &#125;;&#125;二:for(var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; lis[i].onclick = function() &#123; alert(i); &#125;; &#125;)(i); &#125;三：for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; alert(i); &#125;;&#125; 从0开始隔10s按顺序出现’第一次出现’,’第二次出现’,’第三次出现‘123456789101112131415const datas = ['1', '2', '3'];let timer = null;for (let i = 0; i &lt; datas.length; i++) &#123; // const index = i; if (timer) &#123; clearTimeout(timer); let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125; else &#123; let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125;&#125;; 9，请编写一个JavaScript函数 parseQueryString，它的用途是把URL参数解析为一个对象，如： var url = “http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2″1234567891011121314function parseQueryString(url) &#123; var obj = &#123;&#125;; var a = url.split('?'); if(a.length === 1) return obj; var b = a[1].split('&amp;'); for(var i = 0, length = b.length; i &lt; length; i++) &#123; var c = b[i].split('='); obj[c[0]] = c[1]; &#125; return obj;&#125;var url = 'http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2';var obj = parseQueryString(url);console.log(obj.key0, obj.key1, obj.key2); // 0 1 2 10,this1234567891011var baz=3;var bazz=&#123; baz: 2, getbaz: function() &#123; return this.baz &#125;&#125;console.log(bazz.getbaz())var g=bazz.getbaz;console.log(g());第一个输出2，第二个输出3,函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了 11，数组方法 数组排序:写一个js函数,将数组对象按照一定的顺序进行排序，且可通过参数决定升降序 123456789101112131415161718192021222324const list = [ &#123; "name": "first", "index": 1, &#125;, &#123; "name": "second", "index": 2, &#125;, &#123; "name": "third", "index": 3, &#125;, &#123; "name": "fourth", "index": 4, &#125;,]function compare(property)&#123; return function(a,b)&#123; return a[property] - a[property]; &#125;&#125;console.log(list.sort(compare('index'))) 12,求一个字符串的字节长度12345678910111213function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as"));str = 'hello world';console.log(str.charCodeAt(0)); // 104, 返回指定索引处字符的 Unicode 数值,大于255为中文console.log(str.charAt(0)); // h, 返回指定位置的字符, 13 jsonp原理及过程 利用标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个元素，地址指向第三方的API网址，形如 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”})这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 14, link和@import区别 link属于html标签，而@import是css提供的。 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的 15,一个页面从输入url到页面加载显示完成,这个过程都发生了什么? 1,浏览器开启一个线程来处理这个请求 2,查找浏览器缓存(浏览器缓存-系统缓存-路由器缓存) 3,DNS解析,查找该域名对应的IP地址,重定向(301), 4,向真实IP地址服务器发出tcp连接,tcp三次握手 5,握手成功后,进行http协议会话,浏览器发送报头 6,进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 7,进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 8,处理结束回馈报头，将数据返回至浏览器; 9,浏览器开始下载html文档(响应报头，状态码200)，同时设置缓存; 10,之后浏览器对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）。 11,得到绘制树之后，需要计算每个结点在页面中的位置，这一个过程称为layout 浏览器这边做的工作大致分为以下几步：加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等） 16,TCP传输的三次握手四次挥手策略 三次握手 SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 17, new操作符到底干了什么?深入了解 1,创建一个空对象,而且this变量引用该对象,同时还继承了该函数的原型. 2,属性和方法被加入到this引用的对象中, 3,新创建的对象由this所引用,而且最后隐式的返回this18, null和undefined的区别? undefined (1)变量被声明了,但是没有赋值,就等于undefined (2)调用函数时,应该提供的参数没有提供,该参数等于undefined (3)对象没有赋值的属性,该属性的值为undefined (4)函数没有返回值时,默认返回undefinednull (1)作为函数的参数,表示该函数的参数不是对象 (2)作为对象原型链的终点 19, js的基本数据类型Number,String,Boolean,Null, Undefined,Object,Symbol 20,DOM怎样添加,移除,复制,和创建节点12345678910111213// 创建新节点createDocumentFragment(); // 创建一个DOM片段createElement(); // 创建一个具体的元素createTextNode(); // 创建一个文本节点//添加,移除,替换appendChild()removeChild()replaceChild()insertBefore() // 在已有的子节点前插入一个新的子节点// 查找getElementByTagName() // 通过标签名称getElementByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() // 通过元素ID,唯一性 参考总结这10道javaScript笔试题你都会么正则2016年十家公司面试小记浅谈javascript的函数节流面试题1面试题2面试题3html与css道阻且长啊TAT(前端面试总结),17年春招面试总结 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于斐波那契数列]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[用js实现斐波那契数列首先介绍一下，斐波那契数列(Fibonacci sequence)又称黄金分割数列，斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用， 斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368…….. 这个数列从第3项开始，每一项都等于前两项之和。 实现方法一 1234567891011121314function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; return fib(n-1)+fib(n-2); &#125;&#125;以上的发法是能想到的最直观的实现，现在我们测试一下他的运行结果。fib(1);fib(10)fib(50);运行发现n=1时，会快速输出1，n=10,时，运行速度稍慢，但是当n=10时，运行就非常慢，原因是什么呢，因为n=50时，要进行差不多50次的函数调用，每次调用，都会重新走if的那三个判断条件，而且每次都是从最开始开始计算，当n越大时，性能越差，所以有没有更好的方法来实现它呢？ 实现方法二1234567891011121314151617function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; let a = 0, b = 1; let current = null; for(let i = 2; i &lt;= n; i++) &#123; current = b + a; a = b; b = current; &#125; return current; &#125;&#125;方法二与方法一不同之处在于，最后一个判断加入了一个for循环，current = b + a;当前享等于前两项的和，a = b;把前一项的值赋给a(第前两项)，b = current;把当前值赋给前b(第前一项)，这样当n&gt;1时，只需要在第三个判断走一个循环可以，而不需要一直调用函数，这样做比方法一性能上优化了很多，但是还有没有更好的方法呢? 实现方法三1234567891011121314151617181920212223var cache = &#123; 0: 0, 1: 1&#125;;function fib(n) &#123; return typeof cache[n] === 'number' ? cache[n] : cache[n] = fib(n - 1) + fib(n - 2);&#125;该方法的实现利用了缓存，这样每次计算的时候，都会把计算出的值存放到cache这个缓存中，等下次传入较大的n时，如果缓存中有需要的值，则直接用缓存中的值，这种方法大大提高了函数的性能。还存在一个问题,fib(10000) = Infinity;这有是为什么呢，我们可以从js中数值的取值范围考虑，如何知道js中数值的范围呢， console.log(Number.MAX_VALUE, Number.MIN_VALUE); //取得最大和最小的数console.log(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);取得最大和最小的整数1.7976931348623157e+308 5e-3249007199254740991 -9007199254740991console.log(fib(400));console.log(fib(500));1.760236806450138e+831.394232245616977e+104n 在大于500的时候差不多已超出范围 如果有更好的方法，欢迎指正]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
