(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{165:function(e,t,r){"use strict";r.r(t);var a=r(0),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"一：-object-defineproperty-和-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一：-object-defineproperty-和-proxy","aria-hidden":"true"}},[e._v("#")]),e._v(" 一： Object.defineProperty() 和 Proxy")]),e._v(" "),r("h3",{attrs:{id:"vue-2-x-通过-object-defineproperty-来实现vue数据的双向绑定的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-x-通过-object-defineproperty-来实现vue数据的双向绑定的","aria-hidden":"true"}},[e._v("#")]),e._v(" vue 2.X 通过 Object.defineProperty()来实现vue数据的双向绑定的")]),e._v(" "),r("p",[e._v("有以下问题")]),e._v(" "),r("ul",[r("li",[e._v("1.vue中检测不到对象属性的添加和删除")]),e._v(" "),r("li",[e._v("2.无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。")])]),e._v(" "),r("h3",{attrs:{id:"vue3-0-通过proxy来实现的，解决了以上问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-通过proxy来实现的，解决了以上问题","aria-hidden":"true"}},[e._v("#")]),e._v(" vue3.0 通过Proxy来实现的，解决了以上问题")]),e._v(" "),r("h2",{attrs:{id:"二：具体原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二：具体原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 二：具体原理")]),e._v(" "),r("h3",{attrs:{id:"proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy","aria-hidden":"true"}},[e._v("#")]),e._v(" proxy")]),e._v(" "),r("p",[e._v("主要是因为Proxy是拦截对象，对"),r("code",[e._v("对象")]),e._v('进行一个"拦截"，外界对该对象的访问，都必须先通过这层拦截。无论访问对象的什么属性，之前定义的还是新增的，它都会走到拦截中，')]),e._v(" "),r("h3",{attrs:{id:"object-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty","aria-hidden":"true"}},[e._v("#")]),e._v(" Object.defineProperty()")]),e._v(" "),r("p",[e._v("Object.defineProperty()是对"),r("code",[e._v("对象的某个具体属性")]),e._v("的setter和getter方法进行拦截，新属性的话，需要重新去对象新属性的setter和getter方法进行拦截，")]),e._v(" "),r("p",[e._v("vue在创建实例的时候把data深度遍历所有属性,并使用 Object.defineProperty 把这些属性全部转为 getter/setter。让 Vue 追踪依赖，在属性被访问和修改时通知变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。")]),e._v(" "),r("p",[e._v("当你在对象上新加了一个属性newProperty,当前新加的这个属性并没有加入vue检测数据更新的机制(因为是在初始化之后添加的),vue.$set是能让vue知道你添加了属性, 它会给你做处理；$set内部也是通过调用Object.defineProperty()去处理的")])])}),[],!1,null,null,null);t.default=v.exports}}]);