(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{258:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"flux架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flux架构","aria-hidden":"true"}},[t._v("#")]),t._v(" Flux架构")]),t._v(" "),e("p",[t._v("基本概念")]),t._v(" "),e("ul",[e("li",[t._v("View：视图层")]),t._v(" "),e("li",[t._v("Action（动作）：视图层发出的消息(比如mouseClick)")]),t._v(" "),e("li",[t._v("Dispatcher（派发器）：用来接收Actions，执行回调函数")]),t._v(" "),e("li",[t._v("Store(数据层)：用来存放应用的状态，一旦发生改变，就提醒Views要更新页面")])]),t._v(" "),e("p",[t._v("Dispatcher 收集所有的 Action,然后发给所有的 store.\n最大特点：数据的”单向流动“")]),t._v(" "),e("p",[t._v("Flux有一些缺点，比如一个应用可以拥有多个Store， 多个 Store 之间可能会有依赖关系， Store封装了数据还有处理数据的逻辑")]),t._v(" "),e("h1",{attrs:{id:"redux-用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-用法","aria-hidden":"true"}},[t._v("#")]),t._v(" redux 用法")]),t._v(" "),e("p",[t._v("将Flux与函数式编程结合在一起;")]),t._v(" "),e("h2",{attrs:{id:"基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),e("ul",[e("li",[t._v("Store：\n"),e("ul",[e("li",[t._v("store.getState()：")]),t._v(" "),e("li",[t._v("store.dispatch()：redux里里面没有Dispatcher的概念，Store 里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。")]),t._v(" "),e("li",[t._v("store.subscribe()")])])]),t._v(" "),e("li",[t._v("Action：Action 就是 View 发出的通知，告诉 Store State 要改变")]),t._v(" "),e("li",[t._v("Reducer： State的计算过程\n"),e("ul",[e("li",[t._v("为什么叫做reducer呢，reduce 是一个函数式编程的概念，经常和 map 放在一起说，简单来说，map 就是映射，reduce 就是归纳。映射就是把一个列表按照一定规则映射成另一个列表，而 reduce 是把一个列表通过一定规则进行合并，也可以理解为对初始值进行一系列的操作，返回一个新的值。")])])])]),t._v(" "),e("h2",{attrs:{id:"redux流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux流程","aria-hidden":"true"}},[t._v("#")]),t._v(" Redux流程")]),t._v(" "),e("ol",[e("li",[t._v("用户通过 View 发出 Action")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("store"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("action"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" nextState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("xxxReducer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("previousState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" action"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("State 一旦有变化，Store 就会调用监听函数。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("store"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("subscribe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listener"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("listerner")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" newState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" store"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  component"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"中间件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间件","aria-hidden":"true"}},[t._v("#")]),t._v(" 中间件")]),t._v(" "),e("p",[t._v("如何处理异步？")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("redux-thunk 中间件，改造 store.dispatch，使得后者可以接受函数作为参数。\n因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。")])]),t._v(" "),e("li",[e("p",[t._v("既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。\n这就需要使用redux-promise中间件。")])])]),t._v(" "),e("h1",{attrs:{id:"react-redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-redux","aria-hidden":"true"}},[t._v("#")]),t._v(" react-redux")]),t._v(" "),e("p",[t._v("Redux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。")]),t._v(" "),e("h1",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[t._v("#")]),t._v(" vuex")]),t._v(" "),e("p",[t._v("mutaitons: 都是同步事务；\naction: 执行异步操作，可以在action中 提交 store.commit('increment') 来触发 mutation,一个 Action 里面可以触发多个 mutation")]),t._v(" "),e("p",[t._v("Redux： view——>actions——>reducer——>state变化——>view变化（同步异步一样）")]),t._v(" "),e("p",[t._v("Vuex： view——>commit——>mutations——>state变化——>view变化（同步操作） view——>dispatch——>actions——>mutations——>state变化——>view变化（异步操作）")]),t._v(" "),e("h1",{attrs:{id:"redux-saga"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-saga","aria-hidden":"true"}},[t._v("#")]),t._v(" redux saga")]),t._v(" "),e("p",[t._v("用于管理异步操作的Redux中间件;\n刚才介绍了两个Redux 处理异步的中间件 redux-thunk 和 redux-promise，当然 redux 的异步中间件还有很多，他们可以处理大部分场景，这些中间件的思想基本上都是把异步请求部分放在了 action creator 中，理解起来比较简单。")]),t._v(" "),e("p",[t._v("redux-saga 采用了另外一种思路，它没有把异步操作放在 action creator 中，也没有去处理 reductor，而是把所有的异步操作看成“线程”，可以通过普通的action去触发它，当操作完成时也会触发action作为输出。saga 的意思本来就是一连串的事件。")]),t._v(" "),e("h1",{attrs:{id:"rxjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rxjs","aria-hidden":"true"}},[t._v("#")]),t._v(" RxJS")]),t._v(" "),e("p",[t._v("RxJS是一个库，它通过observable序列来编写异步和基于事件的程序。")]),t._v(" "),e("h1",{attrs:{id:"redux-obserable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-obserable","aria-hidden":"true"}},[t._v("#")]),t._v(" redux-obserable")]),t._v(" "),e("p",[t._v("是Redux的一个中间件，使用了 RxJs 来驱动 action 副作用。与其目的类似的有大家比较熟悉的 redux-thunk 和 redux-saga。通过集成 redux-observable，我们可以在 Redux 中使用到 RxJS 所提供的函数响应式编程（FRP）的能力，从而更轻松的管理我们的异步副作用（前提是你熟悉了 RxJS）。")]),t._v(" "),e("h1",{attrs:{id:"mobx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mobx","aria-hidden":"true"}},[t._v("#")]),t._v(" mobx")]),t._v(" "),e("h1",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他","aria-hidden":"true"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),e("p",[t._v("如何合理设计state和props,尽可能避免使用redux")]),t._v(" "),e("h1",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/flux.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flux 架构入门教程"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux 入门教程（一）：基本用法"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux 入门教程（二）：中间件与异步操作"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/53599723",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vuex、Flux、Redux、Redux-saga、Dva、MobX"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5b798501f265da43473130a1",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用 redux-observable 实现组件自治"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);