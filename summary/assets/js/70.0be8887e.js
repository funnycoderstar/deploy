(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{271:function(t,a,v){"use strict";v.r(a);var _=v(0),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"重排和重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重排和重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 重排和重绘")]),t._v(" "),v("ol",[v("li",[t._v("处理HTML标记并构建DOM树")]),t._v(" "),v("li",[t._v("处理CSS标记并构建CSSOM树")]),t._v(" "),v("li",[t._v("将DOM和CSSOM合并成一个渲染树（这里需要注意一下，有了渲染树，开始进入“布局”阶段；到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在视口在确切位置）")]),t._v(" "),v("li",[t._v("根据渲染树来布局，以计算每个节点的几何信息（为了弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始遍历）")]),t._v(" "),v("li",[t._v("将各个节点绘制到屏幕上。")])]),t._v(" "),v("p",[t._v("第一步到第三部非常快，耗时的是第四步和第五步")]),t._v(" "),v("p",[t._v('"生成布局"（flow）和 "绘制"（paint) 这两步，合称为"渲染"（render);')]),t._v(" "),v("p",[t._v("网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染；\n一下三种情况会导致网页重新渲染\n1.修改DOM\n2.修改样式表\n3.用户事件（比如鼠标悬停，页面滚动，输入框键入文字， 改变窗口大小等）")]),t._v(" "),v("p",[t._v("“重绘”不一定需要“重排”，比如改变某个网页的颜色，就只会触发“重绘”，不会触发“重排”，因为布局没有改变；\n”重排“必然导致”重绘“，比如改变改变一个网页元素的位置，就会同时触发”重排“和”重排“，因为布局改变了；")]),t._v(" "),v("h1",{attrs:{id:"对性能的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对性能的影响","aria-hidden":"true"}},[t._v("#")]),t._v(" 对性能的影响")]),t._v(" "),v("p",[t._v("一般规则是")]),t._v(" "),v("ul",[v("li",[t._v("样式表越简单，重排和重绘就越快")]),t._v(" "),v("li",[t._v("重排和重绘的DOM元素层级越高，成本就越高")]),t._v(" "),v("li",[t._v("table元素的重排和重绘成本，要高于div元素")])]),t._v(" "),v("h1",{attrs:{id:"提高性能的几个技巧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高性能的几个技巧","aria-hidden":"true"}},[t._v("#")]),t._v(" 提高性能的几个技巧")]),t._v(" "),v("p",[t._v("1.DOM的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作\n2.如果某个样式是通过重排得到的，那么最好缓存结果， 避免下一次用到的时候，浏览器又要重排\n3.不要一条一条的改变样式，而是要通过改变class, 或者csstext属性， 一次性改变样式")])])}),[],!1,null,null,null);a.default=e.exports}}]);