(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{266:function(r,e,o){"use strict";o.r(e);var t=o(0),a=Object(t.a)({},(function(){var r=this,e=r.$createElement,o=r._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[o("h1",{attrs:{id:"web-worker-service-worker-workbox"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#web-worker-service-worker-workbox","aria-hidden":"true"}},[r._v("#")]),r._v(" Web worker & Service Worker & Workbox")]),r._v(" "),o("h2",{attrs:{id:"什么是web-worker"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是web-worker","aria-hidden":"true"}},[r._v("#")]),r._v(" 什么是Web worker")]),r._v(" "),o("p",[o("strong",[r._v("Web worker为JavaScript 创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker线程在后台运行")]),r._v("， 两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被Worker线程负担了，主线程（通常负责UI交互）就会很流畅，不会被阻塞或拖慢。")]),r._v(" "),o("p",[o("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2018/07/web-worker.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("Web Worker 使用教程"),o("OutboundLink")],1)]),r._v(" "),o("h2",{attrs:{id:"什么是service-worker"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是service-worker","aria-hidden":"true"}},[r._v("#")]),r._v(" 什么是"),o("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers",target:"_blank",rel:"noopener noreferrer"}},[r._v("Service Worker"),o("OutboundLink")],1)]),r._v(" "),o("p",[r._v("Service Worker是一个HTML5 API，主要用来做持久的离线缓存。\n浏览器中的javaScript都是运行在一个单一主线程上的。在同一个时间内只能做一件事情。随着Web业务不断复杂，我们逐渐在js中加了很多耗资源，耗时间的复杂运算过程，这些过程导致的性能问题在WebApp的复杂过程中更加凸显出来。")]),r._v(" "),o("p",[r._v("W3C组织早早的洞察到了这些问题可能造成的影响，这个是有有个web worker的API被造出来了，这个API的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活儿交给它完成，完成后通过postMessage 方法告诉主进程，而主进程通过 onMessage方法得到Web Worker的结果反馈。")]),r._v(" "),o("p",[r._v("一切问题好像是解决了，但Web worker是临时的，每次做的事情的结果还不能被持久存下来，如果下次有同样的复杂操作，还得费时间的重新来一遍。那我们能不能有一个Worker是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初的Service Worker, "),o("strong",[r._v("Service Worker在Web Worker的基础上加了持久离线缓存能力")]),r._v("。当然在Service Worker之前也有在HTML5上做离线缓存的API叫AppCache，但是但是 AppCache 存在很多 不能"),o("a",{attrs:{href:"https://alistapart.com/article/application-cache-is-a-douchebag",target:"_blank",rel:"noopener noreferrer"}},[r._v("忍受的缺点"),o("OutboundLink")],1),r._v("。")]),r._v(" "),o("p",[r._v("Service Worker有以下功能和特性：")]),r._v(" "),o("ul",[o("li",[r._v("一个独立的worker,独立于当前网页进程，有自己独立的 worker context。")]),r._v(" "),o("li",[r._v("一旦被install， 就永选存在，除非被手动 unregister")]),r._v(" "),o("li",[r._v("用到的时候可以直接唤醒，不用的时候自己睡眠")]),r._v(" "),o("li",[r._v("可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）")]),r._v(" "),o("li",[r._v("离线内容开发者可控")]),r._v(" "),o("li",[r._v("能向客户端推动消息")]),r._v(" "),o("li",[r._v("不能直接操作DOM")]),r._v(" "),o("li",[r._v("必须在HTTPS环境下才可工作")]),r._v(" "),o("li",[r._v("异步实现，内部大都是通过Promise实现")])]),r._v(" "),o("p",[o("a",{attrs:{href:"https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-introduction",target:"_blank",rel:"noopener noreferrer"}},[r._v("Service Worker 简介"),o("OutboundLink")],1)]),r._v(" "),o("h2",{attrs:{id:"什么是workbox"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是workbox","aria-hidden":"true"}},[r._v("#")]),r._v(" 什么是Workbox")]),r._v(" "),o("p",[r._v("https://juejin.im/post/5b38bc886fb9a00e5b120437")]),r._v(" "),o("p",[r._v("https://zoumiaojiang.com/article/amazing-workbox-3/")])])}),[],!1,null,null,null);e.default=a.exports}}]);