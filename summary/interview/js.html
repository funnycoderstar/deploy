<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | 前端学习总结</title>
    <meta name="description" content="前端学习总结">
    <link rel="icon" href="https://cdn.wangyaxing.cn/icon-128x128.png">
    
    <link rel="preload" href="/summary/assets/css/0.styles.976d6aee.css" as="style"><link rel="preload" href="/summary/assets/js/app.42468a2d.js" as="script"><link rel="preload" href="/summary/assets/js/2.1ee37bec.js" as="script"><link rel="preload" href="/summary/assets/js/79.020bb0a2.js" as="script"><link rel="prefetch" href="/summary/assets/js/10.8eb1538c.js"><link rel="prefetch" href="/summary/assets/js/100.1ddcc6b4.js"><link rel="prefetch" href="/summary/assets/js/101.2bb5d105.js"><link rel="prefetch" href="/summary/assets/js/102.c12236a4.js"><link rel="prefetch" href="/summary/assets/js/103.919530c8.js"><link rel="prefetch" href="/summary/assets/js/104.073729fa.js"><link rel="prefetch" href="/summary/assets/js/105.b0f80c52.js"><link rel="prefetch" href="/summary/assets/js/106.799747b6.js"><link rel="prefetch" href="/summary/assets/js/107.cc99fda4.js"><link rel="prefetch" href="/summary/assets/js/108.3e73a198.js"><link rel="prefetch" href="/summary/assets/js/109.af5917b5.js"><link rel="prefetch" href="/summary/assets/js/11.34b775fd.js"><link rel="prefetch" href="/summary/assets/js/110.0f1298d0.js"><link rel="prefetch" href="/summary/assets/js/111.2e89ece1.js"><link rel="prefetch" href="/summary/assets/js/112.fad565e0.js"><link rel="prefetch" href="/summary/assets/js/113.a09f1c19.js"><link rel="prefetch" href="/summary/assets/js/114.43347d48.js"><link rel="prefetch" href="/summary/assets/js/115.96825ee2.js"><link rel="prefetch" href="/summary/assets/js/116.6cdb17d4.js"><link rel="prefetch" href="/summary/assets/js/117.90d5b3de.js"><link rel="prefetch" href="/summary/assets/js/118.99d0c2c2.js"><link rel="prefetch" href="/summary/assets/js/119.af945a16.js"><link rel="prefetch" href="/summary/assets/js/12.3ad1af9d.js"><link rel="prefetch" href="/summary/assets/js/120.1fb3b05b.js"><link rel="prefetch" href="/summary/assets/js/121.4d5750ab.js"><link rel="prefetch" href="/summary/assets/js/122.7e2047c3.js"><link rel="prefetch" href="/summary/assets/js/123.9fd343ce.js"><link rel="prefetch" href="/summary/assets/js/124.b2d07de2.js"><link rel="prefetch" href="/summary/assets/js/125.93161990.js"><link rel="prefetch" href="/summary/assets/js/126.83749704.js"><link rel="prefetch" href="/summary/assets/js/127.92f55989.js"><link rel="prefetch" href="/summary/assets/js/128.61fa9826.js"><link rel="prefetch" href="/summary/assets/js/129.363cccfd.js"><link rel="prefetch" href="/summary/assets/js/13.3c11b086.js"><link rel="prefetch" href="/summary/assets/js/130.28ccaf07.js"><link rel="prefetch" href="/summary/assets/js/131.0a31acc5.js"><link rel="prefetch" href="/summary/assets/js/132.e5bcaa1f.js"><link rel="prefetch" href="/summary/assets/js/133.c222d33b.js"><link rel="prefetch" href="/summary/assets/js/134.f1cb1ca2.js"><link rel="prefetch" href="/summary/assets/js/135.4be21204.js"><link rel="prefetch" href="/summary/assets/js/136.0c47aa82.js"><link rel="prefetch" href="/summary/assets/js/137.e912039e.js"><link rel="prefetch" href="/summary/assets/js/138.cddcd9f5.js"><link rel="prefetch" href="/summary/assets/js/139.1083da78.js"><link rel="prefetch" href="/summary/assets/js/14.8164a8d3.js"><link rel="prefetch" href="/summary/assets/js/140.4f21b0ac.js"><link rel="prefetch" href="/summary/assets/js/141.5e9002db.js"><link rel="prefetch" href="/summary/assets/js/142.8218a1c2.js"><link rel="prefetch" href="/summary/assets/js/143.7fb53e57.js"><link rel="prefetch" href="/summary/assets/js/144.7fd0b4ea.js"><link rel="prefetch" href="/summary/assets/js/145.6111dedb.js"><link rel="prefetch" href="/summary/assets/js/146.d55743a2.js"><link rel="prefetch" href="/summary/assets/js/147.5c2fa0c9.js"><link rel="prefetch" href="/summary/assets/js/148.1a62ad5e.js"><link rel="prefetch" href="/summary/assets/js/149.6a46114a.js"><link rel="prefetch" href="/summary/assets/js/15.36dbadda.js"><link rel="prefetch" href="/summary/assets/js/150.51fd6a8f.js"><link rel="prefetch" href="/summary/assets/js/151.8b6e7008.js"><link rel="prefetch" href="/summary/assets/js/152.748ade7f.js"><link rel="prefetch" href="/summary/assets/js/153.946244bf.js"><link rel="prefetch" href="/summary/assets/js/154.d2f651ea.js"><link rel="prefetch" href="/summary/assets/js/155.4a2335e5.js"><link rel="prefetch" href="/summary/assets/js/156.dc436376.js"><link rel="prefetch" href="/summary/assets/js/157.3708776f.js"><link rel="prefetch" href="/summary/assets/js/158.3364d602.js"><link rel="prefetch" href="/summary/assets/js/159.3975267e.js"><link rel="prefetch" href="/summary/assets/js/16.be6e7209.js"><link rel="prefetch" href="/summary/assets/js/160.db4f3aa6.js"><link rel="prefetch" href="/summary/assets/js/161.4255839e.js"><link rel="prefetch" href="/summary/assets/js/162.7c07c738.js"><link rel="prefetch" href="/summary/assets/js/17.f769a9df.js"><link rel="prefetch" href="/summary/assets/js/18.e061b4bb.js"><link rel="prefetch" href="/summary/assets/js/19.7dcb6be8.js"><link rel="prefetch" href="/summary/assets/js/20.8d6622a1.js"><link rel="prefetch" href="/summary/assets/js/21.fd7e385f.js"><link rel="prefetch" href="/summary/assets/js/22.86bee446.js"><link rel="prefetch" href="/summary/assets/js/23.98152607.js"><link rel="prefetch" href="/summary/assets/js/24.ff277d23.js"><link rel="prefetch" href="/summary/assets/js/25.38e5ece6.js"><link rel="prefetch" href="/summary/assets/js/26.4bf6adb2.js"><link rel="prefetch" href="/summary/assets/js/27.b9d7e61e.js"><link rel="prefetch" href="/summary/assets/js/28.2fc6a42c.js"><link rel="prefetch" href="/summary/assets/js/29.65730f32.js"><link rel="prefetch" href="/summary/assets/js/3.2d12c32b.js"><link rel="prefetch" href="/summary/assets/js/30.e57d5f14.js"><link rel="prefetch" href="/summary/assets/js/31.c7e63dce.js"><link rel="prefetch" href="/summary/assets/js/32.c404eb4d.js"><link rel="prefetch" href="/summary/assets/js/33.25e97b0c.js"><link rel="prefetch" href="/summary/assets/js/34.fef8ae97.js"><link rel="prefetch" href="/summary/assets/js/35.f3a436c9.js"><link rel="prefetch" href="/summary/assets/js/36.34412875.js"><link rel="prefetch" href="/summary/assets/js/37.808d0668.js"><link rel="prefetch" href="/summary/assets/js/38.69f44859.js"><link rel="prefetch" href="/summary/assets/js/39.0dd4d5dd.js"><link rel="prefetch" href="/summary/assets/js/4.db2c63af.js"><link rel="prefetch" href="/summary/assets/js/40.915d5c12.js"><link rel="prefetch" href="/summary/assets/js/41.2988d821.js"><link rel="prefetch" href="/summary/assets/js/42.43bdad6c.js"><link rel="prefetch" href="/summary/assets/js/43.a41754a4.js"><link rel="prefetch" href="/summary/assets/js/44.c01bdeea.js"><link rel="prefetch" href="/summary/assets/js/45.aa4207d1.js"><link rel="prefetch" href="/summary/assets/js/46.094733d2.js"><link rel="prefetch" href="/summary/assets/js/47.17c71655.js"><link rel="prefetch" href="/summary/assets/js/48.7771c0b7.js"><link rel="prefetch" href="/summary/assets/js/49.76301772.js"><link rel="prefetch" href="/summary/assets/js/5.15730f29.js"><link rel="prefetch" href="/summary/assets/js/50.5995e015.js"><link rel="prefetch" href="/summary/assets/js/51.e6b99fa3.js"><link rel="prefetch" href="/summary/assets/js/52.8c223934.js"><link rel="prefetch" href="/summary/assets/js/53.627a8fc4.js"><link rel="prefetch" href="/summary/assets/js/54.67a4db5f.js"><link rel="prefetch" href="/summary/assets/js/55.03f64c00.js"><link rel="prefetch" href="/summary/assets/js/56.7dccf975.js"><link rel="prefetch" href="/summary/assets/js/57.51c12383.js"><link rel="prefetch" href="/summary/assets/js/58.db835429.js"><link rel="prefetch" href="/summary/assets/js/59.168bc9ce.js"><link rel="prefetch" href="/summary/assets/js/6.00f0d033.js"><link rel="prefetch" href="/summary/assets/js/60.eb31f0c8.js"><link rel="prefetch" href="/summary/assets/js/61.4539e00c.js"><link rel="prefetch" href="/summary/assets/js/62.6c5b6dcf.js"><link rel="prefetch" href="/summary/assets/js/63.a913cf86.js"><link rel="prefetch" href="/summary/assets/js/64.5451dc6a.js"><link rel="prefetch" href="/summary/assets/js/65.13e91371.js"><link rel="prefetch" href="/summary/assets/js/66.da5553b2.js"><link rel="prefetch" href="/summary/assets/js/67.65c83c98.js"><link rel="prefetch" href="/summary/assets/js/68.3cb17917.js"><link rel="prefetch" href="/summary/assets/js/69.df0028cc.js"><link rel="prefetch" href="/summary/assets/js/7.1e0fdcbf.js"><link rel="prefetch" href="/summary/assets/js/70.0be8887e.js"><link rel="prefetch" href="/summary/assets/js/71.f084cd61.js"><link rel="prefetch" href="/summary/assets/js/72.d49a2556.js"><link rel="prefetch" href="/summary/assets/js/73.c0f3819e.js"><link rel="prefetch" href="/summary/assets/js/74.ff86e250.js"><link rel="prefetch" href="/summary/assets/js/75.8c02416e.js"><link rel="prefetch" href="/summary/assets/js/76.a7e8b1fb.js"><link rel="prefetch" href="/summary/assets/js/77.b9734522.js"><link rel="prefetch" href="/summary/assets/js/78.09e8c8fa.js"><link rel="prefetch" href="/summary/assets/js/8.393630e6.js"><link rel="prefetch" href="/summary/assets/js/80.8f953533.js"><link rel="prefetch" href="/summary/assets/js/81.835765fa.js"><link rel="prefetch" href="/summary/assets/js/82.fcc83f9a.js"><link rel="prefetch" href="/summary/assets/js/83.fe5ba7fa.js"><link rel="prefetch" href="/summary/assets/js/84.ddfa044f.js"><link rel="prefetch" href="/summary/assets/js/85.b91b8ecb.js"><link rel="prefetch" href="/summary/assets/js/86.c8bc3f53.js"><link rel="prefetch" href="/summary/assets/js/87.441e3f9e.js"><link rel="prefetch" href="/summary/assets/js/88.1b08f34a.js"><link rel="prefetch" href="/summary/assets/js/89.ff281bfb.js"><link rel="prefetch" href="/summary/assets/js/9.b20a9d51.js"><link rel="prefetch" href="/summary/assets/js/90.1b2f916d.js"><link rel="prefetch" href="/summary/assets/js/91.06d4b59d.js"><link rel="prefetch" href="/summary/assets/js/92.d23211f4.js"><link rel="prefetch" href="/summary/assets/js/93.b9840f77.js"><link rel="prefetch" href="/summary/assets/js/94.6c5f4070.js"><link rel="prefetch" href="/summary/assets/js/95.81384028.js"><link rel="prefetch" href="/summary/assets/js/96.5d3dc87e.js"><link rel="prefetch" href="/summary/assets/js/97.30921dca.js"><link rel="prefetch" href="/summary/assets/js/98.f0f74e7a.js"><link rel="prefetch" href="/summary/assets/js/99.d25ae723.js">
    <link rel="stylesheet" href="/summary/assets/css/0.styles.976d6aee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/summary/" class="home-link router-link-active"><!----> <span class="site-name">前端学习总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/summary/" class="nav-link">home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/summary/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/summary/HTTP/" class="nav-link">HTTP</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/summary/React/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/summary/node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/tool/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/summary/tool/babel.html" class="nav-link">babel</a></li><li class="dropdown-item"><!----> <a href="/summary/tool/other.html" class="nav-link">更多</a></li></ul></div></div><div class="nav-item"><a href="/summary/interview/" class="nav-link router-link-active">面试题</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/new/" class="nav-link">新技术</a></li><li class="dropdown-item"><!----> <a href="/summary/translation/" class="nav-link">翻译</a></li><li class="dropdown-item"><!----> <a href="/summary/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/summary/nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/summary/meteor/" class="nav-link">Meteor</a></li><li class="dropdown-item"><!----> <a href="/summary/test/" class="nav-link">Test</a></li><li class="dropdown-item"><!----> <a href="/summary/wxapp/" class="nav-link">微信小程序</a></li><li class="dropdown-item"><!----> <a href="/summary/Webkit/" class="nav-link">Webkit</a></li><li class="dropdown-item"><!----> <a href="/summary/Safe/" class="nav-link">安全</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/funnycoderstar/leetcode" target="_blank" rel="noopener noreferrer" class="nav-link external">
  算法
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/funnycoderstar/Front-end-summary" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/summary/" class="nav-link">home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/summary/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/summary/HTTP/" class="nav-link">HTTP</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/summary/React/" class="nav-link">React</a></li><li class="dropdown-item"><!----> <a href="/summary/node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/tool/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/summary/tool/babel.html" class="nav-link">babel</a></li><li class="dropdown-item"><!----> <a href="/summary/tool/other.html" class="nav-link">更多</a></li></ul></div></div><div class="nav-item"><a href="/summary/interview/" class="nav-link router-link-active">面试题</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/summary/new/" class="nav-link">新技术</a></li><li class="dropdown-item"><!----> <a href="/summary/translation/" class="nav-link">翻译</a></li><li class="dropdown-item"><!----> <a href="/summary/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/summary/nginx/" class="nav-link">Nginx</a></li><li class="dropdown-item"><!----> <a href="/summary/meteor/" class="nav-link">Meteor</a></li><li class="dropdown-item"><!----> <a href="/summary/test/" class="nav-link">Test</a></li><li class="dropdown-item"><!----> <a href="/summary/wxapp/" class="nav-link">微信小程序</a></li><li class="dropdown-item"><!----> <a href="/summary/Webkit/" class="nav-link">Webkit</a></li><li class="dropdown-item"><!----> <a href="/summary/Safe/" class="nav-link">安全</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/funnycoderstar/leetcode" target="_blank" rel="noopener noreferrer" class="nav-link external">
  算法
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/funnycoderstar/Front-end-summary" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/interview/18道js笔试题.html" class="sidebar-link">18道JavaScript面试题</a></li><li><a href="/summary/interview/AlgorithmInterview.html" class="sidebar-link">算法面试题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js"><a href="#js" aria-hidden="true" class="header-anchor">#</a> JS</h2> <ol><li><p>ES6的Set内部实现
set内部通过使用 Object.js()来判断两个数据项是否相等，唯一不同的是+0和-0在Set中被判断是相等的。</p></li> <li><p>跨域</p></li></ol> <ul><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener noreferrer">不要再问我跨域的问题了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener noreferrer">前端常见跨域解决方案（全）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <ol start="3"><li><p>事件循环机制，node和浏览器的事件循环机制区别, node中事件队列模型, 事件循环, 如何解决同步调用代码耗时太高的问题, setTimeout(function(){},0)和process.nextTick()的区别</p></li> <li><p>typescript有什么好处？和Javascript区别在哪儿
静态类型检查：</p></li></ol> <ul><li>编译阶段即可发现类型不匹配的错误</li> <li>类型信息有助于编译器做优化</li> <li>IDE自动补全、检查等等，有文档作用</li> <li>类型就是做好的注释</li></ul> <ol start="5"><li><p>JWT优缺点, JWT细节，适用场景</p></li> <li><p>JS数据类型
一共有7中数据类型，分为基本数据类型(undefined, null, 不是new出来的 number, boolean, string, Symbol)，引用类型（function, object, array）</p></li></ol> <p>基本数据类型按值存储在栈中的（undefined, null, 不是new出来的 number, boolean, string)，每种类型数据占用的内存空间大小是确定的，由系统自动分配和释放，好处就是，内存更容易回收，和堆相比，更加更衣管理内存。
引用类型存在在堆内存中，其实引用类型的指针是存在栈内存中，当我们想要访问引用类型的值时，先需要从栈中获取对象的地址指针，然后在通过地址指针找到堆中锁存储的数据。
<img src="https://www.zhoulujun.cn/uploadfile/images/2019/0509/20190509203410820165528.png" alt="img"></p> <ul><li><a href="https://my.oschina.net/zhoulujun/blog/3050884" target="_blank" rel="noopener noreferrer">再谈js对象数据结构底层实现原理-object array map set<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <ol start="7"><li>选择器优先级</li> <li>前端性能优化手段, 各方面谈谈性能优化, 谈谈性能优化(高频)</li></ol> <h2 id="requestanimationframe-vs-settimeout-setinterval"><a href="#requestanimationframe-vs-settimeout-setinterval" aria-hidden="true" class="header-anchor">#</a> requestAnimationFrame VS setTimeout/setInterval</h2> <p>requestAnimationFrame的优点如下: https://zhuanlan.zhihu.com/p/55129100</p> <ol><li>requestAnimationFrame不需要设置时间,采用系统时间间隔,能达到最佳的效果</li> <li>会把每一帧中的所有DOM操作集中起来,在一次重绘或回流中完成</li></ol> <h2 id="前端性能优化"><a href="#前端性能优化" aria-hidden="true" class="header-anchor">#</a> 前端性能优化</h2> <ol><li><p>合并请求
合并请求主要目的是减少浏览器发起的请求数， 从而减少在发起请求过程中花费的时间；
具体手段有： 合并JS, 合并CSS以及合并小图片（使用雪碧图）等方式来优化</p></li> <li><p>域名拆分
浏览器的并发请求数目限制是针对同一域名， 为什么这么做呢</p></li> <li><p>开启gzip, CDN</p></li> <li><p>Minify
将JS和CSS等文本进行最小化处理</p></li> <li><p>按需加载资源</p></li> <li><p>启用 HTTP/2</p></li> <li><p>缓存
<a href="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%81%E8%AE%B8%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F">https://www.zhihu.com/question/20474326</a> <a href="https://www.zhihu.com/question/40505685/answer/86898655" target="_blank" rel="noopener noreferrer">常见的前端性能优化手段都有哪些？都有多大收益？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>谈谈XSS防御，以及Content-Security-Policy细节</p></li> <li><p>ES6特性</p></li> <li><p>闭包和this一起谈谈</p></li> <li><p>postcss配置</p></li> <li><p>Promise内部实现原理, 手写Promise实现, Promise实现原理, 一句话概述什么是 promise; promise解决了什么问题;在没有 promise 之前，怎么解决异步回调; 自己实现一个promise</p></li></ol> <h2 id="promise-prototype-then"><a href="#promise-prototype-then" aria-hidden="true" class="header-anchor">#</a> Promise.prototype.then()</h2> <p>作用： 为 Promise 实例添加状态改变时的回调函数</p> <h2 id="promise-prototype-catch"><a href="#promise-prototype-catch" aria-hidden="true" class="header-anchor">#</a> Promise.prototype.catch()</h2> <p>用于指定发生错误时的回调函数。</p> <h2 id="promise-prototype-finally"><a href="#promise-prototype-finally" aria-hidden="true" class="header-anchor">#</a> Promise.prototype.finally()</h2> <p>finally 方法用于指定 不管 Promise 对象最后如何，都会执行的操作。</p> <p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token parameter">value</span>  <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> reason <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="promise-all"><a href="#promise-all" aria-hidden="true" class="header-anchor">#</a> Promise.all()</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p> <h2 id="promise-race"><a href="#promise-race" aria-hidden="true" class="header-anchor">#</a> Promise.race()</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p> <h2 id="promise-resolve"><a href="#promise-resolve" aria-hidden="true" class="header-anchor">#</a> Promise.resolve()</h2> <p>有时需要将现有对象转为 Promise 对象， Promise.resolve 方法就起到这个作用。</p> <p>如果希望得到一个 Promise 对象，比较方便的方法就是直接调用 promise.resolve() 方法;</p> <h2 id="promise-try"><a href="#promise-try" aria-hidden="true" class="header-anchor">#</a> Promise.try()</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// next</span>
<span class="token comment">// now</span>
</code></pre></div><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">try</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// now</span>
<span class="token comment">// next</span>
</code></pre></div><p>Promise.prototype.catch()</p> <h2 id="需要注意的点"><a href="#需要注意的点" aria-hidden="true" class="header-anchor">#</a> 需要注意的点</h2> <ol><li>调用 resolve 和reject并不会终结 Promise 的参数函数的执行</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
</code></pre></div><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p> <ol start="2"><li>Promise新建之后就会立即执行</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Promise</span>
<span class="token comment">// Hi!</span>
<span class="token comment">// resolved</span>
</code></pre></div><ol start="3"><li>Promise 的状态一旦改变，就永久保持该状态，不会再变了</li></ol> <p>已经变成 resolved ,再抛出错误是无效的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ok</span>
</code></pre></div><ol start="4"><li>Promise ”会吃掉错误“</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">someAsyncThing</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面一行会报错，因为x没有声明</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">someAsyncThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'everything is great'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Uncaught (in promise) ReferenceError: x is not defined</span>
<span class="token comment">// 123</span>
</code></pre></div><p>上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码.</p> <ol start="5"><li>Promise.resolve(),是在本轮”事件循环“的结束时执行，而不是下一轮”事件循环“的开始时</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// one</span>
<span class="token comment">// two</span>
<span class="token comment">// three</span>
</code></pre></div><p>上面代码中， <code>setTimeout(fn, 0)</code>在下一轮”事件循环“开始时执行， <code>Promise.resolve()</code> 在本轮&quot;事件循环&quot;结束时执行，<code>console.log('one')</code>则是立即执行，因此最先输出。</p> <ol start="6"><li>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e <span class="token operator">===</span> thenable<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// true</span>
</code></pre></div><p>上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</p> <ol start="14"><li><p>serviceworker如何保证离线缓存资源更新, service work</p></li> <li><p>virtual dom有哪些好处</p></li> <li><p>发布订阅模式和观察者模式的异同</p></li> <li><p>图片懒加载实现</p></li> <li><p>事件模型，阻止冒泡</p></li> <li><p>CI/CD流程, CI/CD整体流程</p></li> <li><p>canvas优化绘制性能</p></li> <li><p>symbol应用</p></li> <li><p>深拷贝 和浅拷贝的区别, 怎么实现一个浅拷贝, 怎么实现一个深拷贝</p></li> <li><p>贝塞尔曲线</p></li> <li><p>正则的捕获组概念</p></li> <li><p>图片上传是怎么做的？能不能同时上传？</p></li> <li><p>操作系统里面进程和线程的区别</p></li> <li><p>前端安全：XSS（跨站脚本攻击），CSRF跨站请求伪造）</p></li> <li><p>js原型链</p></li> <li><p>闭包</p></li> <li><p>v8引擎区别浏览器做的优化</p></li> <li><p>编译型和解释型语言的区别</p></li> <li><p>跟缓存相关的配置</p></li> <li><p>node 的一些特点</p></li> <li><p>node对于字节流的控制</p></li> <li><p>如何处理js的错误:eslint。</p></li> <li><p>node垃圾回收</p></li> <li><p>js内存溢出</p></li> <li><p>if([]){} 是true，但是[]==false,因为任何类型跟bool比较都会先转化为数值型。[]是object if的时候不是false</p></li> <li><p>this的作用域，()=&gt;{} 箭头函数</p></li> <li><p>setImmediate</p></li> <li><p>require和import的区别： require是CommonJS模块， import是Es6模块，CommonJS是运行时加载， es6模块是编译时加载</p></li> <li><p>箭头函数的好处</p></li> <li><p>判断数组</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用Array.isArray'</span><span class="token punctuation">,</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用 instanceof '</span><span class="token punctuation">,</span> a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用constructor'</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用 Object.prototype.toString.call'</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;[object Array]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="42"><li>typeof和instanceof的区别
typeof判断基本数据类型.
typeof 原理， 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位存储其类型信息。</li></ol> <ul><li>000: 对象</li> <li>010: 浮点数</li> <li>100：字符串</li> <li>110： 布尔</li> <li>1： 整数</li></ul> <p>typeof null 为&quot;object&quot;, 原因是因为 不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位都为0的话会被判断为Object类型，null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回&quot;object&quot;。
一个不恰当的例子，假设所有的Javascript对象都是16位的，也就是有16个0或1组成的序列，猜想如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Array<span class="token punctuation">:</span> <span class="token number">1000100010001000</span>
<span class="token keyword">null</span><span class="token punctuation">:</span>  <span class="token number">0000000000000000</span>

<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> →<span class="token string">&quot;object&quot;</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span>→<span class="token string">&quot;object&quot;</span>
</code></pre></div><p>因为Array和null的前三位都是000。为什么Array的前三位不是100?因为二进制中的“前”一般代表低位， 比如二进制00000011对应十进制数是3，它的前三位是011。</p> <p>instanceof,通俗一些讲，用来比较一个对象是否为某一个构造函数的实例。注意，instanceof运算符只能用于对象，不适用原始类型的值。</p> <p>判断某个<code>实例</code>是否属于<code>某种类型</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>make <span class="token operator">=</span> make<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> year<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> auto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">'Honda'</span><span class="token punctuation">,</span> <span class="token string">'Accord'</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>auto <span class="token keyword">instanceof</span> <span class="token class-name">Car</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>也可以判断一个实例是否是其父类型或者祖先类型的实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>make <span class="token operator">=</span> make<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> year<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> auto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">'Honda'</span><span class="token punctuation">,</span> <span class="token string">'Accord'</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>auto <span class="token keyword">instanceof</span> <span class="token class-name">Car</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// expected output: true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>auto <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// expected output: true</span>
</code></pre></div><p>语法：</p> <div class="language-js extra-class"><pre class="language-js"><code>object <span class="token keyword">instanceof</span> <span class="token class-name">constructor</span>

<span class="token comment">// 等同于</span>
constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span>
</code></pre></div><ul><li>object： 要检测的对象</li> <li>constructor：某个构造函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">instanceof</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//L是表达式左边，R是表达式右边</span>
    <span class="token keyword">var</span> <span class="token constant">O</span> <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">L</span> <span class="token operator">===</span> <span class="token constant">O</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token constant">L</span> <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>instanceof原理： 检测 <code>constructor.prototype</code>是否存在于参数 object的原型链上。instanceof 查找的过程中会遍历 object 的原型链，直到找到 constructor的 prototype , 如果查找失败，则会返回false，告诉我们，object 并非是 constructor 的实例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>js原型继承机制：</p> <h3 id="构造函数的缺点"><a href="#构造函数的缺点" aria-hidden="true" class="header-anchor">#</a> 构造函数的缺点</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">DOG</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">'犬科'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> dogA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOG</span><span class="token punctuation">(</span><span class="token string">'大毛'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> dogB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOG</span><span class="token punctuation">(</span><span class="token string">'二毛'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。</p> <div class="language-js extra-class"><pre class="language-js"><code>dogA<span class="token punctuation">.</span>species <span class="token operator">=</span> <span class="token string">'猫科'</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>dogB<span class="token punctuation">.</span>species<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显示&quot;犬科&quot;，不受dogA的影响</span>
</code></pre></div><p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。
这个问题的解决方法，就是JavaScript的原型对象（prototype）;</p> <h3 id="prototype属性的作用"><a href="#prototype属性的作用" aria-hidden="true" class="header-anchor">#</a> prototype属性的作用</h3> <p>JavaScript继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有的实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p> <blockquote><p>如果你觉得这个不好理解，可以想一下，我们定义的任何对象，都可以使用 toString, valueOf()函数，这就是因为 tostring()和valueOf是定义在 object原型上的方法<code>Object.prototype.toString()</code> 和 <code>Object.prototype.valueOf()</code>；</p></blockquote> <h3 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h3> <p>javascript规定：所有的对象都有自己的原型对象（prototype），一方面，任何一个对象，都可以充当其他对象的原型；另一方面，所有原型对象也是对象，所有它有自己的原型。因此，就会形成一个“原型链”（protype chain）：对象到原型，再到原型的原型......</p> <p>如果一层层地上溯，所有对象的原型最终都可以上溯上 <code>Object.prototype</code>,即 <code>Object构造函数的 prototype</code>属性，也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有 valueOf 和toString方法的原因，因为是从 Object.prototype继承的。</p> <p>那么 Object.prototype对象有没有它的原型呢?回答是 Object.prototype的原型是 null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">// null</span>
</code></pre></div><p>Object.prototype对象的原型为null,由于null没有任何属性，所以原型链到此为止。</p> <p>读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的 <code>Object.prototype</code>还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”。</p> <p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p> <p>举例来说，如果让构造函数的 prototype 属性指向一个数组，就意味着实例对象可以调用数组方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">MyArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MyArray</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> MyArray<span class="token punctuation">;</span>

<span class="token keyword">var</span> mine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mine<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mine<span class="token punctuation">.</span>length <span class="token comment">// 3</span>
mine <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment">// true</span>
</code></pre></div><p>上面代码中，mine是构造函数MyArray的实例对象，由于MyArray.prototype指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。最后那行instanceof表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明mine为Array的实例，instanceof运算符的详细解释详见后文。</p> <h3 id="construstor属性"><a href="#construstor属性" aria-hidden="true" class="header-anchor">#</a> construstor属性</h3> <p><strong>prototype对象上有一个 construstor 属性，默认指向 prototype对象所在的构造函数</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">P</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">P</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>由于construstor属性定义在 prototype 对象上面，意味着可以被所有实例对象继承。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token constant">P</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token class-name">P</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'constructor'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

</code></pre></div><p>上面代码中<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上的 <code>P.prototype.constructor</code>属性</p> <p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪个构造函数产生的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// true</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">method</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// false</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// true</span>
</code></pre></div><p>上面对象中，构造函数 Person 的原型对象改掉了，但是没有修改 constructor 属性，导致这个属性不再指向 Person。由于 Person的新原型是一个普通对象，而普通对象的constructor属性指向 Object 构造函数，导致 <code>Person.prototype.constructor</code>变成了<code>Object</code>。</p> <ul><li><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener noreferrer">浅谈 instanceof 和 typeof 的实现原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://javascript.ruanyifeng.com/oop/prototype.html" target="_blank" rel="noopener noreferrer">prototype 对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <ol start="43"><li>new和instanceof的内部机制</li> <li>for...in迭代和for...of有什么区别？</li></ol> <ul><li><code>for in</code> 更适合遍历对象, 不要使用 <code>for in</code>遍历数组，<code>for in</code>遍历的是数组的索引（即键名）。</li> <li><code>for of</code>适合遍历数组, 遍历的是数组元素名。</li></ul> <blockquote><p>如果老是记不住怎么办，可以了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener noreferrer">in<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 运算符
如果指定的属性在指定的对象或其原型链中，则<code>in</code>运算符返回<code>true</code>。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> trees <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">&quot;redwood&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bay&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cedar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;oak&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;maple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">0</span> <span class="token keyword">in</span> trees        <span class="token comment">// 返回true</span>
<span class="token string">&quot;toString&quot;</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 如果一个属性是从原型链上继承来的，in 运算符也会返回 true。</span>
</code></pre></div><h2 id="for-in-遍历对象"><a href="#for-in-遍历对象" aria-hidden="true" class="header-anchor">#</a> for in 遍历对象</h2> <p>for in 可以遍历到原型上的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">methods</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 使用for in 遍历对象的键名</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token comment">//  a</span>
<span class="token comment">//  b</span>
<span class="token comment">//  c</span>
<span class="token comment">//  methods</span>
</code></pre></div><p>如果不想遍历原型方法和属性的话.可以用hasOwnPropery方法可以判断某属性是否是该对象的实例属性</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token comment">//  a</span>
<span class="token comment">//  b</span>
<span class="token comment">//  c</span>
</code></pre></div><p>同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">[</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span> <span class="token punctuation">]</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> myObject<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//  a 1</span>
<span class="token comment">//  b 2</span>
<span class="token comment">//  c 3</span>
</code></pre></div><p>如果用 for in 来遍历数组，我们来看看会输出什么</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">methods</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'name'</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
myArray<span class="token punctuation">.</span>test1 <span class="token operator">=</span><span class="token string">'数组'</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> myArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 0</span>
<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
<span class="token comment">// 4</span>
<span class="token comment">// test1</span>
<span class="token comment">// methods</span>
<span class="token comment">// test</span>
</code></pre></div><p>可以看出 for in 应用于数组返回的是数组的<code>下标</code>和数组的<code>属性</code>和<code>原型上的方法名和属性名</code>,而 for in应用与对象的遍历 返回的 是对象的 <code>属性名</code> 和<code>原型中的方法名和属性名</code>；
for in 遍历数组，但是会存在以下问题：</p> <ul><li>index 索引为字符串型数字，不能直接进行几何运算</li> <li>遍历顺序有可能不是按照实际数组的内部顺序</li> <li>使用for in会遍历数组所有的可枚举属性，包括原型。例如上例的原型方法method和test属性</li></ul> <h2 id="for-of-用来遍历数组的值"><a href="#for-of-用来遍历数组的值" aria-hidden="true" class="header-anchor">#</a> for of 用来遍历数组的值</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">methods</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'name'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
myArray<span class="token punctuation">.</span>test1 <span class="token operator">=</span><span class="token string">'数组'</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> myArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出结果</span>
<span class="token comment">// 1,200,3,400,100</span>
</code></pre></div><h2 id="for-of-的原理解析"><a href="#for-of-的原理解析" aria-hidden="true" class="header-anchor">#</a> for of 的原理解析</h2> <h3 id="iterator-遍历器"><a href="#iterator-遍历器" aria-hidden="true" class="header-anchor">#</a> Iterator(遍历器)</h3> <p>首先肯定是要说一下  Iterator(遍历器)。
Iterator 的作用有三个：
一是为各种数据结构，提供一个统一的、简便的访问接口；
二是使得数据结构的成员能够按某种次序排列；
三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。</p> <p>默认 Iterator 接口：
部署在 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就认为是&quot;可遍历的&quot;。</p> <p>Symbol.iterator 属性本身是个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。属性名为 Symbol.iterator,它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内;</p> <p>ES6的有些数据结构原生具备 Iterator接口（比如数组），即不用任何处理，就可以被 <code>for of</code>循环遍历。原因在于，<strong>这些数据结构原生部署了Symbol.iterator属性</strong>。另外一些数据结构没有（比如对象）。凡是部署了 Symbol.iterator属性 的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p> <h3 id="for-of-循环"><a href="#for-of-循环" aria-hidden="true" class="header-anchor">#</a> for of 循环</h3> <p>ES6引入 for of 循环，作为遍历所有数据结构的统一方法。</p> <blockquote><p>所以之前的理解存在一个误区，认为 for of 就是用来遍历数组的，for of 不只是用来遍历数组的，一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 <code>for of</code> 循环遍历它的成员。也就是说， for...of 循环内部调用的是数据结构的 Symbol.iterator方法。</p></blockquote> <p>for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p> <p>javaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。</p> <ol start="45"><li>原型链中prototype和__proto__分别指什么
<img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt="prototype &amp; proto">
需要注意一下几点：
1.在JS里，万物皆对象。方法（Function）是对象，方法的原型（Function.prototype）是对象。因此，它们都会具有对象共有的特点。
即：对象具有属性 <strong>proto</strong> , 可称为 隐式原型，<strong>一个对象的隐式原型指向构造该对象的构造函数的原型</strong>，这也保证了实例能够访问</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 实例对象one的隐式原型指向 构造函数Object的原型（Object.prototype）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 实例对象a的隐式原型指向 构造函数A的原型（A.prototype）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><ol start="2"><li>方法（Function）
方法这个特殊的对象，除了和其他对象一样有上述 <strong>proto</strong> 属性之外，还有自己特有的属性-原型属性（prototype）,这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做 constructor，这个属性包含了一个指针，指回原构造函数。</li></ol> <ul><li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener noreferrer">Javascript继承机制的设计思想<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener noreferrer">js中__proto__和prototype的区别和关系？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <ol start="46"><li>class实现原理： class是一个语法糖，很多都可以用es5的语法实现</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ES5实现</span>
<span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用ES6的实现</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
与 ES5 一样，类的所有实例共享一个原型对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p2<span class="token punctuation">.</span>__proto__
</code></pre></div><p>p1和p2都是 Point 的实例，他们的原型都是 Point.prototype, 所以 __proto__属性是相等的.
这意味着，可以通过__proto__属性为“类”添加方法；</p> <p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现在浏览器的JS引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产品依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function-variable function">printName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'Oops'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

p1<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Oops&quot;</span>
p2<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Oops&quot;</span>

<span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p3<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Oops&quot;</span>
</code></pre></div><p>上面代码在p1的原型上添加了一个 <code>printName</code> 方法， 由于 <code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的 <strong>proto</strong> 属性改写原型，必须相当谨慎，不推荐使用，这会改变“类”的原始定义，影响到所有实例。</p> <ol start="47"><li>async和await实现原理: 基于generator实现的，generator又是基于promise实现的</li></ol> <h2 id="含义"><a href="#含义" aria-hidden="true" class="header-anchor">#</a> 含义</h2> <p>async函数是 generator函数的语法糖；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fileName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">gen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> f2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>上面代码的函数 gen 可以写成 async 函数，就是下面这样</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">asyncReadFile</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> f2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>一比较就会发现， async函数就是将Generator函数的星号 (*)替换成 async, 将yield替换成 await, 仅此而已。</p> <p>syn函数对Generator函数的改进，体现在一下四点。</p> <ol><li>内置执行器
函数调用之后，会自动执行，Generator函数的执行必须靠执行器</li> <li>更好的语义
async和await,比起(*)和yield,语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果</li> <li>更广的适用性
co模块约定， yield命令后面只能是Thunk函数或者Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值，字符串，布尔值，但这时会自动转成立即resolved的Promise对象</li> <li>返回值是Promise
async函数的返回值是Promise对象，这比Generator函数的返回值Iterator对象方便多了，你可以用then方法指定下一步操作；</li></ol> <h2 id="async函数的实现原理"><a href="#async函数的实现原理" aria-hidden="true" class="header-anchor">#</a> async函数的实现原理</h2> <p>就是将 Generator函数和自动执行器，包装在一个函数里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的 async 函数都可以写成上面的第二种形式，其中 spawn 函数就是自动执行器。</p> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><h2 id="实现一个-sleep"><a href="#实现一个-sleep" aria-hidden="true" class="header-anchor">#</a> 实现一个 sleep</h2> <p>每隔1秒输出 1， 2， 3， 4， 5</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token parameter">interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用法</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">one2FiveInAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">one2FiveInAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="需要注意的点-2"><a href="#需要注意的点-2" aria-hidden="true" class="header-anchor">#</a> 需要注意的点</h2> <h3 id="多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。"><a href="#多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。" aria-hidden="true" class="header-anchor">#</a> 多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 写法一</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">let</span> fooPromise <span class="token operator">=</span> <span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> barPromise <span class="token operator">=</span> <span class="token function">getBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">await</span> fooPromise<span class="token punctuation">;</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">await</span> barPromise<span class="token punctuation">;</span>
</code></pre></div><p>上面两种写法，getFoo 和getBar都是同时触发的，这样就会缩短程序的执行时间。</p> <h3 id=""><a href="#" aria-hidden="true" class="header-anchor">#</a></h3> <ol start="48"><li>说一下你对generator的了解？</li></ol> <h2 id="概念"><a href="#概念" aria-hidden="true" class="header-anchor">#</a> 概念</h2> <p><strong>异步编程解决方案</strong>
返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p> <p>调用generator函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value属性表示当前的内部状态的值。是yield表达式后面的那个值； done是一个布尔值，表示是否遍历结束。</p> <h2 id="yiled表达式"><a href="#yiled表达式" aria-hidden="true" class="header-anchor">#</a> yiled表达式</h2> <p>generator返回的遍历器对象，只有调用 next 函数才会遍历下一个内部状态。提供了一种可以暂停执行的函数，yield表达式就是暂停标识。
遍历器对象 next的处理逻辑如下：</p> <ol><li>遇到 yiled 表达式，就暂停执行后面的操作，并将紧跟 yield 后面表达式的值，作为返回的对象 value的属性值。</li> <li>下一次调用 next 方法就继续往下执行，直到遇到下一个 yield</li> <li>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到return语句为止，并将 return 语句后面的表达式值，作为返回的对象的value属性值。</li> <li>如果该函数没有 return 语句，则返回的对象value 属性值为 undefined</li></ol> <h2 id="next方法的参数"><a href="#next方法的参数" aria-hidden="true" class="header-anchor">#</a> next方法的参数</h2> <p><strong>yield 表达式本身没有返回值，或者说总是返回undefined. next 方法可以带一个参数，该参数就会被当做上一个yield表达式的返回值</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token punctuation">(</span>y <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:6, done:false}</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:NaN, done:false}</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:NaN, done:true}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// { value:6, done:false }</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// { value:8, done:false }</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token comment">// { value:42, done:true }</span>
</code></pre></div><h2 id="for-of-循环-2"><a href="#for-of-循环-2" aria-hidden="true" class="header-anchor">#</a> for of 循环</h2> <p><code>for...of</code>可以自动遍历 Generator 函数运行时生成的 Iterator对象，且此时不再需要调用 <code>next</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code>unction<span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1 2 3 4 5</span>
</code></pre></div><p>上面代码使用 for...of 循环，依次显示5个 yield 表达式的值。这里需要注意，一旦 next 方法返回对象的done属性为 true， for...of 循环就会终止，且不包含该返回对象，所以上面代码的 return 语句返回的6，不包含在 <code>for...of</code>循环之中。</p> <p>下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> curr<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>prev<span class="token punctuation">,</span> curr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>curr<span class="token punctuation">,</span> prev <span class="token operator">+</span> curr<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> n <span class="token keyword">of</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了for of 循环以外，拓展运算符（...）、解构赋值和 <code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 iterator对象 作为参数。</p> <h2 id="generator-函数的异步应用"><a href="#generator-函数的异步应用" aria-hidden="true" class="header-anchor">#</a> Generator 函数的异步应用</h2> <p>传统方法（ES6之前）</p> <ul><li>回调函数</li> <li>事件监听</li> <li>发布/订阅</li> <li>Promise对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？</p> <p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p> <h3 id="协程的-generator-函数-实现"><a href="#协程的-generator-函数-实现" aria-hidden="true" class="header-anchor">#</a> 协程的 Generator 函数 实现</h3> <p>交出函数的执行权（即暂定执行）；
Generator 函数可以<strong>暂停执行</strong>和<strong>恢复执行</strong>，这是它能封装异步任务的根本原因，除此之外，它还有两个特性。使它可以作为异步编程的完美解决方法：<strong>函数体内外的数据交换</strong>和<strong>错误处理机制</strong>。</p> <h4 id="函数体内外的数据交换"><a href="#函数体内外的数据交换" aria-hidden="true" class="header-anchor">#</a> 函数体内外的数据交换</h4> <p>next返回值得value属性，是Generator 函数向外输出数据；next方法还可以接受参数，想Generator 函数体内输入数据。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// { value: 3, done: false }</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// { value: 2, done: true }</span>
</code></pre></div><h4 id="错误处理机制"><a href="#错误处理机制" aria-hidden="true" class="header-anchor">#</a> 错误处理机制</h4> <p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 出错了</span>
</code></pre></div><p>上面代码的最后一行，Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p> <h3 id="thunk函数"><a href="#thunk函数" aria-hidden="true" class="header-anchor">#</a> thunk函数</h3> <p>thunk函数是自动执行 Generator函数的一种方法</p> <h3 id="co模块"><a href="#co模块" aria-hidden="true" class="header-anchor">#</a> CO模块</h3> <p>co模块的原理</p> <p>为什么 co可以自动执行 Generator 函数？</p> <p>Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p> <p>两个方法可以做到这一点。</p> <ol><li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交出执行权。</li> <li>Promise对象。将异步操作包装成Promise对象，用then方法交回执行权.</li></ol> <p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co模块的条件是, Generator 函数的yield命令后面，只能是Thunk函数或Promise对象，如果数组或对象的成员，全部都是 promise对象，也可以使用co.</p> <h3 id="基于-promise-对象的自动执行"><a href="#基于-promise-对象的自动执行" aria-hidden="true" class="header-anchor">#</a> 基于 Promise 对象的自动执行</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">gen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> f2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>手动执行就是用 then 方法， 层层添加回调函数，理解这一点，就可以写出一个自执行器。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">run</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中，只要Generator 函数 还没执行到最后一步，next就调用自身，以此实现自动执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">co</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            gen <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>gen <span class="token operator">||</span> <span class="token keyword">typeof</span> gen<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> ret<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                ret <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">next</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">ret</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token function">toPromise</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> <span class="token function">isPromise</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token function">onRejected</span><span class="token punctuation">(</span>
                <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>
                    <span class="token string">'You may only yield a function, promise, generator, array, or object, '</span>
                    <span class="token operator">+</span> <span class="token string">'but the following object was passed: &quot;'</span>
                    <span class="token operator">+</span> <span class="token function">String</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                    <span class="token operator">+</span> <span class="token string">'&quot;'</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="应用"><a href="#应用" aria-hidden="true" class="header-anchor">#</a> 应用</h2> <ol><li><p>异步操作的同步化表达</p></li> <li><p>控制流管理</p></li> <li><p>部署 Iterator接口</p></li> <li><p>作为数据结构</p></li> <li><p>说一下macrotask 和 microtask？</p></li> <li><p>fetch api</p></li> <li><p>知道什么是事件委托吗？</p></li> <li><p>如何让网页离线后还能访问</p></li> <li><p>强缓存和协商缓存</p></li> <li><p>script 标签的属性有哪些, script 标签的 defer 和 async 标签的作用与区别, script intergrity的作用</p></li> <li><p>页面加载白屏的原因有哪些，以及如何监控白屏时间，如何优化</p></li> <li><p>数组去重的几种方法</p></li> <li><p>浏览器缓存原理</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/summary/assets/js/app.42468a2d.js" defer></script><script src="/summary/assets/js/2.1ee37bec.js" defer></script><script src="/summary/assets/js/79.020bb0a2.js" defer></script>
  </body>
</html>
